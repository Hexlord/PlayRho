<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: Mathematical functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A Real-Time-Oriented 2-D Physics Engine and Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mathematical functions.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplParams" colspan="2"><a id="ga948ebcbc9ef959d24546e6c8ff848fa6"></a>
template&lt;class TYPE &gt; </td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga948ebcbc9ef959d24546e6c8ff848fa6">playrho::Square</a> (TYPE t) noexcept</td></tr>
<tr class="memdesc:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6c6db0923bcf47c10a118cc613f696"><td class="memTemplParams" colspan="2"><a id="ga7c6c6db0923bcf47c10a118cc613f696"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7c6c6db0923bcf47c10a118cc613f696"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga7c6c6db0923bcf47c10a118cc613f696">playrho::Sqrt</a> (T t)</td></tr>
<tr class="memdesc:ga7c6c6db0923bcf47c10a118cc613f696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root's the given value. <br /></td></tr>
<tr class="separator:ga7c6c6db0923bcf47c10a118cc613f696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2"><a id="gab870a9188fcc77c905807fa718a8268d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gab870a9188fcc77c905807fa718a8268d">playrho::Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values. <br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab938c6a06d9b25eae154d0197a7ac78f"><td class="memTemplParams" colspan="2"><a id="gab938c6a06d9b25eae154d0197a7ac78f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:gab938c6a06d9b25eae154d0197a7ac78f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gab938c6a06d9b25eae154d0197a7ac78f">playrho::Atan2</a> (double y, double x)</td></tr>
<tr class="memdesc:gab938c6a06d9b25eae154d0197a7ac78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values. <br /></td></tr>
<tr class="separator:gab938c6a06d9b25eae154d0197a7ac78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6c1bdecbda95a4bacb7d1a84b7e641"><td class="memTemplParams" colspan="2"><a id="gaec6c1bdecbda95a4bacb7d1a84b7e641"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaec6c1bdecbda95a4bacb7d1a84b7e641"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gaec6c1bdecbda95a4bacb7d1a84b7e641">playrho::Abs</a> (T a)</td></tr>
<tr class="memdesc:gaec6c1bdecbda95a4bacb7d1a84b7e641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of the given value. <br /></td></tr>
<tr class="separator:gaec6c1bdecbda95a4bacb7d1a84b7e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memTemplParams" colspan="2"><a id="ga7b2db834a9d392a7e63660f5dca67c73"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga7b2db834a9d392a7e63660f5dca67c73">playrho::Average</a> (<a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const T &gt; span)</td></tr>
<tr class="memdesc:ga7b2db834a9d392a7e63660f5dca67c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba78027341c78618a96cc650ccc56b59"><td class="memTemplParams" colspan="2"><a id="gaba78027341c78618a96cc650ccc56b59"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaba78027341c78618a96cc650ccc56b59"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gaba78027341c78618a96cc650ccc56b59">playrho::Round</a> (T value, unsigned precision=100000)</td></tr>
<tr class="memdesc:gaba78027341c78618a96cc650ccc56b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:gaba78027341c78618a96cc650ccc56b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade37e04b2ab99cdbfa7b349b6f18f471"><td class="memTemplParams" colspan="2"><a id="gade37e04b2ab99cdbfa7b349b6f18f471"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:gade37e04b2ab99cdbfa7b349b6f18f471"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gade37e04b2ab99cdbfa7b349b6f18f471">playrho::Round</a> (float value, std::uint32_t precision)</td></tr>
<tr class="memdesc:gade37e04b2ab99cdbfa7b349b6f18f471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:gade37e04b2ab99cdbfa7b349b6f18f471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1966cda06592dacb7f0b556e6e4f1b28"><td class="memTemplParams" colspan="2"><a id="ga1966cda06592dacb7f0b556e6e4f1b28"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga1966cda06592dacb7f0b556e6e4f1b28"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga1966cda06592dacb7f0b556e6e4f1b28">playrho::Round</a> (double value, std::uint32_t precision)</td></tr>
<tr class="memdesc:ga1966cda06592dacb7f0b556e6e4f1b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga1966cda06592dacb7f0b556e6e4f1b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d698a85e2fcc2dbbf44fa52d40e4654"><td class="memTemplParams" colspan="2"><a id="ga1d698a85e2fcc2dbbf44fa52d40e4654"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga1d698a85e2fcc2dbbf44fa52d40e4654"><td class="memTemplItemLeft" align="right" valign="top">long double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga1d698a85e2fcc2dbbf44fa52d40e4654">playrho::Round</a> (long double value, std::uint32_t precision)</td></tr>
<tr class="memdesc:ga1d698a85e2fcc2dbbf44fa52d40e4654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga1d698a85e2fcc2dbbf44fa52d40e4654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga395904c6e5897f4897449bd0b1b5366f"><td class="memTemplParams" colspan="2"><a id="ga395904c6e5897f4897449bd0b1b5366f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga395904c6e5897f4897449bd0b1b5366f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga395904c6e5897f4897449bd0b1b5366f">playrho::Round</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> value, std::uint32_t precision)</td></tr>
<tr class="memdesc:ga395904c6e5897f4897449bd0b1b5366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga395904c6e5897f4897449bd0b1b5366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0ad4dc48e056c5f11be37ba14e648ae"><td class="memTemplParams" colspan="2"><a id="gac0ad4dc48e056c5f11be37ba14e648ae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:gac0ad4dc48e056c5f11be37ba14e648ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gac0ad4dc48e056c5f11be37ba14e648ae">playrho::Round</a> (<a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a> value, std::uint32_t precision)</td></tr>
<tr class="memdesc:gac0ad4dc48e056c5f11be37ba14e648ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:gac0ad4dc48e056c5f11be37ba14e648ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b729c7680b3baa4450ebdb434fab13"><td class="memItemLeft" align="right" valign="top"><a id="ga32b729c7680b3baa4450ebdb434fab13"></a>
constexpr <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga32b729c7680b3baa4450ebdb434fab13">playrho::GetVec2</a> (const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> value)</td></tr>
<tr class="memdesc:ga32b729c7680b3baa4450ebdb434fab13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a Vec2 representation of the given value. <br /></td></tr>
<tr class="separator:ga32b729c7680b3baa4450ebdb434fab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ccffffe2da0262013906300190a169"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaa0ccffffe2da0262013906300190a169">playrho::AlmostZero</a> (float value)</td></tr>
<tr class="memdesc:gaa0ccffffe2da0262013906300190a169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group___math.html#gaa0ccffffe2da0262013906300190a169">More...</a><br /></td></tr>
<tr class="separator:gaa0ccffffe2da0262013906300190a169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959834db22987a36e0407b32a41bf070"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga959834db22987a36e0407b32a41bf070">playrho::AlmostZero</a> (double value)</td></tr>
<tr class="memdesc:ga959834db22987a36e0407b32a41bf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group___math.html#ga959834db22987a36e0407b32a41bf070">More...</a><br /></td></tr>
<tr class="separator:ga959834db22987a36e0407b32a41bf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46abe560a1804dc07c49852225f89b5c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga46abe560a1804dc07c49852225f89b5c">playrho::AlmostZero</a> (long double value)</td></tr>
<tr class="memdesc:ga46abe560a1804dc07c49852225f89b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group___math.html#ga46abe560a1804dc07c49852225f89b5c">More...</a><br /></td></tr>
<tr class="separator:ga46abe560a1804dc07c49852225f89b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1880800b48339d780602688865b81f34"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga1880800b48339d780602688865b81f34">playrho::AlmostZero</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> value)</td></tr>
<tr class="memdesc:ga1880800b48339d780602688865b81f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group___math.html#ga1880800b48339d780602688865b81f34">More...</a><br /></td></tr>
<tr class="separator:ga1880800b48339d780602688865b81f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga409fb4afbc685fe12c021c3fcfd82f39"><td class="memItemLeft" align="right" valign="top"><a id="ga409fb4afbc685fe12c021c3fcfd82f39"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga409fb4afbc685fe12c021c3fcfd82f39">playrho::AlmostEqual</a> (float x, float y, int ulp=2)</td></tr>
<tr class="memdesc:ga409fb4afbc685fe12c021c3fcfd82f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga409fb4afbc685fe12c021c3fcfd82f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6352accdaaa076c198ee0c5439b351"><td class="memItemLeft" align="right" valign="top"><a id="ga9f6352accdaaa076c198ee0c5439b351"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga9f6352accdaaa076c198ee0c5439b351">playrho::AlmostEqual</a> (double x, double y, int ulp=2)</td></tr>
<tr class="memdesc:ga9f6352accdaaa076c198ee0c5439b351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga9f6352accdaaa076c198ee0c5439b351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208fc66b4c19b45662d550002e29d251"><td class="memItemLeft" align="right" valign="top"><a id="ga208fc66b4c19b45662d550002e29d251"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga208fc66b4c19b45662d550002e29d251">playrho::AlmostEqual</a> (long double x, long double y, int ulp=2)</td></tr>
<tr class="memdesc:ga208fc66b4c19b45662d550002e29d251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga208fc66b4c19b45662d550002e29d251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52454a6c44125e206a196197bf377b53"><td class="memItemLeft" align="right" valign="top"><a id="ga52454a6c44125e206a196197bf377b53"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga52454a6c44125e206a196197bf377b53">playrho::AlmostEqual</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> x, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> y, int ulp=2)</td></tr>
<tr class="memdesc:ga52454a6c44125e206a196197bf377b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga52454a6c44125e206a196197bf377b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ac24431ece2665105981c22c6d7948"><td class="memItemLeft" align="right" valign="top"><a id="ga76ac24431ece2665105981c22c6d7948"></a>
<a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga76ac24431ece2665105981c22c6d7948">playrho::GetAngle</a> (const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> value)</td></tr>
<tr class="memdesc:ga76ac24431ece2665105981c22c6d7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle of the given unit vector. <br /></td></tr>
<tr class="separator:ga76ac24431ece2665105981c22c6d7948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81733e33485b5ff68d011a82dd357566"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81733e33485b5ff68d011a82dd357566"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga81733e33485b5ff68d011a82dd357566">playrho::GetAngle</a> (const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt; value)</td></tr>
<tr class="memdesc:ga81733e33485b5ff68d011a82dd357566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <a href="group___math.html#ga81733e33485b5ff68d011a82dd357566">More...</a><br /></td></tr>
<tr class="separator:ga81733e33485b5ff68d011a82dd357566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d14d99d2cc4a54a08173adfb756d065"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9d14d99d2cc4a54a08173adfb756d065"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga9d14d99d2cc4a54a08173adfb756d065">playrho::GetLengthSquared</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga9d14d99d2cc4a54a08173adfb756d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the length/magnitude of the given value.  <a href="group___math.html#ga9d14d99d2cc4a54a08173adfb756d065">More...</a><br /></td></tr>
<tr class="separator:ga9d14d99d2cc4a54a08173adfb756d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5564ab7a0000f49a95b83a2e39c30a9d"><td class="memTemplParams" colspan="2"><a id="ga5564ab7a0000f49a95b83a2e39c30a9d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga5564ab7a0000f49a95b83a2e39c30a9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga5564ab7a0000f49a95b83a2e39c30a9d">playrho::GetLengthSquared</a> (<a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> value) noexcept</td></tr>
<tr class="memdesc:ga5564ab7a0000f49a95b83a2e39c30a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the length/magnitude of the given value. <br /></td></tr>
<tr class="separator:ga5564ab7a0000f49a95b83a2e39c30a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad373ae4d5a24ad222d357ed9a7fa9624"><td class="memTemplParams" colspan="2"><a id="gad373ae4d5a24ad222d357ed9a7fa9624"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad373ae4d5a24ad222d357ed9a7fa9624"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gad373ae4d5a24ad222d357ed9a7fa9624">playrho::GetLength</a> (T value)</td></tr>
<tr class="memdesc:gad373ae4d5a24ad222d357ed9a7fa9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length/magnitude of the given value. <br /></td></tr>
<tr class="separator:gad373ae4d5a24ad222d357ed9a7fa9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga451c8554a408d41df85a41650e0ada93">playrho::Dot</a> (const T1 a, const T2 b) noexcept</td></tr>
<tr class="memdesc:ga451c8554a408d41df85a41650e0ada93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <a href="group___math.html#ga451c8554a408d41df85a41650e0ada93">More...</a><br /></td></tr>
<tr class="separator:ga451c8554a408d41df85a41650e0ada93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089de743b46b1c3ca519faeda62a7231"><td class="memTemplParams" colspan="2"><a id="ga089de743b46b1c3ca519faeda62a7231"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga089de743b46b1c3ca519faeda62a7231"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga089de743b46b1c3ca519faeda62a7231">playrho::Dot</a> (const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> a, const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:ga089de743b46b1c3ca519faeda62a7231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors. <br /></td></tr>
<tr class="separator:ga089de743b46b1c3ca519faeda62a7231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047238dea70037e2b0f45f52960d1369"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga047238dea70037e2b0f45f52960d1369"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga047238dea70037e2b0f45f52960d1369">playrho::Cross</a> (const T1 a, const T2 b) noexcept</td></tr>
<tr class="memdesc:ga047238dea70037e2b0f45f52960d1369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2D analog of the cross product of two vectors.  <a href="group___math.html#ga047238dea70037e2b0f45f52960d1369">More...</a><br /></td></tr>
<tr class="separator:ga047238dea70037e2b0f45f52960d1369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f7c644750a719f1edbf59161a424ac"><td class="memTemplParams" colspan="2"><a id="gab4f7c644750a719f1edbf59161a424ac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:gab4f7c644750a719f1edbf59161a424ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gab4f7c644750a719f1edbf59161a424ac">playrho::Cross</a> (const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> a, const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:gab4f7c644750a719f1edbf59161a424ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-products the given two values. <br /></td></tr>
<tr class="separator:gab4f7c644750a719f1edbf59161a424ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99816718b268cb90b8939f8fdc788897"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga99816718b268cb90b8939f8fdc788897"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga99816718b268cb90b8939f8fdc788897">playrho::Solve</a> (const <a class="el" href="namespaceplayrho.html#aed006edfc52c4469ef951a19eb0c56e5">Matrix22</a>&lt; U &gt; mat, const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt; b) noexcept</td></tr>
<tr class="memdesc:ga99816718b268cb90b8939f8fdc788897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group___math.html#ga99816718b268cb90b8939f8fdc788897">More...</a><br /></td></tr>
<tr class="separator:ga99816718b268cb90b8939f8fdc788897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplParams" colspan="2"><a id="ga00cc9646bab6ce84d6b4704f8c1e0ade"></a>
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga00cc9646bab6ce84d6b4704f8c1e0ade">playrho::Invert</a> (const <a class="el" href="namespaceplayrho.html#aed006edfc52c4469ef951a19eb0c56e5">Matrix22</a>&lt; IN_TYPE &gt; value) noexcept</td></tr>
<tr class="memdesc:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4795a90a377c5335ce5b1900caf6d24"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gab4795a90a377c5335ce5b1900caf6d24">playrho::Solve33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:gab4795a90a377c5335ce5b1900caf6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group___math.html#gab4795a90a377c5335ce5b1900caf6d24">More...</a><br /></td></tr>
<tr class="separator:gab4795a90a377c5335ce5b1900caf6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga0a0606abee6bd0cc122578a2a640f044">playrho::Solve22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const T b) noexcept</td></tr>
<tr class="memdesc:ga0a0606abee6bd0cc122578a2a640f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group___math.html#ga0a0606abee6bd0cc122578a2a640f044">More...</a><br /></td></tr>
<tr class="separator:ga0a0606abee6bd0cc122578a2a640f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaeaceaa1218e1f86e27e6678db247bc79">playrho::GetInverse22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gaeaceaa1218e1f86e27e6678db247bc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <a href="group___math.html#gaeaceaa1218e1f86e27e6678db247bc79">More...</a><br /></td></tr>
<tr class="separator:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a513e105038f6425bfc83180a69cd3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae7a513e105038f6425bfc83180a69cd3">playrho::GetSymInverse33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gae7a513e105038f6425bfc83180a69cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <a href="group___math.html#gae7a513e105038f6425bfc83180a69cd3">More...</a><br /></td></tr>
<tr class="separator:gae7a513e105038f6425bfc83180a69cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga6aa0aece94173885da01b5e3a6737af7">playrho::GetRevPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga6aa0aece94173885da01b5e3a6737af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.  <a href="group___math.html#ga6aa0aece94173885da01b5e3a6737af7">More...</a><br /></td></tr>
<tr class="separator:ga6aa0aece94173885da01b5e3a6737af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga87b57d633b625c58f9200a201e4664a7">playrho::GetFwdPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga87b57d633b625c58f9200a201e4664a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.  <a href="group___math.html#ga87b57d633b625c58f9200a201e4664a7">More...</a><br /></td></tr>
<tr class="separator:ga87b57d633b625c58f9200a201e4664a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb719b00fc92c4e84de7115834c745d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0fb719b00fc92c4e84de7115834c745d">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga0fb719b00fc92c4e84de7115834c745d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another.  <a href="group___math.html#ga0fb719b00fc92c4e84de7115834c745d">More...</a><br /></td></tr>
<tr class="separator:ga0fb719b00fc92c4e84de7115834c745d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memItemLeft" align="right" valign="top"><a id="ga819a9ef6f9c3d492b5177ca25077618e"></a>
constexpr <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga819a9ef6f9c3d492b5177ca25077618e">playrho::InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga819a9ef6f9c3d492b5177ca25077618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform). <br /></td></tr>
<tr class="separator:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bda380a4236d10c8bf04cbe539312a"><td class="memTemplParams" colspan="2"><a id="ga35bda380a4236d10c8bf04cbe539312a"></a>
template&lt;class T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:ga35bda380a4236d10c8bf04cbe539312a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga35bda380a4236d10c8bf04cbe539312a">playrho::operator*</a> (<a class="el" href="classplayrho_1_1_bounded_value.html">BoundedValue</a>&lt; T, lo, hi &gt; s, <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> u) noexcept</td></tr>
<tr class="memdesc:ga35bda380a4236d10c8bf04cbe539312a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:ga35bda380a4236d10c8bf04cbe539312a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00abc0d55f8c5496b2001d35b4c4babb"><td class="memTemplParams" colspan="2"><a id="ga00abc0d55f8c5496b2001d35b4c4babb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga00abc0d55f8c5496b2001d35b4c4babb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga00abc0d55f8c5496b2001d35b4c4babb">playrho::operator*</a> (const T s, const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> u) noexcept</td></tr>
<tr class="memdesc:ga00abc0d55f8c5496b2001d35b4c4babb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:ga00abc0d55f8c5496b2001d35b4c4babb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeda3e243d3266bb2b94ef3a4b52b5b4"><td class="memTemplParams" colspan="2"><a id="gadeda3e243d3266bb2b94ef3a4b52b5b4"></a>
template&lt;class T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:gadeda3e243d3266bb2b94ef3a4b52b5b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gadeda3e243d3266bb2b94ef3a4b52b5b4">playrho::operator*</a> (<a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> u, <a class="el" href="classplayrho_1_1_bounded_value.html">BoundedValue</a>&lt; T, lo, hi &gt; s) noexcept</td></tr>
<tr class="memdesc:gadeda3e243d3266bb2b94ef3a4b52b5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:gadeda3e243d3266bb2b94ef3a4b52b5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac407c3e398f82d0c39fbbfde44f4386c"><td class="memTemplParams" colspan="2"><a id="gac407c3e398f82d0c39fbbfde44f4386c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gac407c3e398f82d0c39fbbfde44f4386c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gac407c3e398f82d0c39fbbfde44f4386c">playrho::operator*</a> (const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> u, const T s) noexcept</td></tr>
<tr class="memdesc:gac407c3e398f82d0c39fbbfde44f4386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:gac407c3e398f82d0c39fbbfde44f4386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e6519bbead1fc1cf08300b7e35e8f5"><td class="memItemLeft" align="right" valign="top"><a id="gae7e6519bbead1fc1cf08300b7e35e8f5"></a>
constexpr <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gae7e6519bbead1fc1cf08300b7e35e8f5">playrho::operator/</a> (const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> u, const <a class="el" href="classplayrho_1_1_unit_vec2.html#ab21b256a14b20403a84ed7d33dde9733">UnitVec2::value_type</a> s) noexcept</td></tr>
<tr class="memdesc:gae7e6519bbead1fc1cf08300b7e35e8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:gae7e6519bbead1fc1cf08300b7e35e8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7fc7e2730184d22b620c4f1f607611"><td class="memItemLeft" align="right" valign="top"><a id="gaca7fc7e2730184d22b620c4f1f607611"></a>
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaca7fc7e2730184d22b620c4f1f607611">playrho::Mul</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gaca7fc7e2730184d22b620c4f1f607611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A * B. <br /></td></tr>
<tr class="separator:gaca7fc7e2730184d22b620c4f1f607611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471bae6413067374ab8d8262533e402"><td class="memItemLeft" align="right" valign="top"><a id="gab471bae6413067374ab8d8262533e402"></a>
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gab471bae6413067374ab8d8262533e402">playrho::MulT</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gab471bae6413067374ab8d8262533e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:gab471bae6413067374ab8d8262533e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a09da0dbd8012afafebfae98e6ed44f"><td class="memItemLeft" align="right" valign="top"><a id="ga3a09da0dbd8012afafebfae98e6ed44f"></a>
constexpr <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga3a09da0dbd8012afafebfae98e6ed44f">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> &amp;v, const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga3a09da0dbd8012afafebfae98e6ed44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix by a vector. <br /></td></tr>
<tr class="separator:ga3a09da0dbd8012afafebfae98e6ed44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4376524007c74ffb4c62a6d843504cef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4376524007c74ffb4c62a6d843504cef"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga4376524007c74ffb4c62a6d843504cef">playrho::Rotate</a> (const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt; vector, const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga4376524007c74ffb4c62a6d843504cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a vector by a given angle.  <a href="group___math.html#ga4376524007c74ffb4c62a6d843504cef">More...</a><br /></td></tr>
<tr class="separator:ga4376524007c74ffb4c62a6d843504cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694dc04e2719c4b27bae7aa383bc024b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga694dc04e2719c4b27bae7aa383bc024b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga694dc04e2719c4b27bae7aa383bc024b">playrho::InverseRotate</a> (const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt; vector, const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga694dc04e2719c4b27bae7aa383bc024b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse rotates a vector.  <a href="group___math.html#ga694dc04e2719c4b27bae7aa383bc024b">More...</a><br /></td></tr>
<tr class="separator:ga694dc04e2719c4b27bae7aa383bc024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03f3b19d67e418b538cfeac6c071604"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gad03f3b19d67e418b538cfeac6c071604">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> v, const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> T) noexcept</td></tr>
<tr class="memdesc:gad03f3b19d67e418b538cfeac6c071604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given 2-D vector with the given transformation.  <a href="group___math.html#gad03f3b19d67e418b538cfeac6c071604">More...</a><br /></td></tr>
<tr class="separator:gad03f3b19d67e418b538cfeac6c071604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04485301708620dabf41acda2517892"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gac04485301708620dabf41acda2517892">playrho::InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> v, const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> T) noexcept</td></tr>
<tr class="memdesc:gac04485301708620dabf41acda2517892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transforms the given 2-D vector with the given transformation.  <a href="group___math.html#gac04485301708620dabf41acda2517892">More...</a><br /></td></tr>
<tr class="separator:gac04485301708620dabf41acda2517892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76b0dc85088e062731fd7868aa78a57"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gad76b0dc85088e062731fd7868aa78a57">playrho::Mul</a> (const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;A, const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gad76b0dc85088e062731fd7868aa78a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a given transformation by another given transformation.  <a href="group___math.html#gad76b0dc85088e062731fd7868aa78a57">More...</a><br /></td></tr>
<tr class="separator:gad76b0dc85088e062731fd7868aa78a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6af2739f6bfd0ec9d1e0824c960c3f6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaf6af2739f6bfd0ec9d1e0824c960c3f6">playrho::MulT</a> (const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;A, const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gaf6af2739f6bfd0ec9d1e0824c960c3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse multiplies a given transformation by another given transformation.  <a href="group___math.html#gaf6af2739f6bfd0ec9d1e0824c960c3f6">More...</a><br /></td></tr>
<tr class="separator:gaf6af2739f6bfd0ec9d1e0824c960c3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memTemplParams" colspan="2"><a id="ga8c5b7f3e28aa844cad21eb801d081cd3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga8c5b7f3e28aa844cad21eb801d081cd3">playrho::Abs</a> (<a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a> a)</td></tr>
<tr class="memdesc:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9842d9af8def4938c227e4256f42975"><td class="memTemplParams" colspan="2"><a id="gad9842d9af8def4938c227e4256f42975"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:gad9842d9af8def4938c227e4256f42975"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gad9842d9af8def4938c227e4256f42975">playrho::Abs</a> (<a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> a)</td></tr>
<tr class="memdesc:gad9842d9af8def4938c227e4256f42975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gad9842d9af8def4938c227e4256f42975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa726d0bc106afc7a490573f3d008f6bc"><td class="memItemLeft" align="right" valign="top"><a id="gaa726d0bc106afc7a490573f3d008f6bc"></a>
<a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaa726d0bc106afc7a490573f3d008f6bc">playrho::Abs</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A)</td></tr>
<tr class="memdesc:gaa726d0bc106afc7a490573f3d008f6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gaa726d0bc106afc7a490573f3d008f6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13603b635fc25d5299189e6eddf3816f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13603b635fc25d5299189e6eddf3816f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga13603b635fc25d5299189e6eddf3816f">playrho::Clamp</a> (T value, T low, T high) noexcept</td></tr>
<tr class="memdesc:ga13603b635fc25d5299189e6eddf3816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the given value within the given range (inclusive).  <a href="group___math.html#ga13603b635fc25d5299189e6eddf3816f">More...</a><br /></td></tr>
<tr class="separator:ga13603b635fc25d5299189e6eddf3816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0ad2d1e2b11362e91193d313ee00e78c">playrho::NextPowerOfTwo</a> (std::uint64_t x)</td></tr>
<tr class="memdesc:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <a href="group___math.html#ga0ad2d1e2b11362e91193d313ee00e78c">More...</a><br /></td></tr>
<tr class="separator:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8ec0b7f71ea3d4632a2ff4e7b3f511"><td class="memItemLeft" align="right" valign="top"><a id="ga9d8ec0b7f71ea3d4632a2ff4e7b3f511"></a>
constexpr <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga9d8ec0b7f71ea3d4632a2ff4e7b3f511">playrho::GetTransformation</a> (const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> ctr, const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> rot, const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> localCtr) noexcept</td></tr>
<tr class="memdesc:ga9d8ec0b7f71ea3d4632a2ff4e7b3f511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transformation for the given values. <br /></td></tr>
<tr class="separator:ga9d8ec0b7f71ea3d4632a2ff4e7b3f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0392cc24b3bbc47ca771a03a240a36f2"><td class="memItemLeft" align="right" valign="top"><a id="ga0392cc24b3bbc47ca771a03a240a36f2"></a>
<a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0392cc24b3bbc47ca771a03a240a36f2">playrho::GetTransformation</a> (const <a class="el" href="structplayrho_1_1_position.html">Position</a> pos, const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> local_ctr) noexcept</td></tr>
<tr class="memdesc:ga0392cc24b3bbc47ca771a03a240a36f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transformation for the given values. <br /></td></tr>
<tr class="separator:ga0392cc24b3bbc47ca771a03a240a36f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f84687cb6c4ceff5ff7f1ba75ab193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193">playrho::GetTransformation</a> (const <a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> &amp;sweep, const <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> beta) noexcept</td></tr>
<tr class="memdesc:ga78f84687cb6c4ceff5ff7f1ba75ab193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interpolated transform at a specific time.  <a href="group___math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193">More...</a><br /></td></tr>
<tr class="separator:ga78f84687cb6c4ceff5ff7f1ba75ab193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6b905518bb8caf52657fe4289dc046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gacf6b905518bb8caf52657fe4289dc046">playrho::GetTransform0</a> (const <a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> &amp;sweep) noexcept</td></tr>
<tr class="memdesc:gacf6b905518bb8caf52657fe4289dc046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transform at "time" zero.  <a href="group___math.html#gacf6b905518bb8caf52657fe4289dc046">More...</a><br /></td></tr>
<tr class="separator:gacf6b905518bb8caf52657fe4289dc046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacceda036ecb96e25642e2bd1d6fe9314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gacceda036ecb96e25642e2bd1d6fe9314">playrho::GetTransform1</a> (const <a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> &amp;sweep) noexcept</td></tr>
<tr class="memdesc:gacceda036ecb96e25642e2bd1d6fe9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transform at "time" one.  <a href="group___math.html#gacceda036ecb96e25642e2bd1d6fe9314">More...</a><br /></td></tr>
<tr class="separator:gacceda036ecb96e25642e2bd1d6fe9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee457e0ccdca5de7d892e1eae39e5c5c"><td class="memItemLeft" align="right" valign="top"><a id="gaee457e0ccdca5de7d892e1eae39e5c5c"></a>
<a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaee457e0ccdca5de7d892e1eae39e5c5c">playrho::GetNormalized</a> (<a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> value)</td></tr>
<tr class="memdesc:gaee457e0ccdca5de7d892e1eae39e5c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle. <br /></td></tr>
<tr class="separator:gaee457e0ccdca5de7d892e1eae39e5c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f85d5b0d93d2aa6949bf25e3b378ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1_sweep.html">Sweep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaa8f85d5b0d93d2aa6949bf25e3b378ec">playrho::GetAnglesNormalized</a> (<a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> sweep) noexcept</td></tr>
<tr class="memdesc:gaa8f85d5b0d93d2aa6949bf25e3b378ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a sweep with the given sweeps's angles normalized.  <a href="group___math.html#gaa8f85d5b0d93d2aa6949bf25e3b378ec">More...</a><br /></td></tr>
<tr class="separator:gaa8f85d5b0d93d2aa6949bf25e3b378ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top"><a id="ga0c7d2525a406c1f83c0574e46a2cee32"></a>
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0c7d2525a406c1f83c0574e46a2cee32">playrho::Normalize</a> (<a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465149bd133986e36f6e964839ea863c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#ac0ff68214afc679c84744ef5316134b9">LinearVelocity2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga465149bd133986e36f6e964839ea863c">playrho::GetContactRelVelocity</a> (const <a class="el" href="structplayrho_1_1_velocity.html">Velocity</a> velA, const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> relA, const <a class="el" href="structplayrho_1_1_velocity.html">Velocity</a> velB, const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> relB) noexcept</td></tr>
<tr class="memdesc:ga465149bd133986e36f6e964839ea863c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contact relative velocity.  <a href="group___math.html#ga465149bd133986e36f6e964839ea863c">More...</a><br /></td></tr>
<tr class="separator:ga465149bd133986e36f6e964839ea863c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c9c8c4952457013f24cbebf8712b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga41c9c8c4952457013f24cbebf8712b6a">playrho::ComputeCentroid</a> (const <a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:ga41c9c8c4952457013f24cbebf8712b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <a href="group___math.html#ga41c9c8c4952457013f24cbebf8712b6a">More...</a><br /></td></tr>
<tr class="separator:ga41c9c8c4952457013f24cbebf8712b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memTemplParams" colspan="2"><a id="gaf9689e93a5538424dfb54bbbb78ad217"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gaf9689e93a5538424dfb54bbbb78ad217">playrho::GetModuloNext</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:gaf9689e93a5538424dfb54bbbb78ad217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value. <br /></td></tr>
<tr class="separator:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e627f196ec102af9dd855d05611a6e"><td class="memTemplParams" colspan="2"><a id="ga37e627f196ec102af9dd855d05611a6e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37e627f196ec102af9dd855d05611a6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga37e627f196ec102af9dd855d05611a6e">playrho::GetModuloPrev</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:ga37e627f196ec102af9dd855d05611a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value. <br /></td></tr>
<tr class="separator:ga37e627f196ec102af9dd855d05611a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dcf271b85b501cd2d7188902066e55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga07dcf271b85b501cd2d7188902066e55">playrho::GetRevRotationalAngle</a> (<a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga07dcf271b85b501cd2d7188902066e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2.  <a href="group___math.html#ga07dcf271b85b501cd2d7188902066e55">More...</a><br /></td></tr>
<tr class="separator:ga07dcf271b85b501cd2d7188902066e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae823a948ef9acfe088c2f44923ac45bb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae823a948ef9acfe088c2f44923ac45bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gae823a948ef9acfe088c2f44923ac45bb">playrho::GetUnitVector</a> (const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt; value, const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> fallback=<a class="el" href="classplayrho_1_1_unit_vec2.html#a2b7eb358d02072690a14ef4cbe2990ff">UnitVec2::GetDefaultFallback</a>())</td></tr>
<tr class="memdesc:gae823a948ef9acfe088c2f44923ac45bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unit vector for the given value.  <a href="group___math.html#gae823a948ef9acfe088c2f44923ac45bb">More...</a><br /></td></tr>
<tr class="separator:gae823a948ef9acfe088c2f44923ac45bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32865e179a32d11cc371b0645b9cb14"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf32865e179a32d11cc371b0645b9cb14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gaf32865e179a32d11cc371b0645b9cb14">playrho::GetUnitVector</a> (<a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt; value, T &amp;magnitude, <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> fallback=<a class="el" href="classplayrho_1_1_unit_vec2.html#a2b7eb358d02072690a14ef4cbe2990ff">UnitVec2::GetDefaultFallback</a>())</td></tr>
<tr class="memdesc:gaf32865e179a32d11cc371b0645b9cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unit vector for the given value.  <a href="group___math.html#gaf32865e179a32d11cc371b0645b9cb14">More...</a><br /></td></tr>
<tr class="separator:gaf32865e179a32d11cc371b0645b9cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb7e9b018f4faa848adae8508415724"><td class="memTemplParams" colspan="2"><a id="ga4eb7e9b018f4faa848adae8508415724"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga4eb7e9b018f4faa848adae8508415724"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga4eb7e9b018f4faa848adae8508415724">playrho::GetUnitVector</a> (<a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; value, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &amp;magnitude, <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> fallback)</td></tr>
<tr class="memdesc:ga4eb7e9b018f4faa848adae8508415724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unit vector of the given value. <br /></td></tr>
<tr class="separator:ga4eb7e9b018f4faa848adae8508415724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d11734080c6a83d9946ce954f0fff13"><td class="memItemLeft" align="right" valign="top"><a id="ga2d11734080c6a83d9946ce954f0fff13"></a>
std::vector&lt; <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga2d11734080c6a83d9946ce954f0fff13">playrho::GetCircleVertices</a> (<a class="el" href="group___quantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius, unsigned slices, <a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> start=<a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{0}, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> turns=<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{1})</td></tr>
<tr class="memdesc:ga2d11734080c6a83d9946ce954f0fff13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga2d11734080c6a83d9946ce954f0fff13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memItemLeft" align="right" valign="top"><a id="ga0eb57dabfe8d3db9e509a6b493173358"></a>
<a class="el" href="group___bounded_aliases.html#gafc08c4f8490a39cbd018110ec9e5aa33">NonNegative</a>&lt; <a class="el" href="group___quantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0eb57dabfe8d3db9e509a6b493173358">playrho::GetAreaOfCircle</a> (<a class="el" href="group___quantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius)</td></tr>
<tr class="memdesc:ga0eb57dabfe8d3db9e509a6b493173358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a cirlce. <br /></td></tr>
<tr class="separator:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5bd0f70fd6c0282d8574d260b4cee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___bounded_aliases.html#gafc08c4f8490a39cbd018110ec9e5aa33">NonNegative</a>&lt; <a class="el" href="group___quantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gaec5bd0f70fd6c0282d8574d260b4cee3">playrho::GetAreaOfPolygon</a> (<a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt; vertices)</td></tr>
<tr class="memdesc:gaec5bd0f70fd6c0282d8574d260b4cee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <a href="group___math.html#gaec5bd0f70fd6c0282d8574d260b4cee3">More...</a><br /></td></tr>
<tr class="separator:gaec5bd0f70fd6c0282d8574d260b4cee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195315e7fcf3732d5d4310705c761c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___quantities.html#ga84a494e0a8763db409c32bde53324b06">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga195315e7fcf3732d5d4310705c761c9f">playrho::GetPolarMoment</a> (<a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga195315e7fcf3732d5d4310705c761c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <a href="group___math.html#ga195315e7fcf3732d5d4310705c761c9f">More...</a><br /></td></tr>
<tr class="separator:ga195315e7fcf3732d5d4310705c761c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These are non-member non-friend functions for mathematical operations especially those with mixed input and output types. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa0ccffffe2da0262013906300190a169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ccffffe2da0262013906300190a169">&#9670;&nbsp;</a></span>AlmostZero() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga959834db22987a36e0407b32a41bf070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga959834db22987a36e0407b32a41bf070">&#9670;&nbsp;</a></span>AlmostZero() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga46abe560a1804dc07c49852225f89b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46abe560a1804dc07c49852225f89b5c">&#9670;&nbsp;</a></span>AlmostZero() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga1880800b48339d780602688865b81f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1880800b48339d780602688865b81f34">&#9670;&nbsp;</a></span>AlmostZero() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga13603b635fc25d5299189e6eddf3816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13603b635fc25d5299189e6eddf3816f">&#9670;&nbsp;</a></span>Clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to clamp. </td></tr>
    <tr><td class="paramname">low</td><td>Lowest value to return or NaN to keep the low-end unbounded. </td></tr>
    <tr><td class="paramname">high</td><td>Highest value to return or NaN to keep the high-end unbounded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41c9c8c4952457013f24cbebf8712b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c9c8c4952457013f24cbebf8712b6a">&#9670;&nbsp;</a></span>ComputeCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> playrho::ComputeCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if there are less than 3 vertices or the vertices don't go counter-clockwise. </dd></dl>

</div>
</div>
<a id="ga047238dea70037e2b0f45f52960d1369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047238dea70037e2b0f45f52960d1369">&#9670;&nbsp;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Cross </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defined as the result of: <code>(a.x * b.y) - (a.y * b.x)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is dimension squashing. I.e. A cross of a 2-D length by a 2-D unit vector results in a 1-D length value. </dd>
<dd>
The unit of the result is the 1-D product of the inputs. </dd>
<dd>
This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd>
<dd>
The result will be 0 if any of the following are true: vector A or vector B has a length of zero; vectors A and B point in the same direction; or vectors A and B point in exactly opposite direction of each other. </dd>
<dd>
The result will be positive if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of greater than 0 and less than 180 degrees (counter-clockwise from A being a positive angle). </dd>
<dd>
Result will be negative if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of less than 0 and greater than -180 degrees (clockwise from A being a negative angle). </dd>
<dd>
The absolute value of the result is the area of the parallelogram formed by the vectors A and B.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> A. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two vectors. </dd></dl>

</div>
</div>
<a id="ga451c8554a408d41df85a41650e0ada93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451c8554a408d41df85a41650e0ada93">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Dot </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dot product of two vectors is defined as: the magnitude of vector A, multiplied by, the magnitude of vector B, multiplied by, the cosine of the angle between the two vectors (A and B). Thus the dot product of two vectors is a value ranging between plus and minus the magnitudes of each vector times each other. The middle value of 0 indicates that two vectors are perpendicular to each other (at an angle of +/- 90 degrees from each other).</p>
<dl class="section note"><dt>Note</dt><dd>This operation is commutative. I.e. Dot(a, b) == Dot(b, a). </dd>
<dd>
If A and B are the same vectors, <a class="el" href="group___math.html#ga5564ab7a0000f49a95b83a2e39c30a9d" title="Gets the square of the length/magnitude of the given value. ">GetLengthSquared(Vec2)</a> returns the same value using effectively one less input parameter.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> A. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors (0 means the two vectors are perpendicular). </dd></dl>

</div>
</div>
<a id="ga81733e33485b5ff68d011a82dd357566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81733e33485b5ff68d011a82dd357566">&#9670;&nbsp;</a></span>GetAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Angular value in the range of -Pi to +Pi radians. </dd></dl>

</div>
</div>
<a id="gaa8f85d5b0d93d2aa6949bf25e3b378ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f85d5b0d93d2aa6949bf25e3b378ec">&#9670;&nbsp;</a></span>GetAnglesNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> playrho::GetAnglesNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1_sweep.html">Sweep</a>&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1_sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> to return with its angles normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classplayrho_1_1_sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> with its pos0 angle to be between -2 pi and 2 pi and its pos1 angle reduced by the amount pos0's angle was reduced by. </dd></dl>

</div>
</div>
<a id="gaec5bd0f70fd6c0282d8574d260b4cee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5bd0f70fd6c0282d8574d260b4cee3">&#9670;&nbsp;</a></span>GetAreaOfPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___bounded_aliases.html#gafc08c4f8490a39cbd018110ec9e5aa33">NonNegative</a>&lt; <a class="el" href="group___quantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt; playrho::GetAreaOfPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is valid for any non-self-intersecting (simple) polygon, which can be convex or concave. </dd>
<dd>
Winding order doesn't matter. </dd></dl>

</div>
</div>
<a id="ga465149bd133986e36f6e964839ea863c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga465149bd133986e36f6e964839ea863c">&#9670;&nbsp;</a></span>GetContactRelVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#ac0ff68214afc679c84744ef5316134b9">LinearVelocity2D</a> playrho::GetContactRelVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_velocity.html">Velocity</a>&#160;</td>
          <td class="paramname"><em>velA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td>
          <td class="paramname"><em>relA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_velocity.html">Velocity</a>&#160;</td>
          <td class="paramname"><em>velB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td>
          <td class="paramname"><em>relB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>If relA and relB are the zero vectors, the resulting value is simply velB.linear - velA.linear. </dd></dl>

</div>
</div>
<a id="ga87b57d633b625c58f9200a201e4664a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b57d633b625c58f9200a201e4664a7">&#9670;&nbsp;</a></span>GetFwdPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetFwdPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes a vector of form (x, y) and returns the vector (y, -x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> to return a clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga6aa0aece94173885da01b5e3a6737af7" title="Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector. ">GetRevPerpendicular</a>. </dd></dl>

</div>
</div>
<a id="gaeaceaa1218e1f86e27e6678db247bc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaceaa1218e1f86e27e6678db247bc79">&#9670;&nbsp;</a></span>GetInverse22()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> playrho::GetInverse22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

</div>
</div>
<a id="ga9d14d99d2cc4a54a08173adfb756d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d14d99d2cc4a54a08173adfb756d065">&#9670;&nbsp;</a></span>GetLengthSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetLengthSquared </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>For performance, use this instead of <a class="el" href="group___math.html#gad373ae4d5a24ad222d357ed9a7fa9624" title="Gets the length/magnitude of the given value. ">GetLength(T value)</a> (if possible). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value. </dd></dl>

</div>
</div>
<a id="ga195315e7fcf3732d5d4310705c761c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga195315e7fcf3732d5d4310705c761c9f">&#9670;&nbsp;</a></span>GetPolarMoment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___quantities.html#ga84a494e0a8763db409c32bde53324b06">SecondMomentOfArea</a> playrho::GetPolarMoment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1_span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if given collection has less than 3 vertices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Collection of three or more vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6aa0aece94173885da01b5e3a6737af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa0aece94173885da01b5e3a6737af7">&#9670;&nbsp;</a></span>GetRevPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetRevPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This takes a vector of form (x, y) and returns the vector (-y, x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> to return a counter-clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A counter-clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga87b57d633b625c58f9200a201e4664a7" title="Gets a vector clockwise (forward-clockwise) perpendicular to the given vector. ">GetFwdPerpendicular</a>. </dd></dl>

</div>
</div>
<a id="ga07dcf271b85b501cd2d7188902066e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07dcf271b85b501cd2d7188902066e55">&#9670;&nbsp;</a></span>GetRevRotationalAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetRevRotationalAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___quantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The given angles must be normalized between -Pi to Pi radians. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Angular rotation in the counter clockwise direction to go from angle 1 to angle 2. </dd></dl>

</div>
</div>
<a id="gae7a513e105038f6425bfc83180a69cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a513e105038f6425bfc83180a69cd3">&#9670;&nbsp;</a></span>GetSymInverse33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> playrho::GetSymInverse33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

</div>
</div>
<a id="gacf6b905518bb8caf52657fe4289dc046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6b905518bb8caf52657fe4289dc046">&#9670;&nbsp;</a></span>GetTransform0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> playrho::GetTransform0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is like calling GetTransformation(sweep, 0), except more efficiently. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193" title="Gets the interpolated transform at a specific time. ">GetTransformation(const Sweep&amp; sweep, Real beta)</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1_sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> data to get the transform from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structplayrho_1_1_transformation.html" title="Describes a geometric transformation. ">Transformation</a> of the given sweep at time zero. </dd></dl>

</div>
</div>
<a id="gacceda036ecb96e25642e2bd1d6fe9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacceda036ecb96e25642e2bd1d6fe9314">&#9670;&nbsp;</a></span>GetTransform1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> playrho::GetTransform1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is like calling GetTransformation(sweep, 1.0), except more efficiently. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193" title="Gets the interpolated transform at a specific time. ">GetTransformation(const Sweep&amp; sweep, Real beta)</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1_sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> data to get the transform from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structplayrho_1_1_transformation.html" title="Describes a geometric transformation. ">Transformation</a> of the given sweep at time one. </dd></dl>

</div>
</div>
<a id="ga78f84687cb6c4ceff5ff7f1ba75ab193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f84687cb6c4ceff5ff7f1ba75ab193">&#9670;&nbsp;</a></span>GetTransformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> playrho::GetTransformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_sweep.html">Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>sweep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1_sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> data to get the transform from. </td></tr>
    <tr><td class="paramname">beta</td><td>Time factor in [0,1], where 0 indicates alpha0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structplayrho_1_1_transformation.html" title="Describes a geometric transformation. ">Transformation</a> of the given sweep at the specified time. </dd></dl>

</div>
</div>
<a id="gae823a948ef9acfe088c2f44923ac45bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae823a948ef9acfe088c2f44923ac45bb">&#9670;&nbsp;</a></span>GetUnitVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> playrho::GetUnitVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a>&#160;</td>
          <td class="paramname"><em>fallback</em> = <code><a class="el" href="classplayrho_1_1_unit_vec2.html#a2b7eb358d02072690a14ef4cbe2990ff">UnitVec2::GetDefaultFallback</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to get the unit vector for. </td></tr>
    <tr><td class="paramname">fallback</td><td>Fallback unit vector value to use in case a unit vector can't effectively be calculated from the given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value divided by its length if length not almost zero otherwise invalid value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga409fb4afbc685fe12c021c3fcfd82f39" title="Determines whether the given two values are &quot;almost equal&quot;. ">AlmostEqual</a>. </dd></dl>

</div>
</div>
<a id="gaf32865e179a32d11cc371b0645b9cb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf32865e179a32d11cc371b0645b9cb14">&#9670;&nbsp;</a></span>GetUnitVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> playrho::GetUnitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a>&#160;</td>
          <td class="paramname"><em>fallback</em> = <code><a class="el" href="classplayrho_1_1_unit_vec2.html#a2b7eb358d02072690a14ef4cbe2990ff">UnitVec2::GetDefaultFallback</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to get the unit vector for. </td></tr>
    <tr><td class="paramname">magnitude</td><td>Returns the calculated magnitude of the given vector. </td></tr>
    <tr><td class="paramname">fallback</td><td>Fallback unit vector value to use in case a unit vector can't effectively be calculated from the given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value divided by its length if length not almost zero otherwise invalid value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga409fb4afbc685fe12c021c3fcfd82f39" title="Determines whether the given two values are &quot;almost equal&quot;. ">AlmostEqual</a>. </dd></dl>

</div>
</div>
<a id="ga694dc04e2719c4b27bae7aa383bc024b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694dc04e2719c4b27bae7aa383bc024b">&#9670;&nbsp;</a></span>InverseRotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InverseRotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the inverse of rotating a vector - it undoes what rotate does. I.e. this effectively subtracts from the angle of the given vector the angle that's expressed by the angle parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> to reverse rotate. </td></tr>
    <tr><td class="paramname">angle</td><td>Expresses the angle to reverse rotate the given vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga4376524007c74ffb4c62a6d843504cef" title="Rotates a vector by a given angle. ">Rotate</a>. </dd></dl>

</div>
</div>
<a id="gac04485301708620dabf41acda2517892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04485301708620dabf41acda2517892">&#9670;&nbsp;</a></span>InverseTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> playrho::InverseTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverse translate and rotate the given 2-D vector according to the translation and rotation defined by the given transformation. </p><dl class="section note"><dt>Note</dt><dd>Passing the output of this function to <code>Transform</code> (with the same transformation again) will result in the original vector being returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceplayrho.html#acfb5cb3d85d392c4f66421044d17c0ca" title="Transforms the given shape by the given transformation. ">Transform</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>2-D vector to inverse transform (inverse translate and inverse rotate). </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="structplayrho_1_1_transformation.html" title="Describes a geometric transformation. ">Transformation</a> (a translation and rotation) to inversely apply to the given vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse transformed vector. </dd></dl>

</div>
</div>
<a id="gad76b0dc85088e062731fd7868aa78a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76b0dc85088e062731fd7868aa78a57">&#9670;&nbsp;</a></span>Mul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> playrho::Mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p </dd></dl>

</div>
</div>
<a id="gaf6af2739f6bfd0ec9d1e0824c960c3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6af2739f6bfd0ec9d1e0824c960c3f6">&#9670;&nbsp;</a></span>MulT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> playrho::MulT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>v2 = A.q' * (B.q * v1 + B.p - A.p) = A.q' * B.q * v1 + A.q' * (B.p - A.p) </dd></dl>

</div>
</div>
<a id="ga0ad2d1e2b11362e91193d313ee00e78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad2d1e2b11362e91193d313ee00e78c">&#9670;&nbsp;</a></span>NextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t playrho::NextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next largest power of 2. For a 64-bit value:" </p>

</div>
</div>
<a id="ga4376524007c74ffb4c62a6d843504cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4376524007c74ffb4c62a6d843504cef">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1_unit_vec2.html">UnitVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This rotates a vector by the angle expressed by the angle parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1_vector.html" title="Vector. ">Vector</a> to forward rotate. </td></tr>
    <tr><td class="paramname">angle</td><td>Expresses the angle to forward rotate the given vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___math.html#ga694dc04e2719c4b27bae7aa383bc024b" title="Inverse rotates a vector. ">InverseRotate</a>. </dd></dl>

</div>
</div>
<a id="ga99816718b268cb90b8939f8fdc788897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99816718b268cb90b8939f8fdc788897">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aed006edfc52c4469ef951a19eb0c56e5">Matrix22</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a604e6eb39adcd8462cd7e93c95662daa">Vector2D</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

</div>
</div>
<a id="ga0a0606abee6bd0cc122578a2a640f044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0606abee6bd0cc122578a2a640f044">&#9670;&nbsp;</a></span>Solve22()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Solve22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd>
<dd>
Solves only the upper 2-by-2 matrix equation. </dd></dl>

</div>
</div>
<a id="gab4795a90a377c5335ce5b1900caf6d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4795a90a377c5335ce5b1900caf6d24">&#9670;&nbsp;</a></span>Solve33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a> playrho::Solve33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a6279f900778baa0d49f4257e523dc7a3">Vec3</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

</div>
</div>
<a id="ga0fb719b00fc92c4e84de7115834c745d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb719b00fc92c4e84de7115834c745d">&#9670;&nbsp;</a></span>Transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a> playrho::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a2f167875642767a3c687d78feb01c731">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a matrix by a vector. </p>

</div>
</div>
<a id="gad03f3b19d67e418b538cfeac6c071604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03f3b19d67e418b538cfeac6c071604">&#9670;&nbsp;</a></span>Transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a> playrho::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a8c25d36dc5524be1b25cbe4f267a27ba">Length2D</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1_transformation.html">Transformation</a>&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotate and translate the given 2-D linear position according to the rotation and translation defined by the given transformation. </p><dl class="section note"><dt>Note</dt><dd>Passing the output of this function to <code>InverseTransform</code> (with the same transformation again) will result in the original vector being returned. </dd>
<dd>
For a 2-D linear position of the origin (0, 0), the result is simply the translation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group___math.html#ga819a9ef6f9c3d492b5177ca25077618e" title="Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms th...">InverseTransform</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>2-D position to transform (to rotate and then translate). </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="structplayrho_1_1_transformation.html" title="Describes a geometric transformation. ">Transformation</a> (a translation and rotation) to apply to the given vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotated and translated vector. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 21 2017 15:05:54 for PlayRho by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
