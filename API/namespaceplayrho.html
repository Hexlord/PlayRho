<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: playrho Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A Real-Time-Oriented 2-D Physics Engine and Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceplayrho.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">playrho Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Name space for all PlayRho related names.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceplayrho_1_1d2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1d2.html">d2</a></td></tr>
<tr class="memdesc:namespaceplayrho_1_1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name space for 2-dimensionally related PlayRho names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplayrho_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceplayrho_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name space for internal/detail related PlayRho names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1AllocatedArray.html">AllocatedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated Array.  <a href="classplayrho_1_1AllocatedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array list.  <a href="classplayrho_1_1ArrayList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1BlockAllocator_1_1Block.html" title="Block. ">Block</a> allocator.  <a href="classplayrho_1_1BlockAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1BlockDeallocator.html">BlockDeallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block deallocator.  <a href="structplayrho_1_1BlockDeallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value.  <a href="classplayrho_1_1BoundedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint solver configuration data.  <a href="structplayrho_1_1ConstraintSolverConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact Feature.  <a href="structplayrho_1_1ContactFeature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key value class for contacts.  <a href="classplayrho_1_1ContactKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder for contact filtering data.  <a href="structplayrho_1_1Filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for fixed-point numbers.  <a href="classplayrho_1_1Fixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixture proxy.  <a href="structplayrho_1_1FixtureProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1FlagGuard.html">FlagGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag guard type.  <a href="classplayrho_1_1FlagGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1GrowableStack.html">GrowableStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a growable LIFO stack with an initial capacity of N. If the stack size exceeds the initial capacity, the heap is used to increase the size of the stack.  <a href="classplayrho_1_1GrowableStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasOne.html">HasOne</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasOne_3_01T_00_01VoidT_3_01decltype_07T_021_03_08_01_4_01_4.html">HasOne&lt; T, VoidT&lt; decltype(T{1}) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for valid/acceptable "arithmetic" types.  <a href="structplayrho_1_1HasOne_3_01T_00_01VoidT_3_01decltype_07T_021_03_08_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType.html">HasType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait template class.  <a href="structplayrho_1_1HasType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html">HasType&lt; T, std::tuple&lt; T, Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait true class.  <a href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01U_00_01Ts_8_8_8_01_4_01_4.html">HasType&lt; T, std::tuple&lt; U, Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait template super class.  <a href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01U_00_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_4_01_4.html">HasType&lt; T, std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait template class specialized for <code>std::tuple</code> classes.  <a href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classplayrho_1_1Interval.html" title="Interval template type. ">Interval</a> template type.  <a href="classplayrho_1_1Interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1InvalidArgument.html">InvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid argument logic error.  <a href="classplayrho_1_1InvalidArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsArithmetic.html">IsArithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given type is an "arithmetic" type.  <a href="structplayrho_1_1IsArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsArithmetic_3_01T_00_01VoidT_3_01decltype_07T_02_03_09T_02_03_08_00_01decltype0b2e449314e00fef5ceeea648917bc10.html">IsArithmetic&lt; T, VoidT&lt; decltype(T{}+T{}), decltype(T{} - T{}), decltype(T{} *T{}), decltype(T{}/T{}) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for valid/acceptable "arithmetic" types.  <a href="structplayrho_1_1IsArithmetic_3_01T_00_01VoidT_3_01decltype_07T_02_03_09T_02_03_08_00_01decltype0b2e449314e00fef5ceeea648917bc10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsDivisable.html">IsDivisable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsDivisable_3_01T1_00_01T2_00_01VoidT_3_01decltype_07T1_02_03_2T2_02_03_08_4_01_4.html">IsDivisable&lt; T1, T2, VoidT&lt; decltype(T1{}/T2{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IslandStats.html">IslandStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Island solver statistics.  <a href="structplayrho_1_1IslandStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMatrix.html">IsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for checking if type is a matrix type.  <a href="structplayrho_1_1IsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMatrix_3_01Vector_3_01Vector_3_01T_00_01N_01_4_00_01M_01_4_01_4.html">IsMatrix&lt; Vector&lt; Vector&lt; T, N &gt;, M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class specialization for checking if type is a matrix type.  <a href="structplayrho_1_1IsMatrix_3_01Vector_3_01Vector_3_01T_00_01N_01_4_00_01M_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMultipliable_3_01T1_00_01T2_00_01VoidT_3_01decltype_07T1_02_03_01_5T2_02_03_08_4_01_4.html">IsMultipliable&lt; T1, T2, VoidT&lt; decltype(T1{} *T2{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsSquareMatrix.html">IsSquareMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for checking if type is a square matrix type.  <a href="structplayrho_1_1IsSquareMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsSquareMatrix_3_01Vector_3_01Vector_3_01T_00_01M_01_4_00_01M_01_4_01_4.html">IsSquareMatrix&lt; Vector&lt; Vector&lt; T, M &gt;, M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class specialization for checking if type is a square matrix type.  <a href="structplayrho_1_1IsSquareMatrix_3_01Vector_3_01Vector_3_01T_00_01M_01_4_00_01M_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsVector.html">IsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for checking if type is a <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a></code> type.  <a href="structplayrho_1_1IsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsVector_3_01Vector_3_01T_00_01N_01_4_01_4.html">IsVector&lt; Vector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class specialization for checking if type is a <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a></code> type..  <a href="structplayrho_1_1IsVector_3_01Vector_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1LengthError.html">LengthError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length based logic error.  <a href="classplayrho_1_1LengthError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LengthIndexPair.html">LengthIndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A length associated with two vertex counter indices.  <a href="structplayrho_1_1LengthIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Movement configuration.  <a href="structplayrho_1_1MovementConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1OptionalValue.html">OptionalValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value template class.  <a href="classplayrho_1_1OptionalValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1PointStates.html">PointStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point states.  <a href="structplayrho_1_1PointStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1PreStepStats.html">PreStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-phase per-step statistics.  <a href="structplayrho_1_1PreStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template range value class.  <a href="classplayrho_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular-phase per-step statistics.  <a href="structplayrho_1_1RegStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1SizedRange.html">SizedRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template sized range value class.  <a href="classplayrho_1_1SizedRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ encapsulation of an array and its size.  <a href="classplayrho_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1StackAllocator.html">StackAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack allocator.  <a href="classplayrho_1_1StackAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1StepConf.html">StepConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step configuration.  <a href="classplayrho_1_1StepConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1StepStats.html">StepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-step statistics.  <a href="structplayrho_1_1StepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strong type template.  <a href="classplayrho_1_1StrongTyped.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiConf.html">ToiConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time of impact configuration.  <a href="structplayrho_1_1ToiConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TOIOutput.html">TOIOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output data for time of impact.  <a href="structplayrho_1_1TOIOutput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiStepStats.html">ToiStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TOI-phase per-step statistics.  <a href="structplayrho_1_1ToiStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ValueCheckHelper.html">ValueCheckHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value check helper.  <a href="structplayrho_1_1ValueCheckHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ValueCheckHelper_3_01T_00_01std_1_1enable__if__t_3_01HasOne_3_01T_01_4_1_1value_01_4_01_4.html">ValueCheckHelper&lt; T, std::enable_if_t&lt; HasOne&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the value check helper.  <a href="structplayrho_1_1ValueCheckHelper_3_01T_00_01std_1_1enable__if__t_3_01HasOne_3_01T_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a>.  <a href="structplayrho_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Version.html" title="Version numbering scheme. ">Version</a> numbering scheme.  <a href="structplayrho_1_1Version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Voidify.html">Voidify</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voiding template class.  <a href="structplayrho_1_1Voidify.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider.html">Wider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> data type obtainer.  <a href="structplayrho_1_1Wider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01double_01_4.html">Wider&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for double.  <a href="structplayrho_1_1Wider_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01float_01_4.html">Wider&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for float.  <a href="structplayrho_1_1Wider_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1int16__t_01_4.html">Wider&lt; std::int16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for signed 16-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1int16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1int32__t_01_4.html">Wider&lt; std::int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for signed 32-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1int8__t_01_4.html">Wider&lt; std::int8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for signed 8-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1int8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1uint16__t_01_4.html">Wider&lt; std::uint16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for unsigned 16-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1uint16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1uint32__t_01_4.html">Wider&lt; std::uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for unsigned 32-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1uint8__t_01_4.html">Wider&lt; std::uint8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer. ">Wider</a> trait for unsigned 8-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1uint8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1WrongState.html">WrongState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrong state logic error.  <a href="classplayrho_1_1WrongState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae444a62491fcb2b10f0f06a41b1ac406"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">PairLength2</a> = std::pair&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;</td></tr>
<tr class="memdesc:ae444a62491fcb2b10f0f06a41b1ac406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of <code>Length2</code> values.  <a href="#ae444a62491fcb2b10f0f06a41b1ac406">More...</a><br /></td></tr>
<tr class="separator:ae444a62491fcb2b10f0f06a41b1ac406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d449e0a1528c10ae0f241713fb69b40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a> = std::pair&lt; <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>, <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a> &gt;</td></tr>
<tr class="memdesc:a7d449e0a1528c10ae0f241713fb69b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index pair.  <a href="#a7d449e0a1528c10ae0f241713fb69b40">More...</a><br /></td></tr>
<tr class="separator:a7d449e0a1528c10ae0f241713fb69b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704da3b24d9b1f9135e140dcd5420518"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> = std::array&lt; <a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>, <a class="el" href="namespaceplayrho.html#af31cf01d14137889e66fad67223e8e6f">MaxSimplexEdges</a> &gt;</td></tr>
<tr class="memdesc:a704da3b24d9b1f9135e140dcd5420518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of three index-pair elements.  <a href="#a704da3b24d9b1f9135e140dcd5420518">More...</a><br /></td></tr>
<tr class="separator:a704da3b24d9b1f9135e140dcd5420518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8c8047429035c030e233c9503cbec9"><td class="memTemplParams" colspan="2"><a id="a0a8c8047429035c030e233c9503cbec9"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a0a8c8047429035c030e233c9503cbec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0a8c8047429035c030e233c9503cbec9">VertexCounterArray</a> = std::array&lt; <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>, N &gt;</td></tr>
<tr class="memdesc:a0a8c8047429035c030e233c9503cbec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex counter array template alias. <br /></td></tr>
<tr class="separator:a0a8c8047429035c030e233c9503cbec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="memItemLeft" align="right" valign="top"><a id="ae2ea03f9c65d074dfd1aa21b6352f293"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae2ea03f9c65d074dfd1aa21b6352f293">VertexCounter2</a> = <a class="el" href="namespaceplayrho.html#a0a8c8047429035c030e233c9503cbec9">VertexCounterArray</a>&lt; 2 &gt;</td></tr>
<tr class="memdesc:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vertex counter array. <br /></td></tr>
<tr class="separator:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae872dc540686eb8e626643117f8cb62c"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae872dc540686eb8e626643117f8cb62c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#gae872dc540686eb8e626643117f8cb62c">NonNegative</a> = std::enable_if_t&lt;!std::is_pointer&lt; T &gt;::value, <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::ZeroOrMore, HiValueCheck::Any &gt; &gt;</td></tr>
<tr class="memdesc:gae872dc540686eb8e626643117f8cb62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non negative bounded value type. <br /></td></tr>
<tr class="separator:gae872dc540686eb8e626643117f8cb62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b6bab2cd78b32dbd643d341f37b8e5"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68b6bab2cd78b32dbd643d341f37b8e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#ga68b6bab2cd78b32dbd643d341f37b8e5">NonPositive</a> = <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::Any, HiValueCheck::ZeroOrLess &gt;</td></tr>
<tr class="memdesc:ga68b6bab2cd78b32dbd643d341f37b8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non positive bounded value type. <br /></td></tr>
<tr class="separator:ga68b6bab2cd78b32dbd643d341f37b8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae492ff78381a7dc66d271d0ee3b1189d"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae492ff78381a7dc66d271d0ee3b1189d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#gae492ff78381a7dc66d271d0ee3b1189d">Positive</a> = <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::AboveZero, HiValueCheck::Any &gt;</td></tr>
<tr class="memdesc:gae492ff78381a7dc66d271d0ee3b1189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive bounded value type. <br /></td></tr>
<tr class="separator:gae492ff78381a7dc66d271d0ee3b1189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a15a03f8bd917575a6ae1cc06dff112"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a15a03f8bd917575a6ae1cc06dff112"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#ga0a15a03f8bd917575a6ae1cc06dff112">Negative</a> = <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::Any, HiValueCheck::BelowZero &gt;</td></tr>
<tr class="memdesc:ga0a15a03f8bd917575a6ae1cc06dff112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative bounded value type. <br /></td></tr>
<tr class="separator:ga0a15a03f8bd917575a6ae1cc06dff112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf75a03c4b0afaaba95d65ec8ce54b4"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9cf75a03c4b0afaaba95d65ec8ce54b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#ga9cf75a03c4b0afaaba95d65ec8ce54b4">Finite</a> = <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::AboveNegInf, HiValueCheck::BelowPosInf &gt;</td></tr>
<tr class="memdesc:ga9cf75a03c4b0afaaba95d65ec8ce54b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite bounded value type. <br /></td></tr>
<tr class="separator:ga9cf75a03c4b0afaaba95d65ec8ce54b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3eb15a067eb31352543486e8f10f23"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6d3eb15a067eb31352543486e8f10f23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#ga6d3eb15a067eb31352543486e8f10f23">NonZero</a> = std::enable_if_t&lt;!std::is_pointer&lt; T &gt;::value, <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::NonZero, HiValueCheck::Any &gt; &gt;</td></tr>
<tr class="memdesc:ga6d3eb15a067eb31352543486e8f10f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non zero bounded value type. <br /></td></tr>
<tr class="separator:ga6d3eb15a067eb31352543486e8f10f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64c2bdfe3d8c1c0815013d817b4aa32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab64c2bdfe3d8c1c0815013d817b4aa32"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#gab64c2bdfe3d8c1c0815013d817b4aa32">NonNull</a> = std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value, <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::NonZero, HiValueCheck::Any &gt; &gt;</td></tr>
<tr class="memdesc:gab64c2bdfe3d8c1c0815013d817b4aa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-null pointer type.  <a href="group__BoundedAliases.html#gab64c2bdfe3d8c1c0815013d817b4aa32">More...</a><br /></td></tr>
<tr class="separator:gab64c2bdfe3d8c1c0815013d817b4aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434227c634b0a1b975979d4dbc242346"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga434227c634b0a1b975979d4dbc242346"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BoundedAliases.html#ga434227c634b0a1b975979d4dbc242346">UnitInterval</a> = <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, LoValueCheck::ZeroOrMore, HiValueCheck::OneOrLess &gt;</td></tr>
<tr class="memdesc:ga434227c634b0a1b975979d4dbc242346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit interval bounded value type. <br /></td></tr>
<tr class="separator:ga434227c634b0a1b975979d4dbc242346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e61fee8a0be399ed24773ebc3135f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> = <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; std::int32_t, 9 &gt;</td></tr>
<tr class="memdesc:a51e61fee8a0be399ed24773ebc3135f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit fixed precision type.  <a href="#a51e61fee8a0be399ed24773ebc3135f8">More...</a><br /></td></tr>
<tr class="separator:a51e61fee8a0be399ed24773ebc3135f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;, M &gt;</td></tr>
<tr class="memdesc:acbf97bd8e3f0f2ce4588735388f4089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic M by N matrix.  <a href="#acbf97bd8e3f0f2ce4588735388f4089a">More...</a><br /></td></tr>
<tr class="separator:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aabbb6723402cb9e12cf32e17beebc"><td class="memTemplParams" colspan="2"><a id="a26aabbb6723402cb9e12cf32e17beebc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26aabbb6723402cb9e12cf32e17beebc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a> = <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, 2, 2 &gt;</td></tr>
<tr class="memdesc:a26aabbb6723402cb9e12cf32e17beebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix. <br /></td></tr>
<tr class="separator:a26aabbb6723402cb9e12cf32e17beebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memTemplParams" colspan="2"><a id="a92e228aada1d7ca23d9f6c2c9ce3b415"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a92e228aada1d7ca23d9f6c2c9ce3b415">Matrix33</a> = <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, 3, 3 &gt;</td></tr>
<tr class="memdesc:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 matrix. <br /></td></tr>
<tr class="separator:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c09bb6556e3168c0085871358d2f71"><td class="memItemLeft" align="right" valign="top"><a id="a02c09bb6556e3168c0085871358d2f71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:a02c09bb6556e3168c0085871358d2f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of Real elements. <br /></td></tr>
<tr class="separator:a02c09bb6556e3168c0085871358d2f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358c8036b278316ab41b3f35b56342a1"><td class="memItemLeft" align="right" valign="top"><a id="a358c8036b278316ab41b3f35b56342a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a358c8036b278316ab41b3f35b56342a1">Mass22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> &gt;</td></tr>
<tr class="memdesc:a358c8036b278316ab41b3f35b56342a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of Mass elements. <br /></td></tr>
<tr class="separator:a358c8036b278316ab41b3f35b56342a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="memItemLeft" align="right" valign="top"><a id="a507cf0b47bd41371f90aa8f78f1d7c8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a507cf0b47bd41371f90aa8f78f1d7c8a">InvMass22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga370c2a37515b6a8e79468113554f8ba9">InvMass</a> &gt;</td></tr>
<tr class="memdesc:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of <code>InvMass</code> elements. <br /></td></tr>
<tr class="separator:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="memItemLeft" align="right" valign="top"><a id="aabd44d74c5bc530c9b6676c6a61e6b31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> = <a class="el" href="namespaceplayrho.html#a92e228aada1d7ca23d9f6c2c9ce3b415">Matrix33</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 matrix of Real elements. <br /></td></tr>
<tr class="separator:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc56513bd325732410bc4dbb3261299"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbc56513bd325732410bc4dbb3261299"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acbc56513bd325732410bc4dbb3261299">Optional</a> = <a class="el" href="classplayrho_1_1OptionalValue.html">OptionalValue</a>&lt; T &gt;</td></tr>
<tr class="memdesc:acbc56513bd325732410bc4dbb3261299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional type alias.  <a href="#acbc56513bd325732410bc4dbb3261299">More...</a><br /></td></tr>
<tr class="separator:acbc56513bd325732410bc4dbb3261299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc125070a08100d083a1360f7167f87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> = float</td></tr>
<tr class="memdesc:a1fc125070a08100d083a1360f7167f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-number type.  <a href="#a1fc125070a08100d083a1360f7167f87">More...</a><br /></td></tr>
<tr class="separator:a1fc125070a08100d083a1360f7167f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed352724e203ca09595faf0dc6a76e5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#a1b2b91f99d7c6b008048a242cc291d6a">MaxChildCount</a>)&gt;::type</td></tr>
<tr class="memdesc:aed352724e203ca09595faf0dc6a76e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child counter type.  <a href="#aed352724e203ca09595faf0dc6a76e5c">More...</a><br /></td></tr>
<tr class="separator:aed352724e203ca09595faf0dc6a76e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">TimestepIters</a> = std::uint8_t</td></tr>
<tr class="memdesc:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step iterations type.  <a href="#a3898807006fd29cd5c4fc2e1a9cf5536">More...</a><br /></td></tr>
<tr class="separator:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16da705f1b3c51c7fd1b9b1162c258b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#ac43acb3229848771f11e519430b91725">MaxShapeVertices</a>)&gt;::type</td></tr>
<tr class="memdesc:a16da705f1b3c51c7fd1b9b1162c258b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex count type.  <a href="#a16da705f1b3c51c7fd1b9b1162c258b9">More...</a><br /></td></tr>
<tr class="separator:a16da705f1b3c51c7fd1b9b1162c258b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4106d8a0e998a2485196534514527a5a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a>)&gt;::type</td></tr>
<tr class="memdesc:a4106d8a0e998a2485196534514527a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body count type.  <a href="#a4106d8a0e998a2485196534514527a5a">More...</a><br /></td></tr>
<tr class="separator:a4106d8a0e998a2485196534514527a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf0674233f83e8b83b30db98332e129"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a> = <a class="el" href="structplayrho_1_1Wider.html">Wider</a>&lt; <a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a> &gt;::type</td></tr>
<tr class="memdesc:a2bf0674233f83e8b83b30db98332e129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact count type.  <a href="#a2bf0674233f83e8b83b30db98332e129">More...</a><br /></td></tr>
<tr class="separator:a2bf0674233f83e8b83b30db98332e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8ea60dc388d1e92e2e6fa277a32495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aeb8ea60dc388d1e92e2e6fa277a32495">JointCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#a4ea7793500223bfe5600812095e41a72">MaxJoints</a>)&gt;::type</td></tr>
<tr class="memdesc:aeb8ea60dc388d1e92e2e6fa277a32495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint count type.  <a href="#aeb8ea60dc388d1e92e2e6fa277a32495">More...</a><br /></td></tr>
<tr class="separator:aeb8ea60dc388d1e92e2e6fa277a32495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe7bbcc6786a7468f4d7da7a484a65f"><td class="memTemplParams" colspan="2"><a id="abbe7bbcc6786a7468f4d7da7a484a65f"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:abbe7bbcc6786a7468f4d7da7a484a65f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abbe7bbcc6786a7468f4d7da7a484a65f">VoidT</a> = typename <a class="el" href="structplayrho_1_1Voidify.html">Voidify</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:abbe7bbcc6786a7468f4d7da7a484a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void type templated alias. <br /></td></tr>
<tr class="separator:abbe7bbcc6786a7468f4d7da7a484a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a9fb888eae63605b73b61c61ccd17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a592a9fb888eae63605b73b61c61ccd17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a592a9fb888eae63605b73b61c61ccd17">TupleContainsType</a> = typename <a class="el" href="structplayrho_1_1HasType.html">HasType</a>&lt; T, Tuple &gt;::type</td></tr>
<tr class="memdesc:a592a9fb888eae63605b73b61c61ccd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple contains type alias.  <a href="#a592a9fb888eae63605b73b61c61ccd17">More...</a><br /></td></tr>
<tr class="separator:a592a9fb888eae63605b73b61c61ccd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250898c9929b0e6eaf56a1967c568888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a> = PLAYRHO_QUANTITY(boost::units::si::time)</td></tr>
<tr class="memdesc:ga250898c9929b0e6eaf56a1967c568888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time quantity.  <a href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">More...</a><br /></td></tr>
<tr class="separator:ga250898c9929b0e6eaf56a1967c568888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39135cf298be76964c70829ec84a51e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a> = PLAYRHO_QUANTITY(boost::units::si::frequency)</td></tr>
<tr class="memdesc:gad39135cf298be76964c70829ec84a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency quantity.  <a href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">More...</a><br /></td></tr>
<tr class="separator:gad39135cf298be76964c70829ec84a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7361ef2e10e7853a05b64aa433651014"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> = PLAYRHO_QUANTITY(boost::units::si::length)</td></tr>
<tr class="memdesc:ga7361ef2e10e7853a05b64aa433651014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length quantity.  <a href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">More...</a><br /></td></tr>
<tr class="separator:ga7361ef2e10e7853a05b64aa433651014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e944c18ed210626b5829b8ad2813fde"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a> = PLAYRHO_QUANTITY(boost::units::si::velocity)</td></tr>
<tr class="memdesc:ga6e944c18ed210626b5829b8ad2813fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear velocity quantity.  <a href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">More...</a><br /></td></tr>
<tr class="separator:ga6e944c18ed210626b5829b8ad2813fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7de472e7f4a6fa26bff6a655f100e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a> = PLAYRHO_QUANTITY(boost::units::si::acceleration)</td></tr>
<tr class="memdesc:gadf7de472e7f4a6fa26bff6a655f100e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear acceleration quantity.  <a href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">More...</a><br /></td></tr>
<tr class="separator:gadf7de472e7f4a6fa26bff6a655f100e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edfc295416b7690b4f949223b551bc1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> = PLAYRHO_QUANTITY(boost::units::si::mass)</td></tr>
<tr class="memdesc:ga5edfc295416b7690b4f949223b551bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass quantity.  <a href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">More...</a><br /></td></tr>
<tr class="separator:ga5edfc295416b7690b4f949223b551bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370c2a37515b6a8e79468113554f8ba9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga370c2a37515b6a8e79468113554f8ba9">InvMass</a> = PLAYRHO_QUANTITY(boost::units::si::inverse_mass)</td></tr>
<tr class="memdesc:ga370c2a37515b6a8e79468113554f8ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse mass quantity.  <a href="group__PhysicalQuantities.html#ga370c2a37515b6a8e79468113554f8ba9">More...</a><br /></td></tr>
<tr class="separator:ga370c2a37515b6a8e79468113554f8ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea2a7de91fdafccb2e49c3a84117ab5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> = PLAYRHO_QUANTITY(boost::units::si::area)</td></tr>
<tr class="memdesc:ga3ea2a7de91fdafccb2e49c3a84117ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area quantity.  <a href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">More...</a><br /></td></tr>
<tr class="separator:ga3ea2a7de91fdafccb2e49c3a84117ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534c92a63631b49d1e80119a68af8a4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a> = PLAYRHO_QUANTITY(boost::units::si::surface_density)</td></tr>
<tr class="memdesc:ga534c92a63631b49d1e80119a68af8a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area (surface) density quantity.  <a href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">More...</a><br /></td></tr>
<tr class="separator:ga534c92a63631b49d1e80119a68af8a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab999341c050df340ff56a65816a63da9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> = PLAYRHO_QUANTITY(boost::units::si::plane_angle)</td></tr>
<tr class="memdesc:gab999341c050df340ff56a65816a63da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angle quantity.  <a href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">More...</a><br /></td></tr>
<tr class="separator:gab999341c050df340ff56a65816a63da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33f92018f7e8821550296aece465028"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a> = PLAYRHO_QUANTITY(boost::units::si::angular_velocity)</td></tr>
<tr class="memdesc:gac33f92018f7e8821550296aece465028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular velocity quantity.  <a href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">More...</a><br /></td></tr>
<tr class="separator:gac33f92018f7e8821550296aece465028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcce543a0d59f313adb801e2e18ede86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gafcce543a0d59f313adb801e2e18ede86">AngularAcceleration</a> = PLAYRHO_QUANTITY(boost::units::si::angular_acceleration)</td></tr>
<tr class="memdesc:gafcce543a0d59f313adb801e2e18ede86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular acceleration quantity.  <a href="group__PhysicalQuantities.html#gafcce543a0d59f313adb801e2e18ede86">More...</a><br /></td></tr>
<tr class="separator:gafcce543a0d59f313adb801e2e18ede86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbf955ed1cafec5062f074511ee4829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a> = PLAYRHO_QUANTITY(boost::units::si::force)</td></tr>
<tr class="memdesc:gabdbf955ed1cafec5062f074511ee4829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force quantity.  <a href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">More...</a><br /></td></tr>
<tr class="separator:gabdbf955ed1cafec5062f074511ee4829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13e620479b6e4a34fae5a90bcaf9355"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a> = PLAYRHO_QUANTITY(boost::units::si::torque)</td></tr>
<tr class="memdesc:gaa13e620479b6e4a34fae5a90bcaf9355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Torque quantity.  <a href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">More...</a><br /></td></tr>
<tr class="separator:gaa13e620479b6e4a34fae5a90bcaf9355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a494e0a8763db409c32bde53324b06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga84a494e0a8763db409c32bde53324b06">SecondMomentOfArea</a> = PLAYRHO_QUANTITY(boost::units::si::second_moment_of_area)</td></tr>
<tr class="memdesc:ga84a494e0a8763db409c32bde53324b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second moment of area quantity.  <a href="group__PhysicalQuantities.html#ga84a494e0a8763db409c32bde53324b06">More...</a><br /></td></tr>
<tr class="separator:ga84a494e0a8763db409c32bde53324b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67bbb3e4938321efec8d939636bf988e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga67bbb3e4938321efec8d939636bf988e">RotInertia</a> = PLAYRHO_QUANTITY(boost::units::si::moment_of_inertia)</td></tr>
<tr class="memdesc:ga67bbb3e4938321efec8d939636bf988e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotational inertia quantity.  <a href="group__PhysicalQuantities.html#ga67bbb3e4938321efec8d939636bf988e">More...</a><br /></td></tr>
<tr class="separator:ga67bbb3e4938321efec8d939636bf988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6edf71110d3eef58f39dcbb8067ef4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gafa6edf71110d3eef58f39dcbb8067ef4">InvRotInertia</a> = PLAYRHO_QUANTITY(boost::units::si::inverse_moment_of_inertia)</td></tr>
<tr class="memdesc:gafa6edf71110d3eef58f39dcbb8067ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse rotational inertia quantity.  <a href="group__PhysicalQuantities.html#gafa6edf71110d3eef58f39dcbb8067ef4">More...</a><br /></td></tr>
<tr class="separator:gafa6edf71110d3eef58f39dcbb8067ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d281ffd7cf8e2c8897d03a1cae9f1f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a> = PLAYRHO_QUANTITY(boost::units::si::momentum)</td></tr>
<tr class="memdesc:ga1d281ffd7cf8e2c8897d03a1cae9f1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum quantity.  <a href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">More...</a><br /></td></tr>
<tr class="separator:ga1d281ffd7cf8e2c8897d03a1cae9f1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3537d441743bb2f96c612296424f1e43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga3537d441743bb2f96c612296424f1e43">AngularMomentum</a> = PLAYRHO_QUANTITY(boost::units::si::angular_momentum)</td></tr>
<tr class="memdesc:ga3537d441743bb2f96c612296424f1e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular momentum quantity.  <a href="group__PhysicalQuantities.html#ga3537d441743bb2f96c612296424f1e43">More...</a><br /></td></tr>
<tr class="separator:ga3537d441743bb2f96c612296424f1e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97243f194a9406d0fdcf5f6f833851ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97243f194a9406d0fdcf5f6f833851ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:a97243f194a9406d0fdcf5f6f833851ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> with 2-elements.  <a href="#a97243f194a9406d0fdcf5f6f833851ab">More...</a><br /></td></tr>
<tr class="separator:a97243f194a9406d0fdcf5f6f833851ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93c0cd83df090aba6593ffac4b628ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:ad93c0cd83df090aba6593ffac4b628ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> with 2 Real elements.  <a href="#ad93c0cd83df090aba6593ffac4b628ec">More...</a><br /></td></tr>
<tr class="separator:ad93c0cd83df090aba6593ffac4b628ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> &gt;</td></tr>
<tr class="memdesc:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Length quantities.  <a href="#a7dc68cd0ce177e175ae0bb6c39db158d">More...</a><br /></td></tr>
<tr class="separator:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faa31bff8794a0c4191d8b042f7deeb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">LinearVelocity2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a> &gt;</td></tr>
<tr class="memdesc:a2faa31bff8794a0c4191d8b042f7deeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of linear velocity (<code>LinearVelocity</code>) quantities.  <a href="#a2faa31bff8794a0c4191d8b042f7deeb">More...</a><br /></td></tr>
<tr class="separator:a2faa31bff8794a0c4191d8b042f7deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822921028100052d4c6dfb43c7f6c4b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">LinearAcceleration2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a> &gt;</td></tr>
<tr class="memdesc:a5822921028100052d4c6dfb43c7f6c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of linear acceleration (<code>LinearAcceleration</code>) quantities.  <a href="#a5822921028100052d4c6dfb43c7f6c4b">More...</a><br /></td></tr>
<tr class="separator:a5822921028100052d4c6dfb43c7f6c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d09dc7b51321c052b071485357ca1f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">Force2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a> &gt;</td></tr>
<tr class="memdesc:a2d09dc7b51321c052b071485357ca1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Force quantities.  <a href="#a2d09dc7b51321c052b071485357ca1f9">More...</a><br /></td></tr>
<tr class="separator:a2d09dc7b51321c052b071485357ca1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfba2b26f22dcc026361ed5a0ccf3966"><td class="memItemLeft" align="right" valign="top"><a id="acfba2b26f22dcc026361ed5a0ccf3966"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acfba2b26f22dcc026361ed5a0ccf3966">Mass2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> &gt;</td></tr>
<tr class="memdesc:acfba2b26f22dcc026361ed5a0ccf3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Mass quantities. <br /></td></tr>
<tr class="separator:acfba2b26f22dcc026361ed5a0ccf3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f2424eab18780894e83bbc4127fe67"><td class="memItemLeft" align="right" valign="top"><a id="ab4f2424eab18780894e83bbc4127fe67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab4f2424eab18780894e83bbc4127fe67">InvMass2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga370c2a37515b6a8e79468113554f8ba9">InvMass</a> &gt;</td></tr>
<tr class="memdesc:ab4f2424eab18780894e83bbc4127fe67"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of inverse mass (<code>InvMass</code>) quantities. <br /></td></tr>
<tr class="separator:ab4f2424eab18780894e83bbc4127fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa6ffb2e67c2e2f620eed088412b146"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">Momentum2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a> &gt;</td></tr>
<tr class="memdesc:a1fa6ffb2e67c2e2f620eed088412b146"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Momentum quantities.  <a href="#a1fa6ffb2e67c2e2f620eed088412b146">More...</a><br /></td></tr>
<tr class="separator:a1fa6ffb2e67c2e2f620eed088412b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 3 &gt;</td></tr>
<tr class="memdesc:ad07b44f811ac4c7551067fb1d3554ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> with 3-elements.  <a href="#ad07b44f811ac4c7551067fb1d3554ec5">More...</a><br /></td></tr>
<tr class="separator:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f6dcdf3763052ea25099973c7c00ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:a63f6dcdf3763052ea25099973c7c00ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional column vector with 3 elements.  <a href="#a63f6dcdf3763052ea25099973c7c00ad">More...</a><br /></td></tr>
<tr class="separator:a63f6dcdf3763052ea25099973c7c00ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996c0271f83c70e94b485ff59bb468a1"><td class="memItemLeft" align="right" valign="top"><a id="a996c0271f83c70e94b485ff59bb468a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a996c0271f83c70e94b485ff59bb468a1">Mass3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> &gt;</td></tr>
<tr class="memdesc:a996c0271f83c70e94b485ff59bb468a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-element vector of Mass quantities. <br /></td></tr>
<tr class="separator:a996c0271f83c70e94b485ff59bb468a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b57b56d804cd09ae743e670e866d3"><td class="memItemLeft" align="right" valign="top"><a id="a9d3b57b56d804cd09ae743e670e866d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d3b57b56d804cd09ae743e670e866d3">InvMass3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga370c2a37515b6a8e79468113554f8ba9">InvMass</a> &gt;</td></tr>
<tr class="memdesc:a9d3b57b56d804cd09ae743e670e866d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-element vector of inverse mass (<code>InvMass</code>) quantities. <br /></td></tr>
<tr class="separator:a9d3b57b56d804cd09ae743e670e866d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06f67e158a928ef59e4263facac8fb0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">PointState</a> { <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba5ac8cf2fb7a90ff2d0829f5fca4db5b8">PointState::NullState</a>, 
<a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba494a3e62657370358107e2edf3fca5a0">PointState::AddState</a>, 
<a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba60a7f32dd91e5f33a4ca2bc7b7255343">PointState::PersistState</a>, 
<a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba3500ff358c0521359118fe519bd8f605">PointState::RemoveState</a>
 }<tr class="memdesc:a06f67e158a928ef59e4263facac8fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point state enumeration.  <a href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a06f67e158a928ef59e4263facac8fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66189f1fe36ac717e284ab1099171106"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">RayCastOpcode</a> { <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a056fa3d840f48b7bfbbd68c19a4797b3">RayCastOpcode::Terminate</a>, 
<a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106aaf8767ee039cdc51717435bb815da593">RayCastOpcode::IgnoreFixture</a>, 
<a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a8dcfe18b6245b17c9cd69d5af7ef1847">RayCastOpcode::ClipRay</a>, 
<a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a4592f28dc9d11de3ce507bebafd9de16">RayCastOpcode::ResetRay</a>
 }<tr class="memdesc:a66189f1fe36ac717e284ab1099171106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray cast opcode enumeration.  <a href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a66189f1fe36ac717e284ab1099171106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57593cac21168ed673c77a11d18a35ec"><td class="memItemLeft" align="right" valign="top"><a id="a57593cac21168ed673c77a11d18a35ec"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a57593cac21168ed673c77a11d18a35ec">LoValueCheck</a> { <br />
&#160;&#160;<b>Any</b>, 
<b>AboveZero</b>, 
<b>ZeroOrMore</b>, 
<b>AboveNegInf</b>, 
<br />
&#160;&#160;<b>NonZero</b>
<br />
 }<tr class="memdesc:a57593cac21168ed673c77a11d18a35ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lo value check. <br /></td></tr>
</td></tr>
<tr class="separator:a57593cac21168ed673c77a11d18a35ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f31f7e3449c760decd7f664e16b0390"><td class="memItemLeft" align="right" valign="top"><a id="a1f31f7e3449c760decd7f664e16b0390"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1f31f7e3449c760decd7f664e16b0390">HiValueCheck</a> { <br />
&#160;&#160;<b>Any</b>, 
<b>BelowZero</b>, 
<b>ZeroOrLess</b>, 
<b>OneOrLess</b>, 
<br />
&#160;&#160;<b>BelowPosInf</b>
<br />
 }<tr class="memdesc:a1f31f7e3449c760decd7f664e16b0390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hi value check. <br /></td></tr>
</td></tr>
<tr class="separator:a1f31f7e3449c760decd7f664e16b0390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098b0ef528e3b728af8e3e17873963f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> { <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a84a8921b25f505d0d2077aeb5db4bc16">BodyType::Static</a> = 0, 
<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a40c78b58b86002ee38fad2d3c9dd787e">BodyType::Kinematic</a>, 
<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a971fd8cc345d8bd9f92e9f7d88fdf20c">BodyType::Dynamic</a>
 }<tr class="memdesc:a098b0ef528e3b728af8e3e17873963f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body Type.  <a href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a098b0ef528e3b728af8e3e17873963f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a53f690f42005d67b07deca5aca8bc613"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a53f690f42005d67b07deca5aca8bc613"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho_1_1d2.html#a03a4588e961b6a369745c9c5b68b9868">d2::AABB</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a53f690f42005d67b07deca5aca8bc613">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a53f690f42005d67b07deca5aca8bc613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid AABB value.  <a href="#a53f690f42005d67b07deca5aca8bc613">More...</a><br /></td></tr>
<tr class="separator:a53f690f42005d67b07deca5aca8bc613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ad4cc19ec75313b99288e91950a47d"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a10ad4cc19ec75313b99288e91950a47d">GetVertexVertexContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:a10ad4cc19ec75313b99288e91950a47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex vertex contact feature for the given indices.  <a href="#a10ad4cc19ec75313b99288e91950a47d">More...</a><br /></td></tr>
<tr class="separator:a10ad4cc19ec75313b99288e91950a47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8b575033edcfa889ffbf46c59d3cf"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad6e8b575033edcfa889ffbf46c59d3cf">GetVertexFaceContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:ad6e8b575033edcfa889ffbf46c59d3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex face contact feature for the given indices.  <a href="#ad6e8b575033edcfa889ffbf46c59d3cf">More...</a><br /></td></tr>
<tr class="separator:ad6e8b575033edcfa889ffbf46c59d3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba99e7b6830147b661bafaa0dea6e57"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acba99e7b6830147b661bafaa0dea6e57">GetFaceVertexContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:acba99e7b6830147b661bafaa0dea6e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face vertex contact feature for the given indices.  <a href="#acba99e7b6830147b661bafaa0dea6e57">More...</a><br /></td></tr>
<tr class="separator:acba99e7b6830147b661bafaa0dea6e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8801413b54ba7e1db710717c18020d7"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab8801413b54ba7e1db710717c18020d7">GetFaceFaceContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:ab8801413b54ba7e1db710717c18020d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face face contact feature for the given indices.  <a href="#ab8801413b54ba7e1db710717c18020d7">More...</a><br /></td></tr>
<tr class="separator:ab8801413b54ba7e1db710717c18020d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6715d6c6303a8e57025977ca0b079eb"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac6715d6c6303a8e57025977ca0b079eb">Flip</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> val) noexcept</td></tr>
<tr class="memdesc:ac6715d6c6303a8e57025977ca0b079eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips contact features information.  <a href="#ac6715d6c6303a8e57025977ca0b079eb">More...</a><br /></td></tr>
<tr class="separator:ac6715d6c6303a8e57025977ca0b079eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197cce644da40356103fcdebd7911dba"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a197cce644da40356103fcdebd7911dba">operator==</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> lhs, <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> rhs) noexcept</td></tr>
<tr class="memdesc:a197cce644da40356103fcdebd7911dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given two contact features are equal.  <a href="#a197cce644da40356103fcdebd7911dba">More...</a><br /></td></tr>
<tr class="separator:a197cce644da40356103fcdebd7911dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9469d42ec9781ca037c112ae05ebe9ae"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9469d42ec9781ca037c112ae05ebe9ae">operator!=</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> lhs, <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9469d42ec9781ca037c112ae05ebe9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given two contact features are not equal.  <a href="#a9469d42ec9781ca037c112ae05ebe9ae">More...</a><br /></td></tr>
<tr class="separator:a9469d42ec9781ca037c112ae05ebe9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"><td class="memItemLeft" align="right" valign="top"><a id="a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea">GetName</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#afd2b1a5d28a16fc49261c39d8cebabc0">ContactFeature::Type</a> type) noexcept</td></tr>
<tr class="memdesc:a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the human readable name for the given contact feature type. <br /></td></tr>
<tr class="separator:a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="memItemLeft" align="right" valign="top"><a id="ad3ec58bed15fb00ea00af6a52e5a7e3e"></a>
inline ::std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad3ec58bed15fb00ea00af6a52e5a7e3e">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> &amp;value)</td></tr>
<tr class="memdesc:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator. <br /></td></tr>
<tr class="separator:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa1d36f29e78ecf1d24460013b56560"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adaa1d36f29e78ecf1d24460013b56560">GetNumValidIndices</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) noexcept</td></tr>
<tr class="memdesc:adaa1d36f29e78ecf1d24460013b56560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of valid indices in the given collection of index pairs.  <a href="#adaa1d36f29e78ecf1d24460013b56560">More...</a><br /></td></tr>
<tr class="separator:adaa1d36f29e78ecf1d24460013b56560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e1620b9ba34af4dd2d972369187e29"><td class="memItemLeft" align="right" valign="top"><a id="af9e1620b9ba34af4dd2d972369187e29"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af9e1620b9ba34af4dd2d972369187e29">IsEmpty</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) noexcept</td></tr>
<tr class="memdesc:af9e1620b9ba34af4dd2d972369187e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given collection of index pairs is empty. <br /></td></tr>
<tr class="separator:af9e1620b9ba34af4dd2d972369187e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4ceb8ef2cef80108a8d9dcb0da945"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad0c4ceb8ef2cef80108a8d9dcb0da945">GetSize</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) -&gt; decltype(<a class="el" href="namespaceplayrho.html#adaa1d36f29e78ecf1d24460013b56560">GetNumValidIndices</a>(pairs))</td></tr>
<tr class="memdesc:ad0c4ceb8ef2cef80108a8d9dcb0da945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dynamic size of the given collection of index pairs.  <a href="#ad0c4ceb8ef2cef80108a8d9dcb0da945">More...</a><br /></td></tr>
<tr class="separator:ad0c4ceb8ef2cef80108a8d9dcb0da945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cf14071c9ab7a52d0a11169a5a5ee3"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae0cf14071c9ab7a52d0a11169a5a5ee3">GetMaxSize</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) -&gt; decltype(pairs.max_size())</td></tr>
<tr class="memdesc:ae0cf14071c9ab7a52d0a11169a5a5ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum size of the given container of index pairs.  <a href="#ae0cf14071c9ab7a52d0a11169a5a5ee3">More...</a><br /></td></tr>
<tr class="separator:ae0cf14071c9ab7a52d0a11169a5a5ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memTemplParams" colspan="2"><a id="a24de24fa4d8c10dea7826ce11c81ff36"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a24de24fa4d8c10dea7826ce11c81ff36">GetFirstShapeVertexIdx</a> (const <a class="el" href="structplayrho_1_1detail_1_1SeparationInfo.html">detail::SeparationInfo</a>&lt; N &gt; &amp;info) noexcept</td></tr>
<tr class="memdesc:a24de24fa4d8c10dea7826ce11c81ff36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets first shape vertex index. <br /></td></tr>
<tr class="separator:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memTemplParams" colspan="2"><a id="a435b2e5c84e285bf7f0ac9486c2512d3"></a>
template&lt;VertexCounter M, std::size_t N&gt; </td></tr>
<tr class="memitem:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a435b2e5c84e285bf7f0ac9486c2512d3">GetSecondShapeVertexIdx</a> (const <a class="el" href="structplayrho_1_1detail_1_1SeparationInfo.html">detail::SeparationInfo</a>&lt; N &gt; &amp;info) noexcept</td></tr>
<tr class="memdesc:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets second shape vertex indices. <br /></td></tr>
<tr class="separator:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad596c747e4643415e312ad69bef2a03b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad596c747e4643415e312ad69bef2a03b"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad596c747e4643415e312ad69bef2a03b">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1Manifold.html">d2::Manifold</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ad596c747e4643415e312ad69bef2a03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given manifold is valid.  <a href="#ad596c747e4643415e312ad69bef2a03b">More...</a><br /></td></tr>
<tr class="separator:ad596c747e4643415e312ad69bef2a03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5088fa473b382571a89d042e8a310bee"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5088fa473b382571a89d042e8a310bee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5088fa473b382571a89d042e8a310bee">Visit&lt; d2::Shape &gt;</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">d2::Shape</a> &amp;shape, void *userData)</td></tr>
<tr class="memdesc:a5088fa473b382571a89d042e8a310bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits the given shape with the potentially non-null user data pointer.  <a href="#a5088fa473b382571a89d042e8a310bee">More...</a><br /></td></tr>
<tr class="separator:a5088fa473b382571a89d042e8a310bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb29c9575dd4eeac1ff13136d9a56494"><td class="memItemLeft" align="right" valign="top"><a id="acb29c9575dd4eeac1ff13136d9a56494"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acb29c9575dd4eeac1ff13136d9a56494">GetName</a> (<a class="el" href="structplayrho_1_1TOIOutput.html#a7387423560f6283896f1c6af1f938991">TOIOutput::State</a> state) noexcept</td></tr>
<tr class="memdesc:acb29c9575dd4eeac1ff13136d9a56494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a human readable name for the given output state. <br /></td></tr>
<tr class="separator:acb29c9575dd4eeac1ff13136d9a56494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864179cb9a35cb6665d429656ad0e9b"><td class="memItemLeft" align="right" valign="top"><a id="a9864179cb9a35cb6665d429656ad0e9b"></a>
<a class="el" href="structplayrho_1_1ToiConf.html">ToiConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9864179cb9a35cb6665d429656ad0e9b">GetToiConf</a> (const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a9864179cb9a35cb6665d429656ad0e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time of impact configuration for the given step configuration. <br /></td></tr>
<tr class="separator:a9864179cb9a35cb6665d429656ad0e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1706f5ee9f03fdec4a73d2c4d6ce6b"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abb1706f5ee9f03fdec4a73d2c4d6ce6b">GetDefaultToiConf</a> ()</td></tr>
<tr class="memdesc:abb1706f5ee9f03fdec4a73d2c4d6ce6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default time of impact configuration.  <a href="#abb1706f5ee9f03fdec4a73d2c4d6ce6b">More...</a><br /></td></tr>
<tr class="separator:abb1706f5ee9f03fdec4a73d2c4d6ce6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75eaa3e476bb7117d67e6df9fbfef61b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a75eaa3e476bb7117d67e6df9fbfef61b"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a75eaa3e476bb7117d67e6df9fbfef61b">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Acceleration.html">d2::Acceleration</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a75eaa3e476bb7117d67e6df9fbfef61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="#a75eaa3e476bb7117d67e6df9fbfef61b">More...</a><br /></td></tr>
<tr class="separator:a75eaa3e476bb7117d67e6df9fbfef61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="memTemplParams" colspan="2"><a id="afe9da6ff11f4a2c1b7d0df8f513bc217"></a>
template&lt;typename T , std::size_t S&gt; </td></tr>
<tr class="memitem:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afe9da6ff11f4a2c1b7d0df8f513bc217">operator+=</a> (<a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; &amp;lhs, const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;rhs)</td></tr>
<tr class="memdesc:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list. ">ArrayList</a></code> append operator. <br /></td></tr>
<tr class="separator:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2410eb16decdbb7ed8ce34c06327161b"><td class="memTemplParams" colspan="2"><a id="a2410eb16decdbb7ed8ce34c06327161b"></a>
template&lt;typename T , std::size_t S&gt; </td></tr>
<tr class="memitem:a2410eb16decdbb7ed8ce34c06327161b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2410eb16decdbb7ed8ce34c06327161b">operator+</a> (<a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; lhs, const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;rhs)</td></tr>
<tr class="memdesc:a2410eb16decdbb7ed8ce34c06327161b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list. ">ArrayList</a></code> add operator. <br /></td></tr>
<tr class="separator:a2410eb16decdbb7ed8ce34c06327161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d45df992becf6fd54bb224344dcfd82"><td class="memItemLeft" align="right" valign="top"><a id="a8d45df992becf6fd54bb224344dcfd82"></a>
static std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8d45df992becf6fd54bb224344dcfd82">GetBlockSizeIndex</a> (std::size_t n)</td></tr>
<tr class="memdesc:a8d45df992becf6fd54bb224344dcfd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the block size index for the given data block size. <br /></td></tr>
<tr class="separator:a8d45df992becf6fd54bb224344dcfd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f6b57cf0f7bc53f9339381007d9b84"><td class="memTemplParams" colspan="2"><a id="a02f6b57cf0f7bc53f9339381007d9b84"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02f6b57cf0f7bc53f9339381007d9b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a02f6b57cf0f7bc53f9339381007d9b84">Delete</a> (const T *p, <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;allocator)</td></tr>
<tr class="memdesc:a02f6b57cf0f7bc53f9339381007d9b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given pointer by calling the pointed-to object's destructor and returning it to the given allocator. <br /></td></tr>
<tr class="separator:a02f6b57cf0f7bc53f9339381007d9b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5692e54289c87c156bd7455763082a9"><td class="memItemLeft" align="right" valign="top"><a id="ab5692e54289c87c156bd7455763082a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab5692e54289c87c156bd7455763082a9">operator==</a> (const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;a, const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;b)</td></tr>
<tr class="memdesc:ab5692e54289c87c156bd7455763082a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1BlockAllocator.html" title="Block allocator. ">BlockAllocator</a></code> equality operator. <br /></td></tr>
<tr class="separator:ab5692e54289c87c156bd7455763082a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d26025dffe3901caa095b9fa19682"><td class="memItemLeft" align="right" valign="top"><a id="a425d26025dffe3901caa095b9fa19682"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a425d26025dffe3901caa095b9fa19682">operator!=</a> (const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;a, const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;b)</td></tr>
<tr class="memdesc:a425d26025dffe3901caa095b9fa19682"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1BlockAllocator.html" title="Block allocator. ">BlockAllocator</a></code> inequality operator. <br /></td></tr>
<tr class="separator:a425d26025dffe3901caa095b9fa19682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f286859b30722528653b8b22db575e"><td class="memTemplParams" colspan="2"><a id="a59f286859b30722528653b8b22db575e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59f286859b30722528653b8b22db575e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::has_infinity, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a59f286859b30722528653b8b22db575e">CheckIfAboveNegInf</a> (T value)</td></tr>
<tr class="memdesc:a59f286859b30722528653b8b22db575e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given value is above negative infinity. <br /></td></tr>
<tr class="separator:a59f286859b30722528653b8b22db575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac2f26ff2e83bc367d654ce25f39545"><td class="memTemplParams" colspan="2"><a id="abac2f26ff2e83bc367d654ce25f39545"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abac2f26ff2e83bc367d654ce25f39545"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt;!std::numeric_limits&lt; T &gt;::has_infinity, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abac2f26ff2e83bc367d654ce25f39545">CheckIfAboveNegInf</a> (T)</td></tr>
<tr class="memdesc:abac2f26ff2e83bc367d654ce25f39545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given value is above negative infinity. <br /></td></tr>
<tr class="separator:abac2f26ff2e83bc367d654ce25f39545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bcfd8fa121db2e504c73c636acb4a6"><td class="memTemplParams" colspan="2"><a id="ac8bcfd8fa121db2e504c73c636acb4a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8bcfd8fa121db2e504c73c636acb4a6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::has_infinity, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac8bcfd8fa121db2e504c73c636acb4a6">CheckIfBelowPosInf</a> (T value)</td></tr>
<tr class="memdesc:ac8bcfd8fa121db2e504c73c636acb4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given value is below positive infinity. <br /></td></tr>
<tr class="separator:ac8bcfd8fa121db2e504c73c636acb4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3801ac5010eb98e69e1e71bb330ba0f"><td class="memTemplParams" colspan="2"><a id="aa3801ac5010eb98e69e1e71bb330ba0f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3801ac5010eb98e69e1e71bb330ba0f"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt;!std::numeric_limits&lt; T &gt;::has_infinity, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa3801ac5010eb98e69e1e71bb330ba0f">CheckIfBelowPosInf</a> (T)</td></tr>
<tr class="memdesc:aa3801ac5010eb98e69e1e71bb330ba0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given value is below positive infinity. <br /></td></tr>
<tr class="separator:aa3801ac5010eb98e69e1e71bb330ba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7617d2de4e77e6b2ae6c4a23bf08ea6"><td class="memTemplParams" colspan="2"><a id="af7617d2de4e77e6b2ae6c4a23bf08ea6"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:af7617d2de4e77e6b2ae6c4a23bf08ea6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af7617d2de4e77e6b2ae6c4a23bf08ea6">operator==</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:af7617d2de4e77e6b2ae6c4a23bf08ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value equality operator. <br /></td></tr>
<tr class="separator:af7617d2de4e77e6b2ae6c4a23bf08ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19598ae45019edea9cd9566e3966e25c"><td class="memTemplParams" colspan="2"><a id="a19598ae45019edea9cd9566e3966e25c"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a19598ae45019edea9cd9566e3966e25c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a19598ae45019edea9cd9566e3966e25c">operator!=</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a19598ae45019edea9cd9566e3966e25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value inequality operator. <br /></td></tr>
<tr class="separator:a19598ae45019edea9cd9566e3966e25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda4ed95b3e8aef674cc4f40ac9c256"><td class="memTemplParams" colspan="2"><a id="a2fda4ed95b3e8aef674cc4f40ac9c256"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a2fda4ed95b3e8aef674cc4f40ac9c256"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2fda4ed95b3e8aef674cc4f40ac9c256">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a2fda4ed95b3e8aef674cc4f40ac9c256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a2fda4ed95b3e8aef674cc4f40ac9c256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad5ec0fcfae4c6e9d9a1d59cab77432"><td class="memTemplParams" colspan="2"><a id="a2ad5ec0fcfae4c6e9d9a1d59cab77432"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a2ad5ec0fcfae4c6e9d9a1d59cab77432"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2ad5ec0fcfae4c6e9d9a1d59cab77432">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a2ad5ec0fcfae4c6e9d9a1d59cab77432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:a2ad5ec0fcfae4c6e9d9a1d59cab77432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf5366fdd561f2d9ffe61167ae0f5a6"><td class="memTemplParams" colspan="2"><a id="afaf5366fdd561f2d9ffe61167ae0f5a6"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:afaf5366fdd561f2d9ffe61167ae0f5a6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afaf5366fdd561f2d9ffe61167ae0f5a6">operator&lt;</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:afaf5366fdd561f2d9ffe61167ae0f5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value less-than operator. <br /></td></tr>
<tr class="separator:afaf5366fdd561f2d9ffe61167ae0f5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f7cafaa85a495bde8282dc0b0dfc98"><td class="memTemplParams" colspan="2"><a id="a90f7cafaa85a495bde8282dc0b0dfc98"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a90f7cafaa85a495bde8282dc0b0dfc98"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a90f7cafaa85a495bde8282dc0b0dfc98">operator&gt;</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a90f7cafaa85a495bde8282dc0b0dfc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value greater-than operator. <br /></td></tr>
<tr class="separator:a90f7cafaa85a495bde8282dc0b0dfc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88516702484ce225186e4388cab8c007"><td class="memTemplParams" colspan="2"><a id="a88516702484ce225186e4388cab8c007"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a88516702484ce225186e4388cab8c007"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a88516702484ce225186e4388cab8c007">operator*</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a88516702484ce225186e4388cab8c007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value multiplication operator. <br /></td></tr>
<tr class="separator:a88516702484ce225186e4388cab8c007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faa7d6df2c73d412476a7c8d672c8a8"><td class="memTemplParams" colspan="2"><a id="a5faa7d6df2c73d412476a7c8d672c8a8"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a5faa7d6df2c73d412476a7c8d672c8a8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5faa7d6df2c73d412476a7c8d672c8a8">operator/</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a5faa7d6df2c73d412476a7c8d672c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value division operator. <br /></td></tr>
<tr class="separator:a5faa7d6df2c73d412476a7c8d672c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c2f56046c1900b352bc349647bf441"><td class="memTemplParams" colspan="2"><a id="a41c2f56046c1900b352bc349647bf441"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a41c2f56046c1900b352bc349647bf441"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a41c2f56046c1900b352bc349647bf441">operator+</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a41c2f56046c1900b352bc349647bf441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value addition operator. <br /></td></tr>
<tr class="separator:a41c2f56046c1900b352bc349647bf441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521ae1143f57ad3f714134091f4b7a9d"><td class="memTemplParams" colspan="2"><a id="a521ae1143f57ad3f714134091f4b7a9d"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a521ae1143f57ad3f714134091f4b7a9d"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a521ae1143f57ad3f714134091f4b7a9d">operator-</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a521ae1143f57ad3f714134091f4b7a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value subtraction operator. <br /></td></tr>
<tr class="separator:a521ae1143f57ad3f714134091f4b7a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5052f98c2db895a8d4dabc53294527da"><td class="memTemplParams" colspan="2"><a id="a5052f98c2db895a8d4dabc53294527da"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a5052f98c2db895a8d4dabc53294527da"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5052f98c2db895a8d4dabc53294527da">operator==</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const T rhs)</td></tr>
<tr class="memdesc:a5052f98c2db895a8d4dabc53294527da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value equality operator. <br /></td></tr>
<tr class="separator:a5052f98c2db895a8d4dabc53294527da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc632c2d1a08a96e780aaa4adf2a0cf"><td class="memTemplParams" colspan="2"><a id="a6cc632c2d1a08a96e780aaa4adf2a0cf"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a6cc632c2d1a08a96e780aaa4adf2a0cf"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6cc632c2d1a08a96e780aaa4adf2a0cf">operator!=</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const T rhs)</td></tr>
<tr class="memdesc:a6cc632c2d1a08a96e780aaa4adf2a0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value inequality operator. <br /></td></tr>
<tr class="separator:a6cc632c2d1a08a96e780aaa4adf2a0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e6e8dde024e9eb1bfe98b1ec668744"><td class="memTemplParams" colspan="2"><a id="a16e6e8dde024e9eb1bfe98b1ec668744"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a16e6e8dde024e9eb1bfe98b1ec668744"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a16e6e8dde024e9eb1bfe98b1ec668744">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const T rhs)</td></tr>
<tr class="memdesc:a16e6e8dde024e9eb1bfe98b1ec668744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a16e6e8dde024e9eb1bfe98b1ec668744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914075b95e5d39a01c90919525ad5b73"><td class="memTemplParams" colspan="2"><a id="a914075b95e5d39a01c90919525ad5b73"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a914075b95e5d39a01c90919525ad5b73"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a914075b95e5d39a01c90919525ad5b73">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const T rhs)</td></tr>
<tr class="memdesc:a914075b95e5d39a01c90919525ad5b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:a914075b95e5d39a01c90919525ad5b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ed42bbd3e7e3c3648c1644cb79937"><td class="memTemplParams" colspan="2"><a id="af48ed42bbd3e7e3c3648c1644cb79937"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:af48ed42bbd3e7e3c3648c1644cb79937"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af48ed42bbd3e7e3c3648c1644cb79937">operator&lt;</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const T rhs)</td></tr>
<tr class="memdesc:af48ed42bbd3e7e3c3648c1644cb79937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value less-than operator. <br /></td></tr>
<tr class="separator:af48ed42bbd3e7e3c3648c1644cb79937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdda5158c5d97cf1ffec82b1b1126482"><td class="memTemplParams" colspan="2"><a id="afdda5158c5d97cf1ffec82b1b1126482"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:afdda5158c5d97cf1ffec82b1b1126482"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afdda5158c5d97cf1ffec82b1b1126482">operator&gt;</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const T rhs)</td></tr>
<tr class="memdesc:afdda5158c5d97cf1ffec82b1b1126482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value greater-than operator. <br /></td></tr>
<tr class="separator:afdda5158c5d97cf1ffec82b1b1126482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99468da69970a941511d91342e118d"><td class="memTemplParams" colspan="2"><a id="a4b99468da69970a941511d91342e118d"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a4b99468da69970a941511d91342e118d"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4b99468da69970a941511d91342e118d">operator*</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const U rhs)</td></tr>
<tr class="memdesc:a4b99468da69970a941511d91342e118d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value multiplication operator. <br /></td></tr>
<tr class="separator:a4b99468da69970a941511d91342e118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793c2dc0c6bfa88930594d2aba8fb4a4"><td class="memTemplParams" colspan="2"><a id="a793c2dc0c6bfa88930594d2aba8fb4a4"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a793c2dc0c6bfa88930594d2aba8fb4a4"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a793c2dc0c6bfa88930594d2aba8fb4a4">operator/</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const U rhs)</td></tr>
<tr class="memdesc:a793c2dc0c6bfa88930594d2aba8fb4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value division operator. <br /></td></tr>
<tr class="separator:a793c2dc0c6bfa88930594d2aba8fb4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dd627f695adb3a66dc7c64b21de2f4"><td class="memTemplParams" colspan="2"><a id="a33dd627f695adb3a66dc7c64b21de2f4"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a33dd627f695adb3a66dc7c64b21de2f4"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a33dd627f695adb3a66dc7c64b21de2f4">operator+</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const U rhs)</td></tr>
<tr class="memdesc:a33dd627f695adb3a66dc7c64b21de2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value addition operator. <br /></td></tr>
<tr class="separator:a33dd627f695adb3a66dc7c64b21de2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4a07f5177eca7d807775b49731306"><td class="memTemplParams" colspan="2"><a id="adeb4a07f5177eca7d807775b49731306"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:adeb4a07f5177eca7d807775b49731306"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adeb4a07f5177eca7d807775b49731306">operator-</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; lhs, const U rhs)</td></tr>
<tr class="memdesc:adeb4a07f5177eca7d807775b49731306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value subtraction operator. <br /></td></tr>
<tr class="separator:adeb4a07f5177eca7d807775b49731306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa787954e38e6fa624566e4da935d3ab6"><td class="memTemplParams" colspan="2"><a id="aa787954e38e6fa624566e4da935d3ab6"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:aa787954e38e6fa624566e4da935d3ab6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa787954e38e6fa624566e4da935d3ab6">operator==</a> (const T lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:aa787954e38e6fa624566e4da935d3ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value equality operator. <br /></td></tr>
<tr class="separator:aa787954e38e6fa624566e4da935d3ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9130a5578df059499441c31cd4e47b69"><td class="memTemplParams" colspan="2"><a id="a9130a5578df059499441c31cd4e47b69"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a9130a5578df059499441c31cd4e47b69"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9130a5578df059499441c31cd4e47b69">operator!=</a> (const T lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a9130a5578df059499441c31cd4e47b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value inequality operator. <br /></td></tr>
<tr class="separator:a9130a5578df059499441c31cd4e47b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d693411bafbcd96aea4f64034bbc40f"><td class="memTemplParams" colspan="2"><a id="a4d693411bafbcd96aea4f64034bbc40f"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a4d693411bafbcd96aea4f64034bbc40f"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4d693411bafbcd96aea4f64034bbc40f">operator&lt;=</a> (const T lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a4d693411bafbcd96aea4f64034bbc40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a4d693411bafbcd96aea4f64034bbc40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba8c9e06f41677c6870d31118741a4e"><td class="memTemplParams" colspan="2"><a id="afba8c9e06f41677c6870d31118741a4e"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:afba8c9e06f41677c6870d31118741a4e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afba8c9e06f41677c6870d31118741a4e">operator&gt;=</a> (const T lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:afba8c9e06f41677c6870d31118741a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:afba8c9e06f41677c6870d31118741a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac082e37a15d431ff58945c87094a2992"><td class="memTemplParams" colspan="2"><a id="ac082e37a15d431ff58945c87094a2992"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:ac082e37a15d431ff58945c87094a2992"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac082e37a15d431ff58945c87094a2992">operator&lt;</a> (const T lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:ac082e37a15d431ff58945c87094a2992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value less-than operator. <br /></td></tr>
<tr class="separator:ac082e37a15d431ff58945c87094a2992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c97bd4484daac3a451c3a3a1a63e84"><td class="memTemplParams" colspan="2"><a id="a68c97bd4484daac3a451c3a3a1a63e84"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a68c97bd4484daac3a451c3a3a1a63e84"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a68c97bd4484daac3a451c3a3a1a63e84">operator&gt;</a> (const T lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a68c97bd4484daac3a451c3a3a1a63e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value greater-than operator. <br /></td></tr>
<tr class="separator:a68c97bd4484daac3a451c3a3a1a63e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c28512e2318ba0380d132189078c5"><td class="memTemplParams" colspan="2"><a id="a457c28512e2318ba0380d132189078c5"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a457c28512e2318ba0380d132189078c5"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a457c28512e2318ba0380d132189078c5">operator*</a> (const U lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a457c28512e2318ba0380d132189078c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value multiplication operator. <br /></td></tr>
<tr class="separator:a457c28512e2318ba0380d132189078c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa711ab829adfffa0eddc4426e4c93861"><td class="memTemplParams" colspan="2"><a id="aa711ab829adfffa0eddc4426e4c93861"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:aa711ab829adfffa0eddc4426e4c93861"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa711ab829adfffa0eddc4426e4c93861">operator/</a> (const U lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:aa711ab829adfffa0eddc4426e4c93861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value division operator. <br /></td></tr>
<tr class="separator:aa711ab829adfffa0eddc4426e4c93861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132b4c12e412947f9abdf7cb7f344b0e"><td class="memTemplParams" colspan="2"><a id="a132b4c12e412947f9abdf7cb7f344b0e"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a132b4c12e412947f9abdf7cb7f344b0e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a132b4c12e412947f9abdf7cb7f344b0e">operator+</a> (const U lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:a132b4c12e412947f9abdf7cb7f344b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value addition operator. <br /></td></tr>
<tr class="separator:a132b4c12e412947f9abdf7cb7f344b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22322127c812c51fbec45b54396c1d1"><td class="memTemplParams" colspan="2"><a id="ac22322127c812c51fbec45b54396c1d1"></a>
template&lt;typename T , typename U , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:ac22322127c812c51fbec45b54396c1d1"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac22322127c812c51fbec45b54396c1d1">operator-</a> (const U lhs, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; rhs)</td></tr>
<tr class="memdesc:ac22322127c812c51fbec45b54396c1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value subtraction operator. <br /></td></tr>
<tr class="separator:ac22322127c812c51fbec45b54396c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d8be6e505673dbdb72539076885ec7"><td class="memTemplParams" colspan="2"><a id="a64d8be6e505673dbdb72539076885ec7"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a64d8be6e505673dbdb72539076885ec7"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a64d8be6e505673dbdb72539076885ec7">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; &amp;value)</td></tr>
<tr class="memdesc:a64d8be6e505673dbdb72539076885ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded value stream output operator. <br /></td></tr>
<tr class="separator:a64d8be6e505673dbdb72539076885ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5908a18311a865763d65130dcdf40052"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5908a18311a865763d65130dcdf40052">Alloc</a> (std::size_t size)</td></tr>
<tr class="memdesc:a5908a18311a865763d65130dcdf40052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory.  <a href="#a5908a18311a865763d65130dcdf40052">More...</a><br /></td></tr>
<tr class="separator:a5908a18311a865763d65130dcdf40052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5b2682a491fff8510bbcfea1929e59"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1e5b2682a491fff8510bbcfea1929e59">Realloc</a> (void *ptr, std::size_t new_size)</td></tr>
<tr class="memdesc:a1e5b2682a491fff8510bbcfea1929e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory.  <a href="#a1e5b2682a491fff8510bbcfea1929e59">More...</a><br /></td></tr>
<tr class="separator:a1e5b2682a491fff8510bbcfea1929e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c138018c11ab3c255b410f2dedd7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2">Free</a> (void *mem)</td></tr>
<tr class="memdesc:a62c138018c11ab3c255b410f2dedd7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory.  <a href="#a62c138018c11ab3c255b410f2dedd7d2">More...</a><br /></td></tr>
<tr class="separator:a62c138018c11ab3c255b410f2dedd7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a103da67690df019db5811cec069c61"><td class="memTemplParams" colspan="2"><a id="a3a103da67690df019db5811cec069c61"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a103da67690df019db5811cec069c61"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3a103da67690df019db5811cec069c61">Realloc</a> (T *ptr, std::size_t size)</td></tr>
<tr class="memdesc:a3a103da67690df019db5811cec069c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory. <br /></td></tr>
<tr class="separator:a3a103da67690df019db5811cec069c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e1246afa016452ab43ef1ae5906973"><td class="memTemplParams" colspan="2"><a id="a08e1246afa016452ab43ef1ae5906973"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a08e1246afa016452ab43ef1ae5906973"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a08e1246afa016452ab43ef1ae5906973">operator==</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a08e1246afa016452ab43ef1ae5906973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a08e1246afa016452ab43ef1ae5906973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4b4e933d0de3e22d7f9ed67d974313"><td class="memTemplParams" colspan="2"><a id="a4a4b4e933d0de3e22d7f9ed67d974313"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a4a4b4e933d0de3e22d7f9ed67d974313"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4a4b4e933d0de3e22d7f9ed67d974313">operator!=</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a4a4b4e933d0de3e22d7f9ed67d974313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a4a4b4e933d0de3e22d7f9ed67d974313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17761c9feb89d061621d793a88fff411"><td class="memTemplParams" colspan="2"><a id="a17761c9feb89d061621d793a88fff411"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a17761c9feb89d061621d793a88fff411"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a17761c9feb89d061621d793a88fff411">operator&lt;</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a17761c9feb89d061621d793a88fff411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:a17761c9feb89d061621d793a88fff411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a631162f6aa6d3d6f13705d7267079"><td class="memTemplParams" colspan="2"><a id="a84a631162f6aa6d3d6f13705d7267079"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a84a631162f6aa6d3d6f13705d7267079"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a84a631162f6aa6d3d6f13705d7267079">operator&gt;</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a84a631162f6aa6d3d6f13705d7267079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:a84a631162f6aa6d3d6f13705d7267079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19575018f5f3101db273c2b33f1ab4f"><td class="memTemplParams" colspan="2"><a id="ac19575018f5f3101db273c2b33f1ab4f"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ac19575018f5f3101db273c2b33f1ab4f"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac19575018f5f3101db273c2b33f1ab4f">operator&lt;=</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ac19575018f5f3101db273c2b33f1ab4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:ac19575018f5f3101db273c2b33f1ab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de9b93007ae1f89be08c9ee4d261c9a"><td class="memTemplParams" colspan="2"><a id="a9de9b93007ae1f89be08c9ee4d261c9a"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a9de9b93007ae1f89be08c9ee4d261c9a"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9de9b93007ae1f89be08c9ee4d261c9a">operator&gt;=</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a9de9b93007ae1f89be08c9ee4d261c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:a9de9b93007ae1f89be08c9ee4d261c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7155a910eaa0ec008e2bebaa4f0de3"><td class="memTemplParams" colspan="2"><a id="abf7155a910eaa0ec008e2bebaa4f0de3"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:abf7155a910eaa0ec008e2bebaa4f0de3"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abf7155a910eaa0ec008e2bebaa4f0de3">operator+</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:abf7155a910eaa0ec008e2bebaa4f0de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator. <br /></td></tr>
<tr class="separator:abf7155a910eaa0ec008e2bebaa4f0de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896ed085d4832befdc4523c9a8a48f62"><td class="memTemplParams" colspan="2"><a id="a896ed085d4832befdc4523c9a8a48f62"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a896ed085d4832befdc4523c9a8a48f62"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a896ed085d4832befdc4523c9a8a48f62">operator-</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a896ed085d4832befdc4523c9a8a48f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator. <br /></td></tr>
<tr class="separator:a896ed085d4832befdc4523c9a8a48f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8249194da52af6a68cfc7fc3dc6b45f5"><td class="memTemplParams" colspan="2"><a id="a8249194da52af6a68cfc7fc3dc6b45f5"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a8249194da52af6a68cfc7fc3dc6b45f5"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8249194da52af6a68cfc7fc3dc6b45f5">operator*</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a8249194da52af6a68cfc7fc3dc6b45f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:a8249194da52af6a68cfc7fc3dc6b45f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64b946db27c3256a149851f379d539f"><td class="memTemplParams" colspan="2"><a id="ae64b946db27c3256a149851f379d539f"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ae64b946db27c3256a149851f379d539f"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae64b946db27c3256a149851f379d539f">operator/</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ae64b946db27c3256a149851f379d539f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:ae64b946db27c3256a149851f379d539f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c96799706ca991351ede533bd5e9aa9"><td class="memTemplParams" colspan="2"><a id="a4c96799706ca991351ede533bd5e9aa9"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a4c96799706ca991351ede533bd5e9aa9"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4c96799706ca991351ede533bd5e9aa9">operator%</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a4c96799706ca991351ede533bd5e9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operator. <br /></td></tr>
<tr class="separator:a4c96799706ca991351ede533bd5e9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af449f3dac7aed6e35a519ad0b9ebc540"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:af449f3dac7aed6e35a519ad0b9ebc540"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af449f3dac7aed6e35a519ad0b9ebc540">AlmostZero</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value)</td></tr>
<tr class="memdesc:af449f3dac7aed6e35a519ad0b9ebc540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="#af449f3dac7aed6e35a519ad0b9ebc540">More...</a><br /></td></tr>
<tr class="separator:af449f3dac7aed6e35a519ad0b9ebc540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18b19d457199ee49770d262dfdef98c"><td class="memTemplParams" colspan="2"><a id="ac18b19d457199ee49770d262dfdef98c"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ac18b19d457199ee49770d262dfdef98c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac18b19d457199ee49770d262dfdef98c">AlmostEqual</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; x, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; y, int ulp=2)</td></tr>
<tr class="memdesc:ac18b19d457199ee49770d262dfdef98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ac18b19d457199ee49770d262dfdef98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598d4f1182411b5db1d2c445b16fc5fd"><td class="memTemplParams" colspan="2"><a id="a598d4f1182411b5db1d2c445b16fc5fd"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a598d4f1182411b5db1d2c445b16fc5fd"><td class="memTemplItemLeft" align="right" valign="top">inline ::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a598d4f1182411b5db1d2c445b16fc5fd">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; &amp;value)</td></tr>
<tr class="memdesc:a598d4f1182411b5db1d2c445b16fc5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:a598d4f1182411b5db1d2c445b16fc5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8c9cc7f05d1616a6dc16a0ffa840a2"><td class="memTemplParams" colspan="2"><a id="a1a8c9cc7f05d1616a6dc16a0ffa840a2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1a8c9cc7f05d1616a6dc16a0ffa840a2"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1a8c9cc7f05d1616a6dc16a0ffa840a2">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a1a8c9cc7f05d1616a6dc16a0ffa840a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value. <br /></td></tr>
<tr class="separator:a1a8c9cc7f05d1616a6dc16a0ffa840a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6685eb90d858afe3e745f22a73749138"><td class="memItemLeft" align="right" valign="top"><a id="a6685eb90d858afe3e745f22a73749138"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6685eb90d858afe3e745f22a73749138">operator+</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a6685eb90d858afe3e745f22a73749138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator. <br /></td></tr>
<tr class="separator:a6685eb90d858afe3e745f22a73749138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb30dbb75f77b1ec2c053970ad92f6c1"><td class="memItemLeft" align="right" valign="top"><a id="afb30dbb75f77b1ec2c053970ad92f6c1"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afb30dbb75f77b1ec2c053970ad92f6c1">operator-</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:afb30dbb75f77b1ec2c053970ad92f6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator. <br /></td></tr>
<tr class="separator:afb30dbb75f77b1ec2c053970ad92f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44208cebfbf016b0b8f51c4b21dd460"><td class="memItemLeft" align="right" valign="top"><a id="af44208cebfbf016b0b8f51c4b21dd460"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af44208cebfbf016b0b8f51c4b21dd460">operator*</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:af44208cebfbf016b0b8f51c4b21dd460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:af44208cebfbf016b0b8f51c4b21dd460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d1405232ab84b037748fa77252d0e"><td class="memItemLeft" align="right" valign="top"><a id="aee7d1405232ab84b037748fa77252d0e"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aee7d1405232ab84b037748fa77252d0e">operator/</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:aee7d1405232ab84b037748fa77252d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:aee7d1405232ab84b037748fa77252d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8b3398ca80d67cef0b95f38c173adf"><td class="memItemLeft" align="right" valign="top"><a id="a8a8b3398ca80d67cef0b95f38c173adf"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8a8b3398ca80d67cef0b95f38c173adf">operator%</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a8a8b3398ca80d67cef0b95f38c173adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operator. <br /></td></tr>
<tr class="separator:a8a8b3398ca80d67cef0b95f38c173adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334fab8c8d4da9f26fb91c5ac62d42da"><td class="memItemLeft" align="right" valign="top"><a id="a334fab8c8d4da9f26fb91c5ac62d42da"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a334fab8c8d4da9f26fb91c5ac62d42da">operator==</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a334fab8c8d4da9f26fb91c5ac62d42da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a334fab8c8d4da9f26fb91c5ac62d42da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbdc36c6a8f0611d0b71f1acd637b8"><td class="memItemLeft" align="right" valign="top"><a id="a1cbbdc36c6a8f0611d0b71f1acd637b8"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1cbbdc36c6a8f0611d0b71f1acd637b8">operator!=</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a1cbbdc36c6a8f0611d0b71f1acd637b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a1cbbdc36c6a8f0611d0b71f1acd637b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8ccaf67f4d8fe3bd448030093d289c"><td class="memItemLeft" align="right" valign="top"><a id="a4b8ccaf67f4d8fe3bd448030093d289c"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4b8ccaf67f4d8fe3bd448030093d289c">operator&lt;=</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a4b8ccaf67f4d8fe3bd448030093d289c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a4b8ccaf67f4d8fe3bd448030093d289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30f3accd26968cebb92fb0722a66bd6"><td class="memItemLeft" align="right" valign="top"><a id="ab30f3accd26968cebb92fb0722a66bd6"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab30f3accd26968cebb92fb0722a66bd6">operator&gt;=</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:ab30f3accd26968cebb92fb0722a66bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:ab30f3accd26968cebb92fb0722a66bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee33c3f1ad5437131fc92673ab519d6"><td class="memItemLeft" align="right" valign="top"><a id="a2ee33c3f1ad5437131fc92673ab519d6"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2ee33c3f1ad5437131fc92673ab519d6">operator&lt;</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a2ee33c3f1ad5437131fc92673ab519d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:a2ee33c3f1ad5437131fc92673ab519d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54c9e6d7a5cc86806af0f16d718286"><td class="memItemLeft" align="right" valign="top"><a id="a9d54c9e6d7a5cc86806af0f16d718286"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d54c9e6d7a5cc86806af0f16d718286">operator&gt;</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9d54c9e6d7a5cc86806af0f16d718286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:a9d54c9e6d7a5cc86806af0f16d718286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2557f9e67a6520f3539c9ab282823c70"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2557f9e67a6520f3539c9ab282823c70"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2557f9e67a6520f3539c9ab282823c70">GetTypeName&lt; Fixed32 &gt;</a> () noexcept</td></tr>
<tr class="memdesc:a2557f9e67a6520f3539c9ab282823c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specialized name for the <code>Fixed32</code> type.  <a href="#a2557f9e67a6520f3539c9ab282823c70">More...</a><br /></td></tr>
<tr class="separator:a2557f9e67a6520f3539c9ab282823c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5766364e4f6e29b62f20216a25a678f"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB, int N = 5&gt; </td></tr>
<tr class="memitem:gad5766364e4f6e29b62f20216a25a678f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gad5766364e4f6e29b62f20216a25a678f">abs</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:gad5766364e4f6e29b62f20216a25a678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value.  <a href="group__FixedMath.html#gad5766364e4f6e29b62f20216a25a678f">More...</a><br /></td></tr>
<tr class="separator:gad5766364e4f6e29b62f20216a25a678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gae62c436656c3c2a2e0d46d83fe1ea3ae">pow</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value, int n)</td></tr>
<tr class="memdesc:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the given number raised to the given power.  <a href="group__FixedMath.html#gae62c436656c3c2a2e0d46d83fe1ea3ae">More...</a><br /></td></tr>
<tr class="separator:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55adeaba7e08eb415e6437f709b62c0f"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga55adeaba7e08eb415e6437f709b62c0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga55adeaba7e08eb415e6437f709b62c0f">trunc</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga55adeaba7e08eb415e6437f709b62c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the given value.  <a href="group__FixedMath.html#ga55adeaba7e08eb415e6437f709b62c0f">More...</a><br /></td></tr>
<tr class="separator:ga55adeaba7e08eb415e6437f709b62c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935fa93a69f58baf20b00e14461d51e7"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga935fa93a69f58baf20b00e14461d51e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga935fa93a69f58baf20b00e14461d51e7">nextafter</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; from, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; to) noexcept</td></tr>
<tr class="memdesc:ga935fa93a69f58baf20b00e14461d51e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next after function for <a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers. ">Fixed</a> types.  <a href="group__FixedMath.html#ga935fa93a69f58baf20b00e14461d51e7">More...</a><br /></td></tr>
<tr class="separator:ga935fa93a69f58baf20b00e14461d51e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaae59d507ab3b0f722d4d22b3e4969f4a">fmod</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; dividend, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; divisor) noexcept</td></tr>
<tr class="memdesc:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the division of the given dividend by the given divisor.  <a href="group__FixedMath.html#gaae59d507ab3b0f722d4d22b3e4969f4a">More...</a><br /></td></tr>
<tr class="separator:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">sqrt</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root's the given value.  <a href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">More...</a><br /></td></tr>
<tr class="separator:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab479ab854291e9d03a25cc0986deca"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga4ab479ab854291e9d03a25cc0986deca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga4ab479ab854291e9d03a25cc0986deca">isnormal</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga4ab479ab854291e9d03a25cc0986deca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is normal - i.e. not 0 nor infinite.  <a href="group__FixedMath.html#ga4ab479ab854291e9d03a25cc0986deca">More...</a><br /></td></tr>
<tr class="separator:ga4ab479ab854291e9d03a25cc0986deca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0daabd6eacf8702561639d394e3efe6e"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga0daabd6eacf8702561639d394e3efe6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga0daabd6eacf8702561639d394e3efe6e">sin</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga0daabd6eacf8702561639d394e3efe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of the argument for <a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers. ">Fixed</a> types.  <a href="group__FixedMath.html#ga0daabd6eacf8702561639d394e3efe6e">More...</a><br /></td></tr>
<tr class="separator:ga0daabd6eacf8702561639d394e3efe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6191f040980675d9a5c71bd53c79060"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaf6191f040980675d9a5c71bd53c79060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaf6191f040980675d9a5c71bd53c79060">cos</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:gaf6191f040980675d9a5c71bd53c79060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the argument for <a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers. ">Fixed</a> types.  <a href="group__FixedMath.html#gaf6191f040980675d9a5c71bd53c79060">More...</a><br /></td></tr>
<tr class="separator:gaf6191f040980675d9a5c71bd53c79060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5670d26d229424278268189beb541f5"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaa5670d26d229424278268189beb541f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaa5670d26d229424278268189beb541f5">atan</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:gaa5670d26d229424278268189beb541f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent.  <a href="group__FixedMath.html#gaa5670d26d229424278268189beb541f5">More...</a><br /></td></tr>
<tr class="separator:gaa5670d26d229424278268189beb541f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3e4450a30d08eceda4225bd26c312b"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaad3e4450a30d08eceda4225bd26c312b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaad3e4450a30d08eceda4225bd26c312b">atan2</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; y, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; x)</td></tr>
<tr class="memdesc:gaad3e4450a30d08eceda4225bd26c312b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multi-valued inverse tangent.  <a href="group__FixedMath.html#gaad3e4450a30d08eceda4225bd26c312b">More...</a><br /></td></tr>
<tr class="separator:gaad3e4450a30d08eceda4225bd26c312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661c3590b9b618ac14194bf25a70f1d6"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga661c3590b9b618ac14194bf25a70f1d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga661c3590b9b618ac14194bf25a70f1d6">log</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga661c3590b9b618ac14194bf25a70f1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the given argument.  <a href="group__FixedMath.html#ga661c3590b9b618ac14194bf25a70f1d6">More...</a><br /></td></tr>
<tr class="separator:ga661c3590b9b618ac14194bf25a70f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddb9c067c645bded41aafe75cfecd02"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga7ddb9c067c645bded41aafe75cfecd02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga7ddb9c067c645bded41aafe75cfecd02">exp</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga7ddb9c067c645bded41aafe75cfecd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Euler number raised to the power of the given argument.  <a href="group__FixedMath.html#ga7ddb9c067c645bded41aafe75cfecd02">More...</a><br /></td></tr>
<tr class="separator:ga7ddb9c067c645bded41aafe75cfecd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dfc7d7d071b22f80179a86e5544237"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga85dfc7d7d071b22f80179a86e5544237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga85dfc7d7d071b22f80179a86e5544237">pow</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; base, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; exponent)</td></tr>
<tr class="memdesc:ga85dfc7d7d071b22f80179a86e5544237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the base number raised to the power of the exponent.  <a href="group__FixedMath.html#ga85dfc7d7d071b22f80179a86e5544237">More...</a><br /></td></tr>
<tr class="separator:ga85dfc7d7d071b22f80179a86e5544237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff5f9018a9088992be3c922926aee56"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gafff5f9018a9088992be3c922926aee56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gafff5f9018a9088992be3c922926aee56">hypot</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; x, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; y)</td></tr>
<tr class="memdesc:gafff5f9018a9088992be3c922926aee56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares.  <a href="group__FixedMath.html#gafff5f9018a9088992be3c922926aee56">More...</a><br /></td></tr>
<tr class="separator:gafff5f9018a9088992be3c922926aee56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga1e3ca7fb2626886c5920bbc5f570a525">round</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the given value.  <a href="group__FixedMath.html#ga1e3ca7fb2626886c5920bbc5f570a525">More...</a><br /></td></tr>
<tr class="separator:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8445167791eb53f1e8eb0dbf318293a1"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga8445167791eb53f1e8eb0dbf318293a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga8445167791eb53f1e8eb0dbf318293a1">signbit</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:ga8445167791eb53f1e8eb0dbf318293a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value is negative.  <a href="group__FixedMath.html#ga8445167791eb53f1e8eb0dbf318293a1">More...</a><br /></td></tr>
<tr class="separator:ga8445167791eb53f1e8eb0dbf318293a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8088b287bc76ea58ccb572e3e14012"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga7c8088b287bc76ea58ccb572e3e14012"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga7c8088b287bc76ea58ccb572e3e14012">isnan</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:ga7c8088b287bc76ea58ccb572e3e14012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is not-a-number.  <a href="group__FixedMath.html#ga7c8088b287bc76ea58ccb572e3e14012">More...</a><br /></td></tr>
<tr class="separator:ga7c8088b287bc76ea58ccb572e3e14012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fa73692143466ca4d584aacf5749f1"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gab8fa73692143466ca4d584aacf5749f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gab8fa73692143466ca4d584aacf5749f1">isfinite</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:gab8fa73692143466ca4d584aacf5749f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is finite.  <a href="group__FixedMath.html#gab8fa73692143466ca4d584aacf5749f1">More...</a><br /></td></tr>
<tr class="separator:gab8fa73692143466ca4d584aacf5749f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cd843c0cfe341550f2f4e5f91bf894"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27cd843c0cfe341550f2f4e5f91bf894"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a27cd843c0cfe341550f2f4e5f91bf894">GetSize</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a27cd843c0cfe341550f2f4e5f91bf894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the given interval.  <a href="#a27cd843c0cfe341550f2f4e5f91bf894">More...</a><br /></td></tr>
<tr class="separator:a27cd843c0cfe341550f2f4e5f91bf894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd40c765c799140cbe2b9e1ce4e82bb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd40c765c799140cbe2b9e1ce4e82bb7"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abd40c765c799140cbe2b9e1ce4e82bb7">GetCenter</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:abd40c765c799140cbe2b9e1ce4e82bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the center of the given interval.  <a href="#abd40c765c799140cbe2b9e1ce4e82bb7">More...</a><br /></td></tr>
<tr class="separator:abd40c765c799140cbe2b9e1ce4e82bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6337a4ffbf1fbfb13eece2bb55b93435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6337a4ffbf1fbfb13eece2bb55b93435"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6337a4ffbf1fbfb13eece2bb55b93435">IsIntersecting</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a6337a4ffbf1fbfb13eece2bb55b93435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two value ranges have any intersection/overlap at all.  <a href="#a6337a4ffbf1fbfb13eece2bb55b93435">More...</a><br /></td></tr>
<tr class="separator:a6337a4ffbf1fbfb13eece2bb55b93435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f28075bffede36f3b4c48a477edfda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1f28075bffede36f3b4c48a477edfda"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae1f28075bffede36f3b4c48a477edfda">GetIntersection</a> (<a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ae1f28075bffede36f3b4c48a477edfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the intersecting interval of two given ranges.  <a href="#ae1f28075bffede36f3b4c48a477edfda">More...</a><br /></td></tr>
<tr class="separator:ae1f28075bffede36f3b4c48a477edfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4597a31b2b04189ef75e8d72dbeb51"><td class="memTemplParams" colspan="2"><a id="a2b4597a31b2b04189ef75e8d72dbeb51"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b4597a31b2b04189ef75e8d72dbeb51"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2b4597a31b2b04189ef75e8d72dbeb51">IsEntirelyBefore</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a2b4597a31b2b04189ef75e8d72dbeb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range is entirely before the second range. <br /></td></tr>
<tr class="separator:a2b4597a31b2b04189ef75e8d72dbeb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a567a96ebb2a72b1046573bb4f13a4c"><td class="memTemplParams" colspan="2"><a id="a6a567a96ebb2a72b1046573bb4f13a4c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a567a96ebb2a72b1046573bb4f13a4c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6a567a96ebb2a72b1046573bb4f13a4c">IsEntirelyAfter</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a6a567a96ebb2a72b1046573bb4f13a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range is entirely after the second range. <br /></td></tr>
<tr class="separator:a6a567a96ebb2a72b1046573bb4f13a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29272f4a3694c4725faa56e6c4c1d2a2"><td class="memTemplParams" colspan="2"><a id="a29272f4a3694c4725faa56e6c4c1d2a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29272f4a3694c4725faa56e6c4c1d2a2"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a29272f4a3694c4725faa56e6c4c1d2a2">IsEntirelyEnclosing</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a29272f4a3694c4725faa56e6c4c1d2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range entirely encloses the second. <br /></td></tr>
<tr class="separator:a29272f4a3694c4725faa56e6c4c1d2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebf2ea3be7831ecd4559b2bc0d739c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abebf2ea3be7831ecd4559b2bc0d739c1"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abebf2ea3be7831ecd4559b2bc0d739c1">operator==</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:abebf2ea3be7831ecd4559b2bc0d739c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#abebf2ea3be7831ecd4559b2bc0d739c1">More...</a><br /></td></tr>
<tr class="separator:abebf2ea3be7831ecd4559b2bc0d739c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e28e7223ba1dc78278773b81130c19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56e28e7223ba1dc78278773b81130c19"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a56e28e7223ba1dc78278773b81130c19">operator!=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a56e28e7223ba1dc78278773b81130c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a56e28e7223ba1dc78278773b81130c19">More...</a><br /></td></tr>
<tr class="separator:a56e28e7223ba1dc78278773b81130c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24ce9e9d1f928ef3e60c6bede948966"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab24ce9e9d1f928ef3e60c6bede948966"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab24ce9e9d1f928ef3e60c6bede948966">operator&lt;</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab24ce9e9d1f928ef3e60c6bede948966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator.  <a href="#ab24ce9e9d1f928ef3e60c6bede948966">More...</a><br /></td></tr>
<tr class="separator:ab24ce9e9d1f928ef3e60c6bede948966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2a9ebae8216d14665a627b78c81a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54f2a9ebae8216d14665a627b78c81a8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a54f2a9ebae8216d14665a627b78c81a8">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a54f2a9ebae8216d14665a627b78c81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator.  <a href="#a54f2a9ebae8216d14665a627b78c81a8">More...</a><br /></td></tr>
<tr class="separator:a54f2a9ebae8216d14665a627b78c81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1061544f64556d9c7d77ae547a60b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d1061544f64556d9c7d77ae547a60b8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4d1061544f64556d9c7d77ae547a60b8">operator&gt;</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4d1061544f64556d9c7d77ae547a60b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator.  <a href="#a4d1061544f64556d9c7d77ae547a60b8">More...</a><br /></td></tr>
<tr class="separator:a4d1061544f64556d9c7d77ae547a60b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7ace6468a69a7f600ff05d01598ffd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f7ace6468a69a7f600ff05d01598ffd"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6f7ace6468a69a7f600ff05d01598ffd">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a6f7ace6468a69a7f600ff05d01598ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator.  <a href="#a6f7ace6468a69a7f600ff05d01598ffd">More...</a><br /></td></tr>
<tr class="separator:a6f7ace6468a69a7f600ff05d01598ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5053c1cb8807f6296852e4a8c657d2"><td class="memTemplParams" colspan="2"><a id="acd5053c1cb8807f6296852e4a8c657d2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd5053c1cb8807f6296852e4a8c657d2"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acd5053c1cb8807f6296852e4a8c657d2">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:acd5053c1cb8807f6296852e4a8c657d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:acd5053c1cb8807f6296852e4a8c657d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c036532db1260373b97c1d85360894c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8c036532db1260373b97c1d85360894c">GetDelta</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga8c036532db1260373b97c1d85360894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest angular distance to go from angle 1 to angle 2.  <a href="group__Math.html#ga8c036532db1260373b97c1d85360894c">More...</a><br /></td></tr>
<tr class="separator:ga8c036532db1260373b97c1d85360894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769785f0540a4b8960b282f6b105c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gae769785f0540a4b8960b282f6b105c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <a href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">More...</a><br /></td></tr>
<tr class="separator:gae769785f0540a4b8960b282f6b105c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3b8e8abc999b0c63cf1921b0edcf0b36">GetCircleVertices</a> (<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius, unsigned slices, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> start=0_deg, Real turns=Real{1})</td></tr>
<tr class="memdesc:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__BoundedAliases.html#gae872dc540686eb8e626643117f8cb62c">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0eb57dabfe8d3db9e509a6b493173358">GetAreaOfCircle</a> (<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius)</td></tr>
<tr class="memdesc:ga0eb57dabfe8d3db9e509a6b493173358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a circle. <br /></td></tr>
<tr class="separator:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118f8284073d2638e48ef8f13177e1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__BoundedAliases.html#gae872dc540686eb8e626643117f8cb62c">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">GetAreaOfPolygon</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga118f8284073d2638e48ef8f13177e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <a href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">More...</a><br /></td></tr>
<tr class="separator:ga118f8284073d2638e48ef8f13177e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#ga84a494e0a8763db409c32bde53324b06">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">GetPolarMoment</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <a href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">More...</a><br /></td></tr>
<tr class="separator:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40645d0127c8fd699610de821aebb57"><td class="memTemplParams" colspan="2"><a id="ac40645d0127c8fd699610de821aebb57"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac40645d0127c8fd699610de821aebb57"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac40645d0127c8fd699610de821aebb57">GetX</a> (T &amp;value)</td></tr>
<tr class="memdesc:ac40645d0127c8fd699610de821aebb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "X" element of the given value - i.e. the first element. <br /></td></tr>
<tr class="separator:ac40645d0127c8fd699610de821aebb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e87b921726f7c140ea35db1913ac6c"><td class="memTemplParams" colspan="2"><a id="ac8e87b921726f7c140ea35db1913ac6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8e87b921726f7c140ea35db1913ac6c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac8e87b921726f7c140ea35db1913ac6c">GetY</a> (T &amp;value)</td></tr>
<tr class="memdesc:ac8e87b921726f7c140ea35db1913ac6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Y" element of the given value - i.e. the second element. <br /></td></tr>
<tr class="separator:ac8e87b921726f7c140ea35db1913ac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be31a2325d99319d9cb505057ab44cb"><td class="memTemplParams" colspan="2"><a id="a8be31a2325d99319d9cb505057ab44cb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8be31a2325d99319d9cb505057ab44cb"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8be31a2325d99319d9cb505057ab44cb">GetZ</a> (T &amp;value)</td></tr>
<tr class="memdesc:a8be31a2325d99319d9cb505057ab44cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Z" element of the given value - i.e. the third element. <br /></td></tr>
<tr class="separator:a8be31a2325d99319d9cb505057ab44cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a4aa54b7951fcfd31d080a6faa47c0"><td class="memTemplParams" colspan="2"><a id="a99a4aa54b7951fcfd31d080a6faa47c0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99a4aa54b7951fcfd31d080a6faa47c0"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a99a4aa54b7951fcfd31d080a6faa47c0">GetX</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a99a4aa54b7951fcfd31d080a6faa47c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "X" element of the given value - i.e. the first element. <br /></td></tr>
<tr class="separator:a99a4aa54b7951fcfd31d080a6faa47c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1daa991d7fcea58ab2063a5fb94df8"><td class="memTemplParams" colspan="2"><a id="a5c1daa991d7fcea58ab2063a5fb94df8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c1daa991d7fcea58ab2063a5fb94df8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5c1daa991d7fcea58ab2063a5fb94df8">GetY</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a5c1daa991d7fcea58ab2063a5fb94df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Y" element of the given value - i.e. the second element. <br /></td></tr>
<tr class="separator:a5c1daa991d7fcea58ab2063a5fb94df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e5ac1606ff0591033cfd2f7f99cce4"><td class="memTemplParams" colspan="2"><a id="a90e5ac1606ff0591033cfd2f7f99cce4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90e5ac1606ff0591033cfd2f7f99cce4"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a90e5ac1606ff0591033cfd2f7f99cce4">GetZ</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a90e5ac1606ff0591033cfd2f7f99cce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Z" element of the given value - i.e. the third element. <br /></td></tr>
<tr class="separator:a90e5ac1606ff0591033cfd2f7f99cce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84205bd8956258eea02a5cb0d829042"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab84205bd8956258eea02a5cb0d829042"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, std::make_unsigned_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab84205bd8956258eea02a5cb0d829042">MakeUnsigned</a> (const T &amp;arg) noexcept</td></tr>
<tr class="memdesc:ab84205bd8956258eea02a5cb0d829042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the given value into an unsigned value.  <a href="#ab84205bd8956258eea02a5cb0d829042">More...</a><br /></td></tr>
<tr class="separator:ab84205bd8956258eea02a5cb0d829042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874b78de5f6a519116cca5fc0e3d0ce2"><td class="memTemplParams" colspan="2"><a id="a874b78de5f6a519116cca5fc0e3d0ce2"></a>
template&lt;typename T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:a874b78de5f6a519116cca5fc0e3d0ce2"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a874b78de5f6a519116cca5fc0e3d0ce2">StripUnit</a> (const <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; &amp;v)</td></tr>
<tr class="memdesc:a874b78de5f6a519116cca5fc0e3d0ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the unit from the given value. <br /></td></tr>
<tr class="separator:a874b78de5f6a519116cca5fc0e3d0ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb2415d17dfe0130be9799f945dbc5e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gafbb2415d17dfe0130be9799f945dbc5e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gafbb2415d17dfe0130be9799f945dbc5e">Secant</a> (T target, U a1, T s1, U a2, T s2) noexcept</td></tr>
<tr class="memdesc:gafbb2415d17dfe0130be9799f945dbc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant method.  <a href="group__Math.html#gafbb2415d17dfe0130be9799f945dbc5e">More...</a><br /></td></tr>
<tr class="separator:gafbb2415d17dfe0130be9799f945dbc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d729355fcef6f1d5d1e5e8a31f08cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53d729355fcef6f1d5d1e5e8a31f08cd"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga53d729355fcef6f1d5d1e5e8a31f08cd">Bisect</a> (T a1, T a2) noexcept</td></tr>
<tr class="memdesc:ga53d729355fcef6f1d5d1e5e8a31f08cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection method.  <a href="group__Math.html#ga53d729355fcef6f1d5d1e5e8a31f08cd">More...</a><br /></td></tr>
<tr class="separator:ga53d729355fcef6f1d5d1e5e8a31f08cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0999f6415f56dc56b97da946c23129"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d0999f6415f56dc56b97da946c23129"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga7d0999f6415f56dc56b97da946c23129">IsOdd</a> (T val) noexcept</td></tr>
<tr class="memdesc:ga7d0999f6415f56dc56b97da946c23129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-odd.  <a href="group__Math.html#ga7d0999f6415f56dc56b97da946c23129">More...</a><br /></td></tr>
<tr class="separator:ga7d0999f6415f56dc56b97da946c23129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9163760181cfb59593537b444defe6cf"><td class="memTemplParams" colspan="2">
template&lt;class TYPE &gt; </td></tr>
<tr class="memitem:ga9163760181cfb59593537b444defe6cf"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga9163760181cfb59593537b444defe6cf">Square</a> (TYPE t) noexcept</td></tr>
<tr class="memdesc:ga9163760181cfb59593537b444defe6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:ga9163760181cfb59593537b444defe6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values.  <a href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">More...</a><br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga7b2db834a9d392a7e63660f5dca67c73">Average</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const T &gt; span)</td></tr>
<tr class="memdesc:ga7b2db834a9d392a7e63660f5dca67c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsArithmetic.html">IsArithmetic</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab8f24574b8a0ca458ec2fe9d691364ff">RoundOff</a> (T value, unsigned precision=100000)</td></tr>
<tr class="memdesc:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga812ea5eaf66fb9d1bffa799886b2eee3">RoundOff</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> value, std::uint32_t precision=100000)</td></tr>
<tr class="memdesc:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memTemplParams" colspan="2">
template&lt;&gt; </td></tr>
<tr class="memitem:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8c5b7f3e28aa844cad21eb801d081cd3">Abs</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> a)</td></tr>
<tr class="memdesc:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a421602b65498ccc6c4567afe5a4d2"><td class="memTemplParams" colspan="2">
template&lt;&gt; </td></tr>
<tr class="memitem:ga24a421602b65498ccc6c4567afe5a4d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga24a421602b65498ccc6c4567afe5a4d2">Abs</a> (<a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> a)</td></tr>
<tr class="memdesc:ga24a421602b65498ccc6c4567afe5a4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ga24a421602b65498ccc6c4567afe5a4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8eade67bf49fee09cd743895113ebb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4e8eade67bf49fee09cd743895113ebb"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga4e8eade67bf49fee09cd743895113ebb">AlmostZero</a> (T value)</td></tr>
<tr class="memdesc:ga4e8eade67bf49fee09cd743895113ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group__Math.html#ga4e8eade67bf49fee09cd743895113ebb">More...</a><br /></td></tr>
<tr class="separator:ga4e8eade67bf49fee09cd743895113ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035c5294391f9652e8966092b5caca58"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga035c5294391f9652e8966092b5caca58"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga035c5294391f9652e8966092b5caca58">AlmostEqual</a> (T x, T y, int ulp=2)</td></tr>
<tr class="memdesc:ga035c5294391f9652e8966092b5caca58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga035c5294391f9652e8966092b5caca58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga25b52facf9e28f05e5e41f4e7b7ff54e">ModuloViaFmod</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::fmod</code>.  <a href="group__Math.html#ga25b52facf9e28f05e5e41f4e7b7ff54e">More...</a><br /></td></tr>
<tr class="separator:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">ModuloViaTrunc</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::trunc</code>.  <a href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">More...</a><br /></td></tr>
<tr class="separator:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a2abff11f978a8df25efbf0c10147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">GetNormalized</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> value) noexcept</td></tr>
<tr class="memdesc:ga156a2abff11f978a8df25efbf0c10147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle.  <a href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">More...</a><br /></td></tr>
<tr class="separator:ga156a2abff11f978a8df25efbf0c10147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">GetAngle</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; value)</td></tr>
<tr class="memdesc:ga56785e4c60180ef416fe29f68ccf525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <a href="group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">More...</a><br /></td></tr>
<tr class="separator:ga56785e4c60180ef416fe29f68ccf525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5292dcebbf79916913d2a8c3cc0f821"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac5292dcebbf79916913d2a8c3cc0f821"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gac5292dcebbf79916913d2a8c3cc0f821">GetMagnitudeSquared</a> (T value) noexcept</td></tr>
<tr class="memdesc:gac5292dcebbf79916913d2a8c3cc0f821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the magnitude of the given iterable value.  <a href="group__Math.html#gac5292dcebbf79916913d2a8c3cc0f821">More...</a><br /></td></tr>
<tr class="separator:gac5292dcebbf79916913d2a8c3cc0f821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">GetMagnitude</a> (T value)</td></tr>
<tr class="memdesc:ga85c114f129eeee63e60ec7d4703bbd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the magnitude of the given value.  <a href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">More...</a><br /></td></tr>
<tr class="separator:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a104de7c7a8d482209827d8b26dfa6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga76a104de7c7a8d482209827d8b26dfa6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga76a104de7c7a8d482209827d8b26dfa6">Dot</a> (const T1 a, const T2 b) noexcept</td></tr>
<tr class="memdesc:ga76a104de7c7a8d482209827d8b26dfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <a href="group__Math.html#ga76a104de7c7a8d482209827d8b26dfa6">More...</a><br /></td></tr>
<tr class="separator:ga76a104de7c7a8d482209827d8b26dfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5853b82d4317a3c002b5aae800caf44"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size&lt; T1 &gt;::value==2 &amp;&amp;std::tuple_size&lt; T2 &gt;::value==2, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gaf5853b82d4317a3c002b5aae800caf44"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaf5853b82d4317a3c002b5aae800caf44">Cross</a> (T1 a, T2 b) noexcept</td></tr>
<tr class="memdesc:gaf5853b82d4317a3c002b5aae800caf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-element analog of the cross product of two vectors.  <a href="group__Math.html#gaf5853b82d4317a3c002b5aae800caf44">More...</a><br /></td></tr>
<tr class="separator:gaf5853b82d4317a3c002b5aae800caf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48e5d966eb9e5d6b126f7fbe10d3b697"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga48e5d966eb9e5d6b126f7fbe10d3b697"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga48e5d966eb9e5d6b126f7fbe10d3b697">Solve</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; b) noexcept</td></tr>
<tr class="memdesc:ga48e5d966eb9e5d6b126f7fbe10d3b697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga48e5d966eb9e5d6b126f7fbe10d3b697">More...</a><br /></td></tr>
<tr class="separator:ga48e5d966eb9e5d6b126f7fbe10d3b697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93fcc5a3b89a2c26ebeb2ba69e31a6d"><td class="memTemplParams" colspan="2">
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:gaa93fcc5a3b89a2c26ebeb2ba69e31a6d"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaa93fcc5a3b89a2c26ebeb2ba69e31a6d">Invert</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; IN_TYPE &gt; value) noexcept</td></tr>
<tr class="memdesc:gaa93fcc5a3b89a2c26ebeb2ba69e31a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:gaa93fcc5a3b89a2c26ebeb2ba69e31a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5971f12d70f44aaa1659523dd79bad56"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga5971f12d70f44aaa1659523dd79bad56">Solve33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:ga5971f12d70f44aaa1659523dd79bad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga5971f12d70f44aaa1659523dd79bad56">More...</a><br /></td></tr>
<tr class="separator:ga5971f12d70f44aaa1659523dd79bad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307196931b0b067cacfb6b690547554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga307196931b0b067cacfb6b690547554c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga307196931b0b067cacfb6b690547554c">Solve22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const T b) noexcept</td></tr>
<tr class="memdesc:ga307196931b0b067cacfb6b690547554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga307196931b0b067cacfb6b690547554c">More...</a><br /></td></tr>
<tr class="separator:ga307196931b0b067cacfb6b690547554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929129f73956d318af97ba018147d673"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga929129f73956d318af97ba018147d673">GetInverse22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ga929129f73956d318af97ba018147d673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <a href="group__Math.html#ga929129f73956d318af97ba018147d673">More...</a><br /></td></tr>
<tr class="separator:ga929129f73956d318af97ba018147d673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05611bc6ee4ca8ba6b60074ca969568"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gac05611bc6ee4ca8ba6b60074ca969568">GetSymInverse33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gac05611bc6ee4ca8ba6b60074ca969568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <a href="group__Math.html#gac05611bc6ee4ca8ba6b60074ca969568">More...</a><br /></td></tr>
<tr class="separator:gac05611bc6ee4ca8ba6b60074ca969568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db75e579c251d11bbb7da89184bcbc5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7db75e579c251d11bbb7da89184bcbc5"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga7db75e579c251d11bbb7da89184bcbc5">GetRevPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga7db75e579c251d11bbb7da89184bcbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.  <a href="group__Math.html#ga7db75e579c251d11bbb7da89184bcbc5">More...</a><br /></td></tr>
<tr class="separator:ga7db75e579c251d11bbb7da89184bcbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b2d4eb2cee9e0e14f8e9eea46df5e5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga00b2d4eb2cee9e0e14f8e9eea46df5e5"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga00b2d4eb2cee9e0e14f8e9eea46df5e5">GetFwdPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga00b2d4eb2cee9e0e14f8e9eea46df5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.  <a href="group__Math.html#ga00b2d4eb2cee9e0e14f8e9eea46df5e5">More...</a><br /></td></tr>
<tr class="separator:ga00b2d4eb2cee9e0e14f8e9eea46df5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab12e9930e01cf5596b23e2e63d83f2a"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </td></tr>
<tr class="memitem:gaab12e9930e01cf5596b23e2e63d83f2a"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaab12e9930e01cf5596b23e2e63d83f2a">Transform</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt; v, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gaab12e9930e01cf5596b23e2e63d83f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an M-element vector by an M-by-N matrix.  <a href="group__Math.html#gaab12e9930e01cf5596b23e2e63d83f2a">More...</a><br /></td></tr>
<tr class="separator:gaab12e9930e01cf5596b23e2e63d83f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24b2130cf7cb682b1f9d2ce2f701f29"><td class="memItemLeft" align="right" valign="top">
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gac24b2130cf7cb682b1f9d2ce2f701f29">Transform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:gac24b2130cf7cb682b1f9d2ce2f701f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by a matrix. <br /></td></tr>
<tr class="separator:gac24b2130cf7cb682b1f9d2ce2f701f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c5113af7bc4a93fb0df5e812a5bf7d"><td class="memItemLeft" align="right" valign="top">
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga05c5113af7bc4a93fb0df5e812a5bf7d">InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga05c5113af7bc4a93fb0df5e812a5bf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform). <br /></td></tr>
<tr class="separator:ga05c5113af7bc4a93fb0df5e812a5bf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827e59c08791e02964cd63d4382a4549"><td class="memItemLeft" align="right" valign="top">
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga827e59c08791e02964cd63d4382a4549">MulT</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:ga827e59c08791e02964cd63d4382a4549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:ga827e59c08791e02964cd63d4382a4549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa726d0bc106afc7a490573f3d008f6bc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaa726d0bc106afc7a490573f3d008f6bc">Abs</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A)</td></tr>
<tr class="memdesc:gaa726d0bc106afc7a490573f3d008f6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gaa726d0bc106afc7a490573f3d008f6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0b59c2f32f6ee92dfc708bb3198ffe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed0b59c2f32f6ee92dfc708bb3198ffe"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaed0b59c2f32f6ee92dfc708bb3198ffe">Clamp</a> (T value, T low, T high) noexcept</td></tr>
<tr class="memdesc:gaed0b59c2f32f6ee92dfc708bb3198ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the given value within the given range (inclusive).  <a href="group__Math.html#gaed0b59c2f32f6ee92dfc708bb3198ffe">More...</a><br /></td></tr>
<tr class="separator:gaed0b59c2f32f6ee92dfc708bb3198ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0ad2d1e2b11362e91193d313ee00e78c">NextPowerOfTwo</a> (std::uint64_t x)</td></tr>
<tr class="memdesc:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <a href="group__Math.html#ga0ad2d1e2b11362e91193d313ee00e78c">More...</a><br /></td></tr>
<tr class="separator:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">Normalize</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5218fea988cf8865a55252d7c282442"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab5218fea988cf8865a55252d7c282442"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab5218fea988cf8865a55252d7c282442">GetModuloNext</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:gab5218fea988cf8865a55252d7c282442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value. <br /></td></tr>
<tr class="separator:gab5218fea988cf8865a55252d7c282442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de9ef40d734a89581bcd6b0804e9b02"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9de9ef40d734a89581bcd6b0804e9b02"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga9de9ef40d734a89581bcd6b0804e9b02">GetModuloPrev</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:ga9de9ef40d734a89581bcd6b0804e9b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value. <br /></td></tr>
<tr class="separator:ga9de9ef40d734a89581bcd6b0804e9b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23479fc2522d30b5faf88d4a343d264"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaa23479fc2522d30b5faf88d4a343d264">GetRevRotationalAngle</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:gaa23479fc2522d30b5faf88d4a343d264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#gaa23479fc2522d30b5faf88d4a343d264">More...</a><br /></td></tr>
<tr class="separator:gaa23479fc2522d30b5faf88d4a343d264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4f43ebaadcd88f829efb082cebec9d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4a4f43ebaadcd88f829efb082cebec9d"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T &gt;::value, <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, N, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4a4f43ebaadcd88f829efb082cebec9d">GetIdentityMatrix</a> ()</td></tr>
<tr class="memdesc:a4a4f43ebaadcd88f829efb082cebec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the identity matrix of the template type and size.  <a href="#a4a4f43ebaadcd88f829efb082cebec9d">More...</a><br /></td></tr>
<tr class="separator:a4a4f43ebaadcd88f829efb082cebec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c7cbea13790b72a4bb3aa4af99091c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43c7cbea13790b72a4bb3aa4af99091c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsSquareMatrix.html">IsSquareMatrix</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a43c7cbea13790b72a4bb3aa4af99091c">GetIdentity</a> ()</td></tr>
<tr class="memdesc:a43c7cbea13790b72a4bb3aa4af99091c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the identity matrix of the template type and size as given by the argument.  <a href="#a43c7cbea13790b72a4bb3aa4af99091c">More...</a><br /></td></tr>
<tr class="separator:a43c7cbea13790b72a4bb3aa4af99091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a1715447f7dce79bb09f4bf50745d4"><td class="memTemplParams" colspan="2"><a id="a63a1715447f7dce79bb09f4bf50745d4"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a63a1715447f7dce79bb09f4bf50745d4"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a63a1715447f7dce79bb09f4bf50745d4">GetRowMatrix</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; arg)</td></tr>
<tr class="memdesc:a63a1715447f7dce79bb09f4bf50745d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified row of the given matrix as a row matrix. <br /></td></tr>
<tr class="separator:a63a1715447f7dce79bb09f4bf50745d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdbbbb834c3389a6efef355718e98b8"><td class="memTemplParams" colspan="2"><a id="a5fdbbbb834c3389a6efef355718e98b8"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5fdbbbb834c3389a6efef355718e98b8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 1 &gt;, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5fdbbbb834c3389a6efef355718e98b8">GetColumnMatrix</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; arg)</td></tr>
<tr class="memdesc:a5fdbbbb834c3389a6efef355718e98b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified column of the given matrix as a column matrix. <br /></td></tr>
<tr class="separator:a5fdbbbb834c3389a6efef355718e98b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ab91ce9948b28251bd5f7010ea56f8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:ae0ab91ce9948b28251bd5f7010ea56f8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae0ab91ce9948b28251bd5f7010ea56f8">operator+</a> (const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;lhs, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae0ab91ce9948b28251bd5f7010ea56f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition operator for two same-type, same-sized matrices.  <a href="#ae0ab91ce9948b28251bd5f7010ea56f8">More...</a><br /></td></tr>
<tr class="separator:ae0ab91ce9948b28251bd5f7010ea56f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf301cca25ae9324372e0d266601be2e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:abf301cca25ae9324372e0d266601be2e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abf301cca25ae9324372e0d266601be2e">operator-</a> (const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;lhs, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abf301cca25ae9324372e0d266601be2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix subtraction operator for two same-type, same-sized matrices.  <a href="#abf301cca25ae9324372e0d266601be2e">More...</a><br /></td></tr>
<tr class="separator:abf301cca25ae9324372e0d266601be2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b8dab819e96f993cfdb8c5852ea3e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aec0b8dab819e96f993cfdb8c5852ea3e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aec0b8dab819e96f993cfdb8c5852ea3e">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aec0b8dab819e96f993cfdb8c5852ea3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="#aec0b8dab819e96f993cfdb8c5852ea3e">More...</a><br /></td></tr>
<tr class="separator:aec0b8dab819e96f993cfdb8c5852ea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ad6edf9c44c85648f309ab373c5f33"><td class="memTemplParams" colspan="2"><a id="a46ad6edf9c44c85648f309ab373c5f33"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a46ad6edf9c44c85648f309ab373c5f33"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a46ad6edf9c44c85648f309ab373c5f33">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a46ad6edf9c44c85648f309ab373c5f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for a <code>Mat22</code>. <br /></td></tr>
<tr class="separator:a46ad6edf9c44c85648f309ab373c5f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed18ca9774b8ac513ee9c21153395b8e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aed18ca9774b8ac513ee9c21153395b8e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aed18ca9774b8ac513ee9c21153395b8e">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Position.html">d2::Position</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aed18ca9774b8ac513ee9c21153395b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="#aed18ca9774b8ac513ee9c21153395b8e">More...</a><br /></td></tr>
<tr class="separator:aed18ca9774b8ac513ee9c21153395b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf75cdc5cfd576aa0e67d5ce89a14fe3"><td class="memTemplParams" colspan="2"><a id="acf75cdc5cfd576aa0e67d5ce89a14fe3"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:acf75cdc5cfd576aa0e67d5ce89a14fe3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acf75cdc5cfd576aa0e67d5ce89a14fe3">operator+</a> (<a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acf75cdc5cfd576aa0e67d5ce89a14fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator. <br /></td></tr>
<tr class="separator:acf75cdc5cfd576aa0e67d5ce89a14fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b598e13399fc27f3bbfd0b1b09a344"><td class="memTemplParams" colspan="2"><a id="a55b598e13399fc27f3bbfd0b1b09a344"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:a55b598e13399fc27f3bbfd0b1b09a344"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a55b598e13399fc27f3bbfd0b1b09a344">operator-</a> (<a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a55b598e13399fc27f3bbfd0b1b09a344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator. <br /></td></tr>
<tr class="separator:a55b598e13399fc27f3bbfd0b1b09a344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d3e82ca292784c4ec4f98d078570c2"><td class="memTemplParams" colspan="2"><a id="a99d3e82ca292784c4ec4f98d078570c2"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:a99d3e82ca292784c4ec4f98d078570c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a99d3e82ca292784c4ec4f98d078570c2">operator==</a> (const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a99d3e82ca292784c4ec4f98d078570c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a99d3e82ca292784c4ec4f98d078570c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f02a0f10816399d867067a692694dd"><td class="memTemplParams" colspan="2"><a id="ae3f02a0f10816399d867067a692694dd"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:ae3f02a0f10816399d867067a692694dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae3f02a0f10816399d867067a692694dd">operator!=</a> (const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae3f02a0f10816399d867067a692694dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ae3f02a0f10816399d867067a692694dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39080dffdba57b934e80469d36ef331"><td class="memTemplParams" colspan="2"><a id="ac39080dffdba57b934e80469d36ef331"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:ac39080dffdba57b934e80469d36ef331"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac39080dffdba57b934e80469d36ef331">operator&lt;</a> (const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac39080dffdba57b934e80469d36ef331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:ac39080dffdba57b934e80469d36ef331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc00c596dc6c478c2031dd857276f73"><td class="memTemplParams" colspan="2"><a id="aebc00c596dc6c478c2031dd857276f73"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:aebc00c596dc6c478c2031dd857276f73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aebc00c596dc6c478c2031dd857276f73">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aebc00c596dc6c478c2031dd857276f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:aebc00c596dc6c478c2031dd857276f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a35e221c9450af374d98ba95b09ccc"><td class="memTemplParams" colspan="2"><a id="a60a35e221c9450af374d98ba95b09ccc"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:a60a35e221c9450af374d98ba95b09ccc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a60a35e221c9450af374d98ba95b09ccc">operator&gt;</a> (const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a60a35e221c9450af374d98ba95b09ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:a60a35e221c9450af374d98ba95b09ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d16981402e01b86c42fc2611e73b10"><td class="memTemplParams" colspan="2"><a id="a33d16981402e01b86c42fc2611e73b10"></a>
template&lt;typename AT , class For &gt; </td></tr>
<tr class="memitem:a33d16981402e01b86c42fc2611e73b10"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a33d16981402e01b86c42fc2611e73b10">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1StrongTyped.html">StrongTyped</a>&lt; AT, For &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a33d16981402e01b86c42fc2611e73b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:a33d16981402e01b86c42fc2611e73b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51995ca843108552f24b8ccf3c7bcee"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa51995ca843108552f24b8ccf3c7bcee"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa51995ca843108552f24b8ccf3c7bcee">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1Sweep.html">d2::Sweep</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aa51995ca843108552f24b8ccf3c7bcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="#aa51995ca843108552f24b8ccf3c7bcee">More...</a><br /></td></tr>
<tr class="separator:aa51995ca843108552f24b8ccf3c7bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a2b892f4effbc98c1b2468d6eb56a"><td class="memTemplParams" colspan="2"><a id="a465a2b892f4effbc98c1b2468d6eb56a"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a465a2b892f4effbc98c1b2468d6eb56a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a465a2b892f4effbc98c1b2468d6eb56a">NOT_USED</a> (T &amp;&amp;...)</td></tr>
<tr class="memdesc:a465a2b892f4effbc98c1b2468d6eb56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Not used" annotator. <br /></td></tr>
<tr class="separator:a465a2b892f4effbc98c1b2468d6eb56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b14742ed432c0aebf43b831665d39c7"><td class="memTemplParams" colspan="2"><a id="a2b14742ed432c0aebf43b831665d39c7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b14742ed432c0aebf43b831665d39c7"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2b14742ed432c0aebf43b831665d39c7">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a2b14742ed432c0aebf43b831665d39c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the type. <br /></td></tr>
<tr class="separator:a2b14742ed432c0aebf43b831665d39c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebca9d65a7fe1b13d2153365ea5c38df"><td class="memTemplParams" colspan="2"><a id="aebca9d65a7fe1b13d2153365ea5c38df"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebca9d65a7fe1b13d2153365ea5c38df"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aebca9d65a7fe1b13d2153365ea5c38df">IsValid</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:aebca9d65a7fe1b13d2153365ea5c38df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:aebca9d65a7fe1b13d2153365ea5c38df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aa3531167e1c43c6f69a015a9ec964"><td class="memTemplParams" colspan="2"><a id="a17aa3531167e1c43c6f69a015a9ec964"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a17aa3531167e1c43c6f69a015a9ec964"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a17aa3531167e1c43c6f69a015a9ec964">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a17aa3531167e1c43c6f69a015a9ec964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the float type. <br /></td></tr>
<tr class="separator:a17aa3531167e1c43c6f69a015a9ec964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd997c2502dccea0749fadb36883baa"><td class="memTemplParams" colspan="2"><a id="a9dd997c2502dccea0749fadb36883baa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9dd997c2502dccea0749fadb36883baa"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9dd997c2502dccea0749fadb36883baa">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a9dd997c2502dccea0749fadb36883baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the double type. <br /></td></tr>
<tr class="separator:a9dd997c2502dccea0749fadb36883baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c64746b22afc3d6ae0e9305c60dd03"><td class="memTemplParams" colspan="2"><a id="ad8c64746b22afc3d6ae0e9305c60dd03"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad8c64746b22afc3d6ae0e9305c60dd03"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR long double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad8c64746b22afc3d6ae0e9305c60dd03">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:ad8c64746b22afc3d6ae0e9305c60dd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the long double type. <br /></td></tr>
<tr class="separator:ad8c64746b22afc3d6ae0e9305c60dd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2185dbf222c27d604ae575bcbd9b732"><td class="memTemplParams" colspan="2"><a id="ad2185dbf222c27d604ae575bcbd9b732"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2185dbf222c27d604ae575bcbd9b732"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad2185dbf222c27d604ae575bcbd9b732">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:ad2185dbf222c27d604ae575bcbd9b732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the std::size_t type. <br /></td></tr>
<tr class="separator:ad2185dbf222c27d604ae575bcbd9b732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac426fb8460298ceef49047f0d8d30a78"><td class="memTemplParams" colspan="2"><a id="ac426fb8460298ceef49047f0d8d30a78"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac426fb8460298ceef49047f0d8d30a78"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac426fb8460298ceef49047f0d8d30a78">IsValid</a> (const std::size_t &amp;value) noexcept</td></tr>
<tr class="memdesc:ac426fb8460298ceef49047f0d8d30a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:ac426fb8460298ceef49047f0d8d30a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7657def9da2229b6a95d1a37008b0258"><td class="memTemplParams" colspan="2"><a id="a7657def9da2229b6a95d1a37008b0258"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7657def9da2229b6a95d1a37008b0258"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7657def9da2229b6a95d1a37008b0258">GetPtr</a> (const T *value) noexcept</td></tr>
<tr class="memdesc:a7657def9da2229b6a95d1a37008b0258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer for the given variable. <br /></td></tr>
<tr class="separator:a7657def9da2229b6a95d1a37008b0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e04f144e783ab9e0ddbdbdec18b54f"><td class="memTemplParams" colspan="2"><a id="a46e04f144e783ab9e0ddbdbdec18b54f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a46e04f144e783ab9e0ddbdbdec18b54f"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a46e04f144e783ab9e0ddbdbdec18b54f">GetPtr</a> (T *value) noexcept</td></tr>
<tr class="memdesc:a46e04f144e783ab9e0ddbdbdec18b54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer for the given variable. <br /></td></tr>
<tr class="separator:a46e04f144e783ab9e0ddbdbdec18b54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499b8202232b69ed772a6c4fe29f0b23"><td class="memTemplParams" colspan="2"><a id="a499b8202232b69ed772a6c4fe29f0b23"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a499b8202232b69ed772a6c4fe29f0b23"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a499b8202232b69ed772a6c4fe29f0b23">GetPtr</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:a499b8202232b69ed772a6c4fe29f0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer for the given variable. <br /></td></tr>
<tr class="separator:a499b8202232b69ed772a6c4fe29f0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12088eebdc95c1928618bfecf50b75bd"><td class="memTemplParams" colspan="2"><a id="a12088eebdc95c1928618bfecf50b75bd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a12088eebdc95c1928618bfecf50b75bd"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a12088eebdc95c1928618bfecf50b75bd">GetPtr</a> (T &amp;value) noexcept</td></tr>
<tr class="memdesc:a12088eebdc95c1928618bfecf50b75bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer for the given variable. <br /></td></tr>
<tr class="separator:a12088eebdc95c1928618bfecf50b75bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3194ff280eae2efe80483c3388891c"><td class="memTemplParams" colspan="2"><a id="a3c3194ff280eae2efe80483c3388891c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c3194ff280eae2efe80483c3388891c"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3c3194ff280eae2efe80483c3388891c">GetRef</a> (const T *value) noexcept</td></tr>
<tr class="memdesc:a3c3194ff280eae2efe80483c3388891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference for the given variable. <br /></td></tr>
<tr class="separator:a3c3194ff280eae2efe80483c3388891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d64e2849426d3384a5f4bac7a6616b6"><td class="memTemplParams" colspan="2"><a id="a3d64e2849426d3384a5f4bac7a6616b6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d64e2849426d3384a5f4bac7a6616b6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3d64e2849426d3384a5f4bac7a6616b6">GetRef</a> (T *value) noexcept</td></tr>
<tr class="memdesc:a3d64e2849426d3384a5f4bac7a6616b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference for the given variable. <br /></td></tr>
<tr class="separator:a3d64e2849426d3384a5f4bac7a6616b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950ed668ea747caad43033fe820bb876"><td class="memTemplParams" colspan="2"><a id="a950ed668ea747caad43033fe820bb876"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a950ed668ea747caad43033fe820bb876"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a950ed668ea747caad43033fe820bb876">GetRef</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:a950ed668ea747caad43033fe820bb876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference for the given variable. <br /></td></tr>
<tr class="separator:a950ed668ea747caad43033fe820bb876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740409a73c321d59d72dae06bd0ae890"><td class="memTemplParams" colspan="2"><a id="a740409a73c321d59d72dae06bd0ae890"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a740409a73c321d59d72dae06bd0ae890"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a740409a73c321d59d72dae06bd0ae890">GetRef</a> (T &amp;value) noexcept</td></tr>
<tr class="memdesc:a740409a73c321d59d72dae06bd0ae890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference for the given variable. <br /></td></tr>
<tr class="separator:a740409a73c321d59d72dae06bd0ae890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d72a91d98ac22b6b7603f9747bca314"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d72a91d98ac22b6b7603f9747bca314"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4d72a91d98ac22b6b7603f9747bca314">Visit</a> (const T &amp;, void *)</td></tr>
<tr class="memdesc:a4d72a91d98ac22b6b7603f9747bca314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function for visiting objects.  <a href="#a4d72a91d98ac22b6b7603f9747bca314">More...</a><br /></td></tr>
<tr class="separator:a4d72a91d98ac22b6b7603f9747bca314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09121345512aa02387efe31575450d6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09121345512aa02387efe31575450d6c"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a09121345512aa02387efe31575450d6c">GetTypeName</a> () noexcept</td></tr>
<tr class="memdesc:a09121345512aa02387efe31575450d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the library defined name for the given type.  <a href="#a09121345512aa02387efe31575450d6c">More...</a><br /></td></tr>
<tr class="separator:a09121345512aa02387efe31575450d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d64e8a9e599a8d64e38376b391d62e"><td class="memTemplParams" colspan="2"><a id="aa6d64e8a9e599a8d64e38376b391d62e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa6d64e8a9e599a8d64e38376b391d62e"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa6d64e8a9e599a8d64e38376b391d62e">GetTypeName&lt; float &gt;</a> () noexcept</td></tr>
<tr class="memdesc:aa6d64e8a9e599a8d64e38376b391d62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a human recognizable name for the float type. <br /></td></tr>
<tr class="separator:aa6d64e8a9e599a8d64e38376b391d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff06bebc8d932908c6cda3738a8be297"><td class="memTemplParams" colspan="2"><a id="aff06bebc8d932908c6cda3738a8be297"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aff06bebc8d932908c6cda3738a8be297"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aff06bebc8d932908c6cda3738a8be297">GetTypeName&lt; double &gt;</a> () noexcept</td></tr>
<tr class="memdesc:aff06bebc8d932908c6cda3738a8be297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a human recognizable name for the double type. <br /></td></tr>
<tr class="separator:aff06bebc8d932908c6cda3738a8be297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab607914db71f28acb7e60624f6a419a2"><td class="memTemplParams" colspan="2"><a id="ab607914db71f28acb7e60624f6a419a2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab607914db71f28acb7e60624f6a419a2"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab607914db71f28acb7e60624f6a419a2">GetTypeName&lt; long double &gt;</a> () noexcept</td></tr>
<tr class="memdesc:ab607914db71f28acb7e60624f6a419a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a human recognizable name for the long double type. <br /></td></tr>
<tr class="separator:ab607914db71f28acb7e60624f6a419a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a9c0f69c4031d87c3159a25d763e4b"><td class="memTemplParams" colspan="2"><a id="a15a9c0f69c4031d87c3159a25d763e4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15a9c0f69c4031d87c3159a25d763e4b"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a15a9c0f69c4031d87c3159a25d763e4b">Abs</a> (T a)</td></tr>
<tr class="memdesc:a15a9c0f69c4031d87c3159a25d763e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of the given value. <br /></td></tr>
<tr class="separator:a15a9c0f69c4031d87c3159a25d763e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75679dddad0465e76a3293176fc1eb67"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a75679dddad0465e76a3293176fc1eb67"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a75679dddad0465e76a3293176fc1eb67">IsEmpty</a> (const T &amp;arg) -&gt; decltype(arg.empty())</td></tr>
<tr class="memdesc:a75679dddad0465e76a3293176fc1eb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given container is empty.  <a href="#a75679dddad0465e76a3293176fc1eb67">More...</a><br /></td></tr>
<tr class="separator:a75679dddad0465e76a3293176fc1eb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f14d6b4300980071278dc4f968d36db"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f14d6b4300980071278dc4f968d36db"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7f14d6b4300980071278dc4f968d36db">GetSize</a> (const T &amp;arg) -&gt; decltype(arg.size())</td></tr>
<tr class="memdesc:a7f14d6b4300980071278dc4f968d36db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current size of the given container.  <a href="#a7f14d6b4300980071278dc4f968d36db">More...</a><br /></td></tr>
<tr class="separator:a7f14d6b4300980071278dc4f968d36db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a80a488e25e34e1e43f95ce5a2830fe"><td class="memTemplParams" colspan="2"><a id="a1a80a488e25e34e1e43f95ce5a2830fe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a80a488e25e34e1e43f95ce5a2830fe"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1a80a488e25e34e1e43f95ce5a2830fe">GetMaxSize</a> (const T &amp;arg) -&gt; decltype(arg.max_size())</td></tr>
<tr class="memdesc:a1a80a488e25e34e1e43f95ce5a2830fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum size of the given container. <br /></td></tr>
<tr class="separator:a1a80a488e25e34e1e43f95ce5a2830fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331d0f9eebffe5a6de76b5124975bdbf"><td class="memTemplParams" colspan="2"><a id="a331d0f9eebffe5a6de76b5124975bdbf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a331d0f9eebffe5a6de76b5124975bdbf"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a331d0f9eebffe5a6de76b5124975bdbf">IsFull</a> (const T &amp;arg) -&gt; decltype(<a class="el" href="namespaceplayrho.html#ad0c4ceb8ef2cef80108a8d9dcb0da945">GetSize</a>(arg)==arg.max_size())</td></tr>
<tr class="memdesc:a331d0f9eebffe5a6de76b5124975bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given container is full. <br /></td></tr>
<tr class="separator:a331d0f9eebffe5a6de76b5124975bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa952a45e627aa1a3cf8f83be23ec533"><td class="memTemplParams" colspan="2"><a id="afa952a45e627aa1a3cf8f83be23ec533"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:afa952a45e627aa1a3cf8f83be23ec533"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afa952a45e627aa1a3cf8f83be23ec533">GetSize</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:afa952a45e627aa1a3cf8f83be23ec533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the compile-time size of a C-style array. <br /></td></tr>
<tr class="separator:afa952a45e627aa1a3cf8f83be23ec533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85222e60032cfff157b66b69d86a7941"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a85222e60032cfff157b66b69d86a7941"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a85222e60032cfff157b66b69d86a7941">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Transformation.html">d2::Transformation</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a85222e60032cfff157b66b69d86a7941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="#a85222e60032cfff157b66b69d86a7941">More...</a><br /></td></tr>
<tr class="separator:a85222e60032cfff157b66b69d86a7941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8040ad9d50312fa73c864b069d05aea7"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga8040ad9d50312fa73c864b069d05aea7">operator&quot;&quot; _g</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga8040ad9d50312fa73c864b069d05aea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gram unit of Mass.  <a href="group__Unitsymbols.html#ga8040ad9d50312fa73c864b069d05aea7">More...</a><br /></td></tr>
<tr class="separator:ga8040ad9d50312fa73c864b069d05aea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c024493242edcbfb008c4d80a4399d7"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga5c024493242edcbfb008c4d80a4399d7">operator&quot;&quot; _g</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga5c024493242edcbfb008c4d80a4399d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gram unit of Mass.  <a href="group__Unitsymbols.html#ga5c024493242edcbfb008c4d80a4399d7">More...</a><br /></td></tr>
<tr class="separator:ga5c024493242edcbfb008c4d80a4399d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487ee5c35c018ff7780e162842b3fba6"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga487ee5c35c018ff7780e162842b3fba6">operator&quot;&quot; _kg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga487ee5c35c018ff7780e162842b3fba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a kilogram unit of Mass.  <a href="group__Unitsymbols.html#ga487ee5c35c018ff7780e162842b3fba6">More...</a><br /></td></tr>
<tr class="separator:ga487ee5c35c018ff7780e162842b3fba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffdbd18cdc04357fbc04bf9f10e3d14d"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaffdbd18cdc04357fbc04bf9f10e3d14d">operator&quot;&quot; _kg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaffdbd18cdc04357fbc04bf9f10e3d14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a kilogram unit of Mass.  <a href="group__Unitsymbols.html#gaffdbd18cdc04357fbc04bf9f10e3d14d">More...</a><br /></td></tr>
<tr class="separator:gaffdbd18cdc04357fbc04bf9f10e3d14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga766da6630f92d07dd6c37a86a249733c"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga766da6630f92d07dd6c37a86a249733c">operator&quot;&quot; _Yg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga766da6630f92d07dd6c37a86a249733c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a yottagram unit of Mass.  <a href="group__Unitsymbols.html#ga766da6630f92d07dd6c37a86a249733c">More...</a><br /></td></tr>
<tr class="separator:ga766da6630f92d07dd6c37a86a249733c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd28e8099eae18b182971b31bbb222ea"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gacd28e8099eae18b182971b31bbb222ea">operator&quot;&quot; _Yg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gacd28e8099eae18b182971b31bbb222ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a yottagram unit of Mass.  <a href="group__Unitsymbols.html#gacd28e8099eae18b182971b31bbb222ea">More...</a><br /></td></tr>
<tr class="separator:gacd28e8099eae18b182971b31bbb222ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabea44133255849a79659b512921a5a01"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gabea44133255849a79659b512921a5a01">operator&quot;&quot; _m</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gabea44133255849a79659b512921a5a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a meter of Length.  <a href="group__Unitsymbols.html#gabea44133255849a79659b512921a5a01">More...</a><br /></td></tr>
<tr class="separator:gabea44133255849a79659b512921a5a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b12002aac98614c901a20b20f043b3b"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga3b12002aac98614c901a20b20f043b3b">operator&quot;&quot; _m</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga3b12002aac98614c901a20b20f043b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a meter of Length.  <a href="group__Unitsymbols.html#ga3b12002aac98614c901a20b20f043b3b">More...</a><br /></td></tr>
<tr class="separator:ga3b12002aac98614c901a20b20f043b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb22cf6088e7090626d45671ac6fcb5c"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gabb22cf6088e7090626d45671ac6fcb5c">operator&quot;&quot; _dm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gabb22cf6088e7090626d45671ac6fcb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a decimeter of Length.  <a href="group__Unitsymbols.html#gabb22cf6088e7090626d45671ac6fcb5c">More...</a><br /></td></tr>
<tr class="separator:gabb22cf6088e7090626d45671ac6fcb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c388dcd1905058179ed96c9b292c359"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga3c388dcd1905058179ed96c9b292c359">operator&quot;&quot; _dm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga3c388dcd1905058179ed96c9b292c359"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a decimeter of Length.  <a href="group__Unitsymbols.html#ga3c388dcd1905058179ed96c9b292c359">More...</a><br /></td></tr>
<tr class="separator:ga3c388dcd1905058179ed96c9b292c359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca4e42fedbd6a2337ae51f5a71ef12c"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gafca4e42fedbd6a2337ae51f5a71ef12c">operator&quot;&quot; _cm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gafca4e42fedbd6a2337ae51f5a71ef12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a centimeter of Length.  <a href="group__Unitsymbols.html#gafca4e42fedbd6a2337ae51f5a71ef12c">More...</a><br /></td></tr>
<tr class="separator:gafca4e42fedbd6a2337ae51f5a71ef12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab435f6912267733ad2d303ea16c534d6"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab435f6912267733ad2d303ea16c534d6">operator&quot;&quot; _cm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab435f6912267733ad2d303ea16c534d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a centimeter of Length.  <a href="group__Unitsymbols.html#gab435f6912267733ad2d303ea16c534d6">More...</a><br /></td></tr>
<tr class="separator:gab435f6912267733ad2d303ea16c534d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db7294952670f348ef461eed58fef38"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4db7294952670f348ef461eed58fef38">operator&quot;&quot; _Gm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga4db7294952670f348ef461eed58fef38"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gigameter unit of Length.  <a href="group__Unitsymbols.html#ga4db7294952670f348ef461eed58fef38">More...</a><br /></td></tr>
<tr class="separator:ga4db7294952670f348ef461eed58fef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6450212b522cc22e3619d599afc5306"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae6450212b522cc22e3619d599afc5306">operator&quot;&quot; _Gm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gae6450212b522cc22e3619d599afc5306"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gigameter unit of Length.  <a href="group__Unitsymbols.html#gae6450212b522cc22e3619d599afc5306">More...</a><br /></td></tr>
<tr class="separator:gae6450212b522cc22e3619d599afc5306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64700f80da78f469756c45c440cf3f04"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga64700f80da78f469756c45c440cf3f04">operator&quot;&quot; _km</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga64700f80da78f469756c45c440cf3f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a kilometer unit of Length.  <a href="group__Unitsymbols.html#ga64700f80da78f469756c45c440cf3f04">More...</a><br /></td></tr>
<tr class="separator:ga64700f80da78f469756c45c440cf3f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c55d7ab8a2817929f8b717124f7fb47"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga6c55d7ab8a2817929f8b717124f7fb47">operator&quot;&quot; _km</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga6c55d7ab8a2817929f8b717124f7fb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a kilometer unit of Length.  <a href="group__Unitsymbols.html#ga6c55d7ab8a2817929f8b717124f7fb47">More...</a><br /></td></tr>
<tr class="separator:ga6c55d7ab8a2817929f8b717124f7fb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4804777cc4294102cc87f83e65f882aa"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4804777cc4294102cc87f83e65f882aa">operator&quot;&quot; _s</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga4804777cc4294102cc87f83e65f882aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a second unit of Time.  <a href="group__Unitsymbols.html#ga4804777cc4294102cc87f83e65f882aa">More...</a><br /></td></tr>
<tr class="separator:ga4804777cc4294102cc87f83e65f882aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66518eaae46239aca650ac50876797d6"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga66518eaae46239aca650ac50876797d6">operator&quot;&quot; _s</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga66518eaae46239aca650ac50876797d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a second unit of Time.  <a href="group__Unitsymbols.html#ga66518eaae46239aca650ac50876797d6">More...</a><br /></td></tr>
<tr class="separator:ga66518eaae46239aca650ac50876797d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e57732955f83fc20ba2940f772c49bb"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1e57732955f83fc20ba2940f772c49bb">operator&quot;&quot; _min</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1e57732955f83fc20ba2940f772c49bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a minute unit of Time.  <a href="group__Unitsymbols.html#ga1e57732955f83fc20ba2940f772c49bb">More...</a><br /></td></tr>
<tr class="separator:ga1e57732955f83fc20ba2940f772c49bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4d82cc27fb37a51045344b12088333"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga3f4d82cc27fb37a51045344b12088333">operator&quot;&quot; _min</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga3f4d82cc27fb37a51045344b12088333"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a minute unit of Time.  <a href="group__Unitsymbols.html#ga3f4d82cc27fb37a51045344b12088333">More...</a><br /></td></tr>
<tr class="separator:ga3f4d82cc27fb37a51045344b12088333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e6683029e3be1968b42928db5d8e81"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga21e6683029e3be1968b42928db5d8e81">operator&quot;&quot; _h</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga21e6683029e3be1968b42928db5d8e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for an hour unit of Time.  <a href="group__Unitsymbols.html#ga21e6683029e3be1968b42928db5d8e81">More...</a><br /></td></tr>
<tr class="separator:ga21e6683029e3be1968b42928db5d8e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2abe922817d1dd5cf31380e0a1fbef7f"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga2abe922817d1dd5cf31380e0a1fbef7f">operator&quot;&quot; _h</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga2abe922817d1dd5cf31380e0a1fbef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for an hour unit of Time.  <a href="group__Unitsymbols.html#ga2abe922817d1dd5cf31380e0a1fbef7f">More...</a><br /></td></tr>
<tr class="separator:ga2abe922817d1dd5cf31380e0a1fbef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5289f608e3c69ae4a0532b8e3455e812"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga5289f608e3c69ae4a0532b8e3455e812">operator&quot;&quot; _d</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga5289f608e3c69ae4a0532b8e3455e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for a day unit of Time.  <a href="group__Unitsymbols.html#ga5289f608e3c69ae4a0532b8e3455e812">More...</a><br /></td></tr>
<tr class="separator:ga5289f608e3c69ae4a0532b8e3455e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cd39a8f90db4d8584b0bfd9c5bea91"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab4cd39a8f90db4d8584b0bfd9c5bea91">operator&quot;&quot; _d</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab4cd39a8f90db4d8584b0bfd9c5bea91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for a day unit of Time.  <a href="group__Unitsymbols.html#gab4cd39a8f90db4d8584b0bfd9c5bea91">More...</a><br /></td></tr>
<tr class="separator:gab4cd39a8f90db4d8584b0bfd9c5bea91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0bf5b16a6e211fac8bf1a2f3c9cdbe"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga5b0bf5b16a6e211fac8bf1a2f3c9cdbe">operator&quot;&quot; _rad</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga5b0bf5b16a6e211fac8bf1a2f3c9cdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a radian unit of Angle.  <a href="group__Unitsymbols.html#ga5b0bf5b16a6e211fac8bf1a2f3c9cdbe">More...</a><br /></td></tr>
<tr class="separator:ga5b0bf5b16a6e211fac8bf1a2f3c9cdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0891c9a35e9de313e5ddd5f7e0e9fa9"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab0891c9a35e9de313e5ddd5f7e0e9fa9">operator&quot;&quot; _rad</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab0891c9a35e9de313e5ddd5f7e0e9fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a radian unit of Angle.  <a href="group__Unitsymbols.html#gab0891c9a35e9de313e5ddd5f7e0e9fa9">More...</a><br /></td></tr>
<tr class="separator:gab0891c9a35e9de313e5ddd5f7e0e9fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fdeff8d9d9d5de3bb052997b4e74f39"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga9fdeff8d9d9d5de3bb052997b4e74f39">operator&quot;&quot; _deg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga9fdeff8d9d9d5de3bb052997b4e74f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for a degree unit of Angle.  <a href="group__Unitsymbols.html#ga9fdeff8d9d9d5de3bb052997b4e74f39">More...</a><br /></td></tr>
<tr class="separator:ga9fdeff8d9d9d5de3bb052997b4e74f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60a5e0f9dccfd389db3faacff1ec3c8"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaa60a5e0f9dccfd389db3faacff1ec3c8">operator&quot;&quot; _deg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaa60a5e0f9dccfd389db3faacff1ec3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for a degree unit of Angle.  <a href="group__Unitsymbols.html#gaa60a5e0f9dccfd389db3faacff1ec3c8">More...</a><br /></td></tr>
<tr class="separator:gaa60a5e0f9dccfd389db3faacff1ec3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2fb46228d12914c433bb68a4349d945"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae2fb46228d12914c433bb68a4349d945">operator&quot;&quot; _N</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gae2fb46228d12914c433bb68a4349d945"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton unit of Force.  <a href="group__Unitsymbols.html#gae2fb46228d12914c433bb68a4349d945">More...</a><br /></td></tr>
<tr class="separator:gae2fb46228d12914c433bb68a4349d945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e7f5935f082c1dedfe94655076860b"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga78e7f5935f082c1dedfe94655076860b">operator&quot;&quot; _N</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga78e7f5935f082c1dedfe94655076860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton unit of Force.  <a href="group__Unitsymbols.html#ga78e7f5935f082c1dedfe94655076860b">More...</a><br /></td></tr>
<tr class="separator:ga78e7f5935f082c1dedfe94655076860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf718d8d1b2cb89d77ce397d67337092"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gadf718d8d1b2cb89d77ce397d67337092">operator&quot;&quot; _m2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gadf718d8d1b2cb89d77ce397d67337092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter squared unit of Area.  <a href="group__Unitsymbols.html#gadf718d8d1b2cb89d77ce397d67337092">More...</a><br /></td></tr>
<tr class="separator:gadf718d8d1b2cb89d77ce397d67337092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d089acf7cf2d7d805abc4e64180a71"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga46d089acf7cf2d7d805abc4e64180a71">operator&quot;&quot; _m2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga46d089acf7cf2d7d805abc4e64180a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter squared unit of Area.  <a href="group__Unitsymbols.html#ga46d089acf7cf2d7d805abc4e64180a71">More...</a><br /></td></tr>
<tr class="separator:ga46d089acf7cf2d7d805abc4e64180a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083f2b1a76145234f96d8c1494f0dfd7"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga083f2b1a76145234f96d8c1494f0dfd7">operator&quot;&quot; _mps</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga083f2b1a76145234f96d8c1494f0dfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second.  <a href="group__Unitsymbols.html#ga083f2b1a76145234f96d8c1494f0dfd7">More...</a><br /></td></tr>
<tr class="separator:ga083f2b1a76145234f96d8c1494f0dfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37cae2d6af52ca68ba569f89acc2eb39"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga37cae2d6af52ca68ba569f89acc2eb39">operator&quot;&quot; _mps</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga37cae2d6af52ca68ba569f89acc2eb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second.  <a href="group__Unitsymbols.html#ga37cae2d6af52ca68ba569f89acc2eb39">More...</a><br /></td></tr>
<tr class="separator:ga37cae2d6af52ca68ba569f89acc2eb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd0607b78e0936d606cbeff81087380"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1cd0607b78e0936d606cbeff81087380">operator&quot;&quot; _kps</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1cd0607b78e0936d606cbeff81087380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilometer per second.  <a href="group__Unitsymbols.html#ga1cd0607b78e0936d606cbeff81087380">More...</a><br /></td></tr>
<tr class="separator:ga1cd0607b78e0936d606cbeff81087380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2591c003d51edc92ee2f6e21a1111e0e"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga2591c003d51edc92ee2f6e21a1111e0e">operator&quot;&quot; _kps</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga2591c003d51edc92ee2f6e21a1111e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilometer per second.  <a href="group__Unitsymbols.html#ga2591c003d51edc92ee2f6e21a1111e0e">More...</a><br /></td></tr>
<tr class="separator:ga2591c003d51edc92ee2f6e21a1111e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d98e990b0112a09981bb89b2ec1978"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad1d98e990b0112a09981bb89b2ec1978">operator&quot;&quot; _mps2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gad1d98e990b0112a09981bb89b2ec1978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second squared.  <a href="group__Unitsymbols.html#gad1d98e990b0112a09981bb89b2ec1978">More...</a><br /></td></tr>
<tr class="separator:gad1d98e990b0112a09981bb89b2ec1978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ef8800c5a4d29097107bda8f979e3d"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab0ef8800c5a4d29097107bda8f979e3d">operator&quot;&quot; _mps2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab0ef8800c5a4d29097107bda8f979e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second squared.  <a href="group__Unitsymbols.html#gab0ef8800c5a4d29097107bda8f979e3d">More...</a><br /></td></tr>
<tr class="separator:gab0ef8800c5a4d29097107bda8f979e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6abec5ad8adab1f0a91f308b35850865"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga6abec5ad8adab1f0a91f308b35850865">operator&quot;&quot; _Hz</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga6abec5ad8adab1f0a91f308b35850865"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a hertz unit of Frequency.  <a href="group__Unitsymbols.html#ga6abec5ad8adab1f0a91f308b35850865">More...</a><br /></td></tr>
<tr class="separator:ga6abec5ad8adab1f0a91f308b35850865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2a01afc98a9b1b46c80729fbfe1b19"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga7c2a01afc98a9b1b46c80729fbfe1b19">operator&quot;&quot; _Hz</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga7c2a01afc98a9b1b46c80729fbfe1b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a hertz unit of Frequency.  <a href="group__Unitsymbols.html#ga7c2a01afc98a9b1b46c80729fbfe1b19">More...</a><br /></td></tr>
<tr class="separator:ga7c2a01afc98a9b1b46c80729fbfe1b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab777ce411e28b62470ed8abb774aa64"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaab777ce411e28b62470ed8abb774aa64">operator&quot;&quot; _Nm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaab777ce411e28b62470ed8abb774aa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for newton-meter unit of torque.  <a href="group__Unitsymbols.html#gaab777ce411e28b62470ed8abb774aa64">More...</a><br /></td></tr>
<tr class="separator:gaab777ce411e28b62470ed8abb774aa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d244a3e438c7fee0a82c340d63fdc78"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4d244a3e438c7fee0a82c340d63fdc78">operator&quot;&quot; _Nm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga4d244a3e438c7fee0a82c340d63fdc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for newton-meter unit of torque.  <a href="group__Unitsymbols.html#ga4d244a3e438c7fee0a82c340d63fdc78">More...</a><br /></td></tr>
<tr class="separator:ga4d244a3e438c7fee0a82c340d63fdc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f504bcbfedfda4497cde4d106f8e2cd"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1f504bcbfedfda4497cde4d106f8e2cd">operator&quot;&quot; _Ns</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1f504bcbfedfda4497cde4d106f8e2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton second of impulse.  <a href="group__Unitsymbols.html#ga1f504bcbfedfda4497cde4d106f8e2cd">More...</a><br /></td></tr>
<tr class="separator:ga1f504bcbfedfda4497cde4d106f8e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc15d4eb5753ba0746b3cceafbf7429"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaacc15d4eb5753ba0746b3cceafbf7429">operator&quot;&quot; _Ns</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaacc15d4eb5753ba0746b3cceafbf7429"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton second of impulse.  <a href="group__Unitsymbols.html#gaacc15d4eb5753ba0746b3cceafbf7429">More...</a><br /></td></tr>
<tr class="separator:gaacc15d4eb5753ba0746b3cceafbf7429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c5b245c64b0d663490ddf50c9bf33a"><td class="memItemLeft" align="right" valign="top">
PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga93c5b245c64b0d663490ddf50c9bf33a">operator&quot;&quot; _kgpm2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga93c5b245c64b0d663490ddf50c9bf33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilogram per square meter. <br /></td></tr>
<tr class="separator:ga93c5b245c64b0d663490ddf50c9bf33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56569af5c38f324baed6b79698301d0a"><td class="memItemLeft" align="right" valign="top">
PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga56569af5c38f324baed6b79698301d0a">operator&quot;&quot; _kgpm2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga56569af5c38f324baed6b79698301d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilogram per square meter. <br /></td></tr>
<tr class="separator:ga56569af5c38f324baed6b79698301d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383329e7a2f092ece9a8fa1bdabdb480"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga383329e7a2f092ece9a8fa1bdabdb480">operator&quot;&quot; _rpm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga383329e7a2f092ece9a8fa1bdabdb480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for revolutions per minute.  <a href="group__Unitsymbols.html#ga383329e7a2f092ece9a8fa1bdabdb480">More...</a><br /></td></tr>
<tr class="separator:ga383329e7a2f092ece9a8fa1bdabdb480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2784ecea54f617631def05752ccf3533"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga2784ecea54f617631def05752ccf3533">operator&quot;&quot; _rpm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga2784ecea54f617631def05752ccf3533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for revolutions per minute.  <a href="group__Unitsymbols.html#ga2784ecea54f617631def05752ccf3533">More...</a><br /></td></tr>
<tr class="separator:ga2784ecea54f617631def05752ccf3533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7953adf3060305d984bce50ab31398"><td class="memItemLeft" align="right" valign="top"><a id="adb7953adf3060305d984bce50ab31398"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adb7953adf3060305d984bce50ab31398">StripUnit</a> (const <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> value)</td></tr>
<tr class="memdesc:adb7953adf3060305d984bce50ab31398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the units off of the given value. <br /></td></tr>
<tr class="separator:adb7953adf3060305d984bce50ab31398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8c8a56bc58de7e2b5b615ca27e49ae"><td class="memTemplParams" colspan="2"><a id="a0e8c8a56bc58de7e2b5b615ca27e49ae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0e8c8a56bc58de7e2b5b615ca27e49ae"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0e8c8a56bc58de7e2b5b615ca27e49ae">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a0e8c8a56bc58de7e2b5b615ca27e49ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the <code>UnitVec</code> type. <br /></td></tr>
<tr class="separator:a0e8c8a56bc58de7e2b5b615ca27e49ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490b25838c4ed7c8eaed66bd354ce11b"><td class="memTemplParams" colspan="2"><a id="a490b25838c4ed7c8eaed66bd354ce11b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a490b25838c4ed7c8eaed66bd354ce11b"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a490b25838c4ed7c8eaed66bd354ce11b">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a490b25838c4ed7c8eaed66bd354ce11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a490b25838c4ed7c8eaed66bd354ce11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57dd3d609c236bf471a84526d8dfe4e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac57dd3d609c236bf471a84526d8dfe4e"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac57dd3d609c236bf471a84526d8dfe4e">operator==</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac57dd3d609c236bf471a84526d8dfe4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#ac57dd3d609c236bf471a84526d8dfe4e">More...</a><br /></td></tr>
<tr class="separator:ac57dd3d609c236bf471a84526d8dfe4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0b5a548efed2357cfdfa38c746f00f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:afb0b5a548efed2357cfdfa38c746f00f"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afb0b5a548efed2357cfdfa38c746f00f">operator!=</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:afb0b5a548efed2357cfdfa38c746f00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#afb0b5a548efed2357cfdfa38c746f00f">More...</a><br /></td></tr>
<tr class="separator:afb0b5a548efed2357cfdfa38c746f00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32698762d0d37c394a55cdd167cd4948"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a32698762d0d37c394a55cdd167cd4948"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a32698762d0d37c394a55cdd167cd4948">operator+</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; v) noexcept</td></tr>
<tr class="memdesc:a32698762d0d37c394a55cdd167cd4948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus operator.  <a href="#a32698762d0d37c394a55cdd167cd4948">More...</a><br /></td></tr>
<tr class="separator:a32698762d0d37c394a55cdd167cd4948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b14eb31c39cb09ab1e073c98b575de4"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4b14eb31c39cb09ab1e073c98b575de4"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(-T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4b14eb31c39cb09ab1e073c98b575de4">operator-</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; v) noexcept</td></tr>
<tr class="memdesc:a4b14eb31c39cb09ab1e073c98b575de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation operator.  <a href="#a4b14eb31c39cb09ab1e073c98b575de4">More...</a><br /></td></tr>
<tr class="separator:a4b14eb31c39cb09ab1e073c98b575de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac37e361c264eb820a4fcd0957b6659"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9ac37e361c264eb820a4fcd0957b6659"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{}+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9ac37e361c264eb820a4fcd0957b6659">operator+=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a9ac37e361c264eb820a4fcd0957b6659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the left hand side value by the right hand side value.  <a href="#a9ac37e361c264eb820a4fcd0957b6659">More...</a><br /></td></tr>
<tr class="separator:a9ac37e361c264eb820a4fcd0957b6659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17db72d9d3cf57a3dcde299003091925"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a17db72d9d3cf57a3dcde299003091925"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{} - T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a17db72d9d3cf57a3dcde299003091925">operator-=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a17db72d9d3cf57a3dcde299003091925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the left hand side value by the right hand side value.  <a href="#a17db72d9d3cf57a3dcde299003091925">More...</a><br /></td></tr>
<tr class="separator:a17db72d9d3cf57a3dcde299003091925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f12e932cc3ae8a52a46acb6a759018"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a26f12e932cc3ae8a52a46acb6a759018"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{}+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a26f12e932cc3ae8a52a46acb6a759018">operator+</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a26f12e932cc3ae8a52a46acb6a759018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors component-wise.  <a href="#a26f12e932cc3ae8a52a46acb6a759018">More...</a><br /></td></tr>
<tr class="separator:a26f12e932cc3ae8a52a46acb6a759018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4498290f800bb77a09ca6e181f4d200"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae4498290f800bb77a09ca6e181f4d200"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{} - T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae4498290f800bb77a09ca6e181f4d200">operator-</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ae4498290f800bb77a09ca6e181f4d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two vectors component-wise.  <a href="#ae4498290f800bb77a09ca6e181f4d200">More...</a><br /></td></tr>
<tr class="separator:ae4498290f800bb77a09ca6e181f4d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3867e38d81818a352ab8e6f527a5dafa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t N&gt; </td></tr>
<tr class="memitem:a3867e38d81818a352ab8e6f527a5dafa"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T1, decltype(T1{} *T2{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3867e38d81818a352ab8e6f527a5dafa">operator*=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;lhs, const T2 rhs) noexcept</td></tr>
<tr class="memdesc:a3867e38d81818a352ab8e6f527a5dafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator.  <a href="#a3867e38d81818a352ab8e6f527a5dafa">More...</a><br /></td></tr>
<tr class="separator:a3867e38d81818a352ab8e6f527a5dafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ef497cc5b8197cec1fb5bf7fcdb546"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t N&gt; </td></tr>
<tr class="memitem:a33ef497cc5b8197cec1fb5bf7fcdb546"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T1, decltype(T1{}/T2{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a33ef497cc5b8197cec1fb5bf7fcdb546">operator/=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;lhs, const T2 rhs) noexcept</td></tr>
<tr class="memdesc:a33ef497cc5b8197cec1fb5bf7fcdb546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator.  <a href="#a33ef497cc5b8197cec1fb5bf7fcdb546">More...</a><br /></td></tr>
<tr class="separator:a33ef497cc5b8197cec1fb5bf7fcdb546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916ffd1ead44fed6c0296cd1eb152de8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, std::size_t C, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a916ffd1ead44fed6c0296cd1eb152de8"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, C &gt;, A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a916ffd1ead44fed6c0296cd1eb152de8">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, B &gt;, A &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, C &gt;, B &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a916ffd1ead44fed6c0296cd1eb152de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the matrix product of the two given vector of vectors (matrices).  <a href="#a916ffd1ead44fed6c0296cd1eb152de8">More...</a><br /></td></tr>
<tr class="separator:a916ffd1ead44fed6c0296cd1eb152de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65669d8b8c23c5569bfcf6a5262a6cdb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a65669d8b8c23c5569bfcf6a5262a6cdb"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T1 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a65669d8b8c23c5569bfcf6a5262a6cdb">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, B &gt;, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a65669d8b8c23c5569bfcf6a5262a6cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an A-element vector by a A-by-B vector of vectors.  <a href="#a65669d8b8c23c5569bfcf6a5262a6cdb">More...</a><br /></td></tr>
<tr class="separator:a65669d8b8c23c5569bfcf6a5262a6cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a493b2f768fa07b50356b4ba142ad11"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a9a493b2f768fa07b50356b4ba142ad11"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9a493b2f768fa07b50356b4ba142ad11">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt;, B &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9a493b2f768fa07b50356b4ba142ad11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a B-by-A vector of vectors by an A-element vector.  <a href="#a9a493b2f768fa07b50356b4ba142ad11">More...</a><br /></td></tr>
<tr class="separator:a9a493b2f768fa07b50356b4ba142ad11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49704e8fc8a2eb2e95e3a429ad638f50"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a49704e8fc8a2eb2e95e3a429ad638f50"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T1 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a49704e8fc8a2eb2e95e3a429ad638f50">operator*</a> (const T1 s, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, N &gt; a) noexcept</td></tr>
<tr class="memdesc:a49704e8fc8a2eb2e95e3a429ad638f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for non-vector times vector.  <a href="#a49704e8fc8a2eb2e95e3a429ad638f50">More...</a><br /></td></tr>
<tr class="separator:a49704e8fc8a2eb2e95e3a429ad638f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329a09aded9f2ef0d9f599153feebc63"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a329a09aded9f2ef0d9f599153feebc63"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a329a09aded9f2ef0d9f599153feebc63">operator*</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; a, const T2 s) noexcept</td></tr>
<tr class="memdesc:a329a09aded9f2ef0d9f599153feebc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for vector times non-vector.  <a href="#a329a09aded9f2ef0d9f599153feebc63">More...</a><br /></td></tr>
<tr class="separator:a329a09aded9f2ef0d9f599153feebc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adc6d6a43f882bafb2b88a4e7091e57"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} / T2{})&gt; </td></tr>
<tr class="memitem:a7adc6d6a43f882bafb2b88a4e7091e57"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsDivisable.html">IsDivisable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7adc6d6a43f882bafb2b88a4e7091e57">operator/</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; a, const T2 s) noexcept</td></tr>
<tr class="memdesc:a7adc6d6a43f882bafb2b88a4e7091e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator.  <a href="#a7adc6d6a43f882bafb2b88a4e7091e57">More...</a><br /></td></tr>
<tr class="separator:a7adc6d6a43f882bafb2b88a4e7091e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f714963917f6a632001a9bb3a3d1d6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a53f714963917f6a632001a9bb3a3d1d6"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a53f714963917f6a632001a9bb3a3d1d6">operator&lt;</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a53f714963917f6a632001a9bb3a3d1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical less-than operator.  <a href="#a53f714963917f6a632001a9bb3a3d1d6">More...</a><br /></td></tr>
<tr class="separator:a53f714963917f6a632001a9bb3a3d1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8920673b547533b8ea9ae73a337cd426"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a8920673b547533b8ea9ae73a337cd426"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8920673b547533b8ea9ae73a337cd426">operator&lt;=</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8920673b547533b8ea9ae73a337cd426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical less-than or equal-to operator.  <a href="#a8920673b547533b8ea9ae73a337cd426">More...</a><br /></td></tr>
<tr class="separator:a8920673b547533b8ea9ae73a337cd426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dcf1a39cfc007ab5fc07b698d306e9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab6dcf1a39cfc007ab5fc07b698d306e9"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab6dcf1a39cfc007ab5fc07b698d306e9">operator&gt;</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab6dcf1a39cfc007ab5fc07b698d306e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical greater-than operator.  <a href="#ab6dcf1a39cfc007ab5fc07b698d306e9">More...</a><br /></td></tr>
<tr class="separator:ab6dcf1a39cfc007ab5fc07b698d306e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0a3cf79016d76c6949999433a8fb5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a69f0a3cf79016d76c6949999433a8fb5"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a69f0a3cf79016d76c6949999433a8fb5">operator&gt;=</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a69f0a3cf79016d76c6949999433a8fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical greater-than or equal-to operator.  <a href="#a69f0a3cf79016d76c6949999433a8fb5">More...</a><br /></td></tr>
<tr class="separator:a69f0a3cf79016d76c6949999433a8fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d0f1bd8dfe3701e5380723c3277d68"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:ac7d0f1bd8dfe3701e5380723c3277d68"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac7d0f1bd8dfe3701e5380723c3277d68">Get</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ac7d0f1bd8dfe3701e5380723c3277d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified element of the given collection.  <a href="#ac7d0f1bd8dfe3701e5380723c3277d68">More...</a><br /></td></tr>
<tr class="separator:ac7d0f1bd8dfe3701e5380723c3277d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085b8e66ff69811fec516bc22b15300"><td class="memTemplParams" colspan="2"><a id="ac085b8e66ff69811fec516bc22b15300"></a>
template&lt;std::size_t I, std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:ac085b8e66ff69811fec516bc22b15300"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac085b8e66ff69811fec516bc22b15300">Get</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ac085b8e66ff69811fec516bc22b15300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified element of the given collection. <br /></td></tr>
<tr class="separator:ac085b8e66ff69811fec516bc22b15300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda91572806860fa512fff0f01a001b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6bda91572806860fa512fff0f01a001b"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6bda91572806860fa512fff0f01a001b">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value)</td></tr>
<tr class="memdesc:a6bda91572806860fa512fff0f01a001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator.  <a href="#a6bda91572806860fa512fff0f01a001b">More...</a><br /></td></tr>
<tr class="separator:a6bda91572806860fa512fff0f01a001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e902077bbcd4070f04162092c8fb1d"><td class="memItemLeft" align="right" valign="top"><a id="a92e902077bbcd4070f04162092c8fb1d"></a>
PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a92e902077bbcd4070f04162092c8fb1d">GetVec2</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; value)</td></tr>
<tr class="memdesc:a92e902077bbcd4070f04162092c8fb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the given value as a 2-element vector of reals (<code>Vec2</code>). <br /></td></tr>
<tr class="separator:a92e902077bbcd4070f04162092c8fb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3ce7339659b652b23610ac0d500a71"><td class="memTemplParams" colspan="2"><a id="a8e3ce7339659b652b23610ac0d500a71"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8e3ce7339659b652b23610ac0d500a71"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8e3ce7339659b652b23610ac0d500a71">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a8e3ce7339659b652b23610ac0d500a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the <code>Vec2</code> type. <br /></td></tr>
<tr class="separator:a8e3ce7339659b652b23610ac0d500a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d7ab7f222264a61b3894b2eefe883"><td class="memTemplParams" colspan="2"><a id="ac84d7ab7f222264a61b3894b2eefe883"></a>
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ac84d7ab7f222264a61b3894b2eefe883"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac84d7ab7f222264a61b3894b2eefe883">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; TYPE &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ac84d7ab7f222264a61b3894b2eefe883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given vector contains finite coordinates. <br /></td></tr>
<tr class="separator:ac84d7ab7f222264a61b3894b2eefe883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d5fa1d077fbec64800d99ce2775aae"><td class="memTemplParams" colspan="2"><a id="a54d5fa1d077fbec64800d99ce2775aae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a54d5fa1d077fbec64800d99ce2775aae"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a54d5fa1d077fbec64800d99ce2775aae">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:a54d5fa1d077fbec64800d99ce2775aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid value for the 3-element vector of real (<code>Vec3</code>) type. <br /></td></tr>
<tr class="separator:a54d5fa1d077fbec64800d99ce2775aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6887c8070394826911cddf7c29be82"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2b6887c8070394826911cddf7c29be82"><td class="memTemplItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2b6887c8070394826911cddf7c29be82">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Velocity.html">d2::Velocity</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a2b6887c8070394826911cddf7c29be82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="#a2b6887c8070394826911cddf7c29be82">More...</a><br /></td></tr>
<tr class="separator:a2b6887c8070394826911cddf7c29be82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ad5413c876b34dcf8430c045986cc"><td class="memItemLeft" align="right" valign="top"><a id="af43ad5413c876b34dcf8430c045986cc"></a>
<a class="el" href="structplayrho_1_1Version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af43ad5413c876b34dcf8430c045986cc">GetVersion</a> () noexcept</td></tr>
<tr class="memdesc:af43ad5413c876b34dcf8430c045986cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version information of the library. <br /></td></tr>
<tr class="separator:af43ad5413c876b34dcf8430c045986cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e36c723d641ea2e8dad6e8653f6ffd"><td class="memItemLeft" align="right" valign="top"><a id="a66e36c723d641ea2e8dad6e8653f6ffd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a66e36c723d641ea2e8dad6e8653f6ffd">GetBuildDetails</a> () noexcept</td></tr>
<tr class="memdesc:a66e36c723d641ea2e8dad6e8653f6ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the build details of the library. <br /></td></tr>
<tr class="separator:a66e36c723d641ea2e8dad6e8653f6ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58823f4cba966f2ddf371bf48656a74"><td class="memItemLeft" align="right" valign="top"><a id="ad58823f4cba966f2ddf371bf48656a74"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad58823f4cba966f2ddf371bf48656a74">operator==</a> (<a class="el" href="structplayrho_1_1Version.html">Version</a> lhs, <a class="el" href="structplayrho_1_1Version.html">Version</a> rhs)</td></tr>
<tr class="memdesc:ad58823f4cba966f2ddf371bf48656a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:ad58823f4cba966f2ddf371bf48656a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe456353b547ab70b3050be04644b974"><td class="memItemLeft" align="right" valign="top"><a id="afe456353b547ab70b3050be04644b974"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afe456353b547ab70b3050be04644b974">operator!=</a> (<a class="el" href="structplayrho_1_1Version.html">Version</a> lhs, <a class="el" href="structplayrho_1_1Version.html">Version</a> rhs)</td></tr>
<tr class="memdesc:afe456353b547ab70b3050be04644b974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:afe456353b547ab70b3050be04644b974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d46e6e45df1f7049decee120ce9922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a50d46e6e45df1f7049decee120ce9922">MixFriction</a> (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> friction1, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> friction2)</td></tr>
<tr class="memdesc:a50d46e6e45df1f7049decee120ce9922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes friction.  <a href="#a50d46e6e45df1f7049decee120ce9922">More...</a><br /></td></tr>
<tr class="separator:a50d46e6e45df1f7049decee120ce9922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2574637d4c8869ae345d3975829cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abdd2574637d4c8869ae345d3975829cc">MixRestitution</a> (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> restitution1, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> restitution2) noexcept</td></tr>
<tr class="memdesc:abdd2574637d4c8869ae345d3975829cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes restitution.  <a href="#abdd2574637d4c8869ae345d3975829cc">More...</a><br /></td></tr>
<tr class="separator:abdd2574637d4c8869ae345d3975829cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd8c9bd6313579a5b5bc194b62847cc"><td class="memItemLeft" align="right" valign="top"><a id="a5dd8c9bd6313579a5b5bc194b62847cc"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5dd8c9bd6313579a5b5bc194b62847cc">operator==</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a5dd8c9bd6313579a5b5bc194b62847cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a5dd8c9bd6313579a5b5bc194b62847cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b7e8f86343cf046ccfe30c5b0920dd"><td class="memItemLeft" align="right" valign="top"><a id="a73b7e8f86343cf046ccfe30c5b0920dd"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a73b7e8f86343cf046ccfe30c5b0920dd">operator!=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a73b7e8f86343cf046ccfe30c5b0920dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a73b7e8f86343cf046ccfe30c5b0920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3ad5b08a3971eebd78d95866df2278"><td class="memItemLeft" align="right" valign="top"><a id="a1c3ad5b08a3971eebd78d95866df2278"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1c3ad5b08a3971eebd78d95866df2278">operator&lt;</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a1c3ad5b08a3971eebd78d95866df2278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:a1c3ad5b08a3971eebd78d95866df2278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a0945c99fc7012e010f1892d0d2f5"><td class="memItemLeft" align="right" valign="top"><a id="a048a0945c99fc7012e010f1892d0d2f5"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a048a0945c99fc7012e010f1892d0d2f5">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a048a0945c99fc7012e010f1892d0d2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a048a0945c99fc7012e010f1892d0d2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a5f2b320e151ec9c0b63815685f7f4"><td class="memItemLeft" align="right" valign="top"><a id="ac5a5f2b320e151ec9c0b63815685f7f4"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac5a5f2b320e151ec9c0b63815685f7f4">operator&gt;</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:ac5a5f2b320e151ec9c0b63815685f7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:ac5a5f2b320e151ec9c0b63815685f7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b58a8a5896dc5d9dfbe4cd83265eb"><td class="memItemLeft" align="right" valign="top"><a id="af78b58a8a5896dc5d9dfbe4cd83265eb"></a>
PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af78b58a8a5896dc5d9dfbe4cd83265eb">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:af78b58a8a5896dc5d9dfbe4cd83265eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:af78b58a8a5896dc5d9dfbe4cd83265eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf6573afe5f3fb0803faa353dc9c65"><td class="memItemLeft" align="right" valign="top"><a id="aacaf6573afe5f3fb0803faa353dc9c65"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aacaf6573afe5f3fb0803faa353dc9c65">GetRegConstraintSolverConf</a> (const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:aacaf6573afe5f3fb0803faa353dc9c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the regular phase constraint solver configuration for the given step configuration. <br /></td></tr>
<tr class="separator:aacaf6573afe5f3fb0803faa353dc9c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8daa84d36ac948934ee05eb4cb242"><td class="memItemLeft" align="right" valign="top"><a id="afdb8daa84d36ac948934ee05eb4cb242"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afdb8daa84d36ac948934ee05eb4cb242">GetToiConstraintSolverConf</a> (const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:afdb8daa84d36ac948934ee05eb4cb242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the TOI phase constraint solver configuration for the given step configuration. <br /></td></tr>
<tr class="separator:afdb8daa84d36ac948934ee05eb4cb242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5bfe19319bd53279df8e97a75c1aee"><td class="memItemLeft" align="right" valign="top"><a id="a0c5bfe19319bd53279df8e97a75c1aee"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0c5bfe19319bd53279df8e97a75c1aee">GetDefaultPositionSolverConf</a> ()</td></tr>
<tr class="memdesc:a0c5bfe19319bd53279df8e97a75c1aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default position solver configuration. <br /></td></tr>
<tr class="separator:a0c5bfe19319bd53279df8e97a75c1aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ede85de958ca0b1409f86e95843b578"><td class="memItemLeft" align="right" valign="top"><a id="a0ede85de958ca0b1409f86e95843b578"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0ede85de958ca0b1409f86e95843b578">GetDefaultToiPositionSolverConf</a> ()</td></tr>
<tr class="memdesc:a0ede85de958ca0b1409f86e95843b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default TOI position solver configuration. <br /></td></tr>
<tr class="separator:a0ede85de958ca0b1409f86e95843b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48fe223cf379b5534ebf571d5f83164"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af48fe223cf379b5534ebf571d5f83164">operator==</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> lhs, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> rhs) noexcept</td></tr>
<tr class="memdesc:af48fe223cf379b5534ebf571d5f83164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#af48fe223cf379b5534ebf571d5f83164">More...</a><br /></td></tr>
<tr class="separator:af48fe223cf379b5534ebf571d5f83164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab177f652a925ae4e4a236a597dbe6d07"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab177f652a925ae4e4a236a597dbe6d07">operator!=</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> lhs, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> rhs) noexcept</td></tr>
<tr class="memdesc:ab177f652a925ae4e4a236a597dbe6d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#ab177f652a925ae4e4a236a597dbe6d07">More...</a><br /></td></tr>
<tr class="separator:ab177f652a925ae4e4a236a597dbe6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223329721a8138f316898ed9a4877250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a223329721a8138f316898ed9a4877250">ShouldCollide</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> filterA, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> filterB) noexcept</td></tr>
<tr class="memdesc:a223329721a8138f316898ed9a4877250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether collision processing should be performed.  <a href="#a223329721a8138f316898ed9a4877250">More...</a><br /></td></tr>
<tr class="separator:a223329721a8138f316898ed9a4877250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa7929a7c9cfd63177dcf77c3116bf1"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7fa7929a7c9cfd63177dcf77c3116bf1">operator==</a> (const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;lhs, const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7fa7929a7c9cfd63177dcf77c3116bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a7fa7929a7c9cfd63177dcf77c3116bf1">More...</a><br /></td></tr>
<tr class="separator:a7fa7929a7c9cfd63177dcf77c3116bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11952027f7e2cabb36d03c2677219a4a"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a11952027f7e2cabb36d03c2677219a4a">operator!=</a> (const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;lhs, const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a11952027f7e2cabb36d03c2677219a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a11952027f7e2cabb36d03c2677219a4a">More...</a><br /></td></tr>
<tr class="separator:a11952027f7e2cabb36d03c2677219a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5227d01d6f7c75ac2399c3da7b5572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9f5227d01d6f7c75ac2399c3da7b5572">GetMovementConf</a> (const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a9f5227d01d6f7c75ac2399c3da7b5572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the movement configuration from the given value.  <a href="#a9f5227d01d6f7c75ac2399c3da7b5572">More...</a><br /></td></tr>
<tr class="separator:a9f5227d01d6f7c75ac2399c3da7b5572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d21c386ca6d39d5cc35cbad350a8c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a05d21c386ca6d39d5cc35cbad350a8c9">IsMaxTranslationWithinTolerance</a> (const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a05d21c386ca6d39d5cc35cbad350a8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the maximum translation is within tolerance.  <a href="#a05d21c386ca6d39d5cc35cbad350a8c9">More...</a><br /></td></tr>
<tr class="separator:a05d21c386ca6d39d5cc35cbad350a8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f543b42eadf60ef9e730edc77912c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a396f543b42eadf60ef9e730edc77912c">GetMaxRegLinearCorrection</a> (const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a396f543b42eadf60ef9e730edc77912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum regular linear correction from the given value.  <a href="#a396f543b42eadf60ef9e730edc77912c">More...</a><br /></td></tr>
<tr class="separator:a396f543b42eadf60ef9e730edc77912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b942aee8449be45b89aea3b870ad76b"><td class="memItemLeft" align="right" valign="top"><a id="a9b942aee8449be45b89aea3b870ad76b"></a>
<a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9b942aee8449be45b89aea3b870ad76b">Update</a> (<a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a> &amp;lhs, const <a class="el" href="structplayrho_1_1IslandStats.html">IslandStats</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9b942aee8449be45b89aea3b870ad76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the given regular step statistics. <br /></td></tr>
<tr class="separator:a9b942aee8449be45b89aea3b870ad76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9ae0d4494c5f273d7bae9489ea22cf15"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9ae0d4494c5f273d7bae9489ea22cf15">InvalidIndexPair</a></td></tr>
<tr class="memdesc:a9ae0d4494c5f273d7bae9489ea22cf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid index-pair value.  <a href="#a9ae0d4494c5f273d7bae9489ea22cf15">More...</a><br /></td></tr>
<tr class="separator:a9ae0d4494c5f273d7bae9489ea22cf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6ff7b1718107009f0242e8919d96a7"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7a6ff7b1718107009f0242e8919d96a7">InvalidIndexPair3</a></td></tr>
<tr class="memdesc:a7a6ff7b1718107009f0242e8919d96a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid array of three index-pair elements.  <a href="#a7a6ff7b1718107009f0242e8919d96a7">More...</a><br /></td></tr>
<tr class="separator:a7a6ff7b1718107009f0242e8919d96a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8c760ae98e855ef8ba9c976fa732b5"><td class="memItemLeft" align="right" valign="top">static PLAYRHO_CONSTEXPR const std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aea8c760ae98e855ef8ba9c976fa732b5">s_blockSizeLookup</a> [<a class="el" href="classplayrho_1_1BlockAllocator.html#a2845e1a67f12b93c3bd543e72f6655f0">BlockAllocator::GetMaxBlockSize</a>()+1]</td></tr>
<tr class="memdesc:aea8c760ae98e855ef8ba9c976fa732b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size lookup array.  <a href="#aea8c760ae98e855ef8ba9c976fa732b5">More...</a><br /></td></tr>
<tr class="separator:aea8c760ae98e855ef8ba9c976fa732b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14624c80f5b2f01b49d878764aa55af0"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a14624c80f5b2f01b49d878764aa55af0">AllocatorBlockSizes</a> []</td></tr>
<tr class="memdesc:a14624c80f5b2f01b49d878764aa55af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator block sizes array data.  <a href="#a14624c80f5b2f01b49d878764aa55af0">More...</a><br /></td></tr>
<tr class="separator:a14624c80f5b2f01b49d878764aa55af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2e155484aefe7098ddf4248bff8ca"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(3.14159265358979323846264338327950288)</td></tr>
<tr class="memdesc:a83e2e155484aefe7098ddf4248bff8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi.  <a href="#a83e2e155484aefe7098ddf4248bff8ca">More...</a><br /></td></tr>
<tr class="separator:a83e2e155484aefe7098ddf4248bff8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4398b65ad858db7f77516a968f8443ce"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4398b65ad858db7f77516a968f8443ce">SquareRootTwo</a></td></tr>
<tr class="memdesc:a4398b65ad858db7f77516a968f8443ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of two.  <a href="#a4398b65ad858db7f77516a968f8443ce">More...</a><br /></td></tr>
<tr class="separator:a4398b65ad858db7f77516a968f8443ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387ed5b46cb1013ff38c0b32d98f2771"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga387ed5b46cb1013ff38c0b32d98f2771">Centi</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e-2)</td></tr>
<tr class="memdesc:ga387ed5b46cb1013ff38c0b32d98f2771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centi- (1 x 10^-2).  <a href="group__DecimalUnitPrefices.html#ga387ed5b46cb1013ff38c0b32d98f2771">More...</a><br /></td></tr>
<tr class="separator:ga387ed5b46cb1013ff38c0b32d98f2771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac718685329c6b54f97b4be173133b3d3"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gac718685329c6b54f97b4be173133b3d3">Deci</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e-1)</td></tr>
<tr class="memdesc:gac718685329c6b54f97b4be173133b3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deci- (1 x 10^-1).  <a href="group__DecimalUnitPrefices.html#gac718685329c6b54f97b4be173133b3d3">More...</a><br /></td></tr>
<tr class="separator:gac718685329c6b54f97b4be173133b3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8072171d5c45141876d15d6b3d8eaca0"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga8072171d5c45141876d15d6b3d8eaca0">Kilo</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e3)</td></tr>
<tr class="memdesc:ga8072171d5c45141876d15d6b3d8eaca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilo- (1 x 10^3).  <a href="group__DecimalUnitPrefices.html#ga8072171d5c45141876d15d6b3d8eaca0">More...</a><br /></td></tr>
<tr class="separator:ga8072171d5c45141876d15d6b3d8eaca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272d0509b477a6badd7f175e9598ce8b"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga272d0509b477a6badd7f175e9598ce8b">Giga</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e9)</td></tr>
<tr class="memdesc:ga272d0509b477a6badd7f175e9598ce8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Giga- (1 x 10^9).  <a href="group__DecimalUnitPrefices.html#ga272d0509b477a6badd7f175e9598ce8b">More...</a><br /></td></tr>
<tr class="separator:ga272d0509b477a6badd7f175e9598ce8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120ec462977c3a766b0c069a4706ffd9"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga120ec462977c3a766b0c069a4706ffd9">Yotta</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e24)</td></tr>
<tr class="memdesc:ga120ec462977c3a766b0c069a4706ffd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yotta- (1 x 10^24).  <a href="group__DecimalUnitPrefices.html#ga120ec462977c3a766b0c069a4706ffd9">More...</a><br /></td></tr>
<tr class="separator:ga120ec462977c3a766b0c069a4706ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31cf01d14137889e66fad67223e8e6f"><td class="memItemLeft" align="right" valign="top"><a id="af31cf01d14137889e66fad67223e8e6f"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af31cf01d14137889e66fad67223e8e6f">MaxSimplexEdges</a> = std::uint8_t{3}</td></tr>
<tr class="memdesc:af31cf01d14137889e66fad67223e8e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of supportable edges in a simplex. <br /></td></tr>
<tr class="separator:af31cf01d14137889e66fad67223e8e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2b91f99d7c6b008048a242cc291d6a"><td class="memItemLeft" align="right" valign="top"><a id="a1b2b91f99d7c6b008048a242cc291d6a"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1b2b91f99d7c6b008048a242cc291d6a">MaxChildCount</a> = std::numeric_limits&lt;std::uint32_t&gt;::max() &gt;&gt; 6</td></tr>
<tr class="memdesc:a1b2b91f99d7c6b008048a242cc291d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max child count. <br /></td></tr>
<tr class="separator:a1b2b91f99d7c6b008048a242cc291d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cee4bebe0e1b82beed42c1f2907fd58"><td class="memItemLeft" align="right" valign="top"><a id="a1cee4bebe0e1b82beed42c1f2907fd58"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1cee4bebe0e1b82beed42c1f2907fd58">MaxFloat</a> = std::numeric_limits&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::max()</td></tr>
<tr class="memdesc:a1cee4bebe0e1b82beed42c1f2907fd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum float value. <br /></td></tr>
<tr class="separator:a1cee4bebe0e1b82beed42c1f2907fd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56978175f768dd093094931064fed774"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a56978175f768dd093094931064fed774">MaxManifoldPoints</a> = std::uint8_t{2}</td></tr>
<tr class="memdesc:a56978175f768dd093094931064fed774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum manifold points. This is the maximum number of contact points between two convex shapes. Do not change this value.  <a href="#a56978175f768dd093094931064fed774">More...</a><br /></td></tr>
<tr class="separator:a56978175f768dd093094931064fed774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43acb3229848771f11e519430b91725"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac43acb3229848771f11e519430b91725">MaxShapeVertices</a> = std::uint8_t{254}</td></tr>
<tr class="memdesc:ac43acb3229848771f11e519430b91725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of vertices for any shape type.  <a href="#ac43acb3229848771f11e519430b91725">More...</a><br /></td></tr>
<tr class="separator:ac43acb3229848771f11e519430b91725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13e92f7c6118e3ac33ea8f769dd51a3"><td class="memItemLeft" align="right" valign="top"><a id="ab13e92f7c6118e3ac33ea8f769dd51a3"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab13e92f7c6118e3ac33ea8f769dd51a3">InvalidVertex</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&gt;(-1)</td></tr>
<tr class="memdesc:ab13e92f7c6118e3ac33ea8f769dd51a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid vertex index. <br /></td></tr>
<tr class="separator:ab13e92f7c6118e3ac33ea8f769dd51a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d420c3642290da261ff169a973b070f"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3d420c3642290da261ff169a973b070f">DefaultLinearSlop</a> = <a class="el" href="structplayrho_1_1detail_1_1Defaults.html">detail::Defaults</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::GetLinearSlop()</td></tr>
<tr class="memdesc:a3d420c3642290da261ff169a973b070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default linear slop.  <a href="#a3d420c3642290da261ff169a973b070f">More...</a><br /></td></tr>
<tr class="separator:a3d420c3642290da261ff169a973b070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec427cf56f7c89aa54721551439f4aa"><td class="memItemLeft" align="right" valign="top"><a id="a4ec427cf56f7c89aa54721551439f4aa"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4ec427cf56f7c89aa54721551439f4aa">DefaultMinVertexRadius</a> = <a class="el" href="namespaceplayrho.html#a3d420c3642290da261ff169a973b070f">DefaultLinearSlop</a> * <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{2}</td></tr>
<tr class="memdesc:a4ec427cf56f7c89aa54721551439f4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default minimum vertex radius. <br /></td></tr>
<tr class="separator:a4ec427cf56f7c89aa54721551439f4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d3c2fbc49a410aaa875a4e42e37cb8"><td class="memItemLeft" align="right" valign="top"><a id="a36d3c2fbc49a410aaa875a4e42e37cb8"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a36d3c2fbc49a410aaa875a4e42e37cb8">DefaultMaxVertexRadius</a> = <a class="el" href="structplayrho_1_1detail_1_1Defaults.html">detail::Defaults</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::GetMaxVertexRadius()</td></tr>
<tr class="memdesc:a36d3c2fbc49a410aaa875a4e42e37cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum vertex radius. <br /></td></tr>
<tr class="separator:a36d3c2fbc49a410aaa875a4e42e37cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f7efd19057d7a44d9d997f7e78b7b4"><td class="memItemLeft" align="right" valign="top"><a id="a17f7efd19057d7a44d9d997f7e78b7b4"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a17f7efd19057d7a44d9d997f7e78b7b4">DefaultAabbExtension</a> = <a class="el" href="namespaceplayrho.html#a3d420c3642290da261ff169a973b070f">DefaultLinearSlop</a> * <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{20}</td></tr>
<tr class="memdesc:a17f7efd19057d7a44d9d997f7e78b7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default AABB extension amount. <br /></td></tr>
<tr class="separator:a17f7efd19057d7a44d9d997f7e78b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96b68f65909222ce41acdfe0435b309"><td class="memItemLeft" align="right" valign="top"><a id="af96b68f65909222ce41acdfe0435b309"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af96b68f65909222ce41acdfe0435b309">DefaultDistanceMultiplier</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{2}</td></tr>
<tr class="memdesc:af96b68f65909222ce41acdfe0435b309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default distance multiplier. <br /></td></tr>
<tr class="separator:af96b68f65909222ce41acdfe0435b309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeec74885c6139f6d3589df0961b465"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afdeec74885c6139f6d3589df0961b465">DefaultAngularSlop</a> = (<a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * 2_rad) / Real{180}</td></tr>
<tr class="memdesc:afdeec74885c6139f6d3589df0961b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default angular slop.  <a href="#afdeec74885c6139f6d3589df0961b465">More...</a><br /></td></tr>
<tr class="separator:afdeec74885c6139f6d3589df0961b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06c35910bfd4af96dab8900b3bbd068"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af06c35910bfd4af96dab8900b3bbd068">DefaultMaxLinearCorrection</a> = 0.2_m</td></tr>
<tr class="memdesc:af06c35910bfd4af96dab8900b3bbd068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum linear correction.  <a href="#af06c35910bfd4af96dab8900b3bbd068">More...</a><br /></td></tr>
<tr class="separator:af06c35910bfd4af96dab8900b3bbd068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c72ad15b5cc7420967f448df82f9392"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8c72ad15b5cc7420967f448df82f9392">DefaultMaxAngularCorrection</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(8.0f / 180.0f) * Pi * 1_rad</td></tr>
<tr class="memdesc:a8c72ad15b5cc7420967f448df82f9392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum angular correction.  <a href="#a8c72ad15b5cc7420967f448df82f9392">More...</a><br /></td></tr>
<tr class="separator:a8c72ad15b5cc7420967f448df82f9392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573b553689b1621f6447af5f9c36ff1d"><td class="memItemLeft" align="right" valign="top"><a id="a573b553689b1621f6447af5f9c36ff1d"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a573b553689b1621f6447af5f9c36ff1d">DefaultMaxTranslation</a> = 2_m</td></tr>
<tr class="memdesc:a573b553689b1621f6447af5f9c36ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum translation amount. <br /></td></tr>
<tr class="separator:a573b553689b1621f6447af5f9c36ff1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b41af1b8c909a70f0212ce87a7a5dc"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a57b41af1b8c909a70f0212ce87a7a5dc">DefaultMaxRotation</a> = <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{<a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * 1_rad / Real(2)}</td></tr>
<tr class="memdesc:a57b41af1b8c909a70f0212ce87a7a5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum rotation per world step.  <a href="#a57b41af1b8c909a70f0212ce87a7a5dc">More...</a><br /></td></tr>
<tr class="separator:a57b41af1b8c909a70f0212ce87a7a5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f8112a0da9ce8858c867f89a921161"><td class="memItemLeft" align="right" valign="top"><a id="a96f8112a0da9ce8858c867f89a921161"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a96f8112a0da9ce8858c867f89a921161">DefaultMaxToiIters</a> = std::uint8_t{20}</td></tr>
<tr class="memdesc:a96f8112a0da9ce8858c867f89a921161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum time of impact iterations. <br /></td></tr>
<tr class="separator:a96f8112a0da9ce8858c867f89a921161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35523dfe363049d006435f16d1d9a3a6"><td class="memItemLeft" align="right" valign="top"><a id="a35523dfe363049d006435f16d1d9a3a6"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a35523dfe363049d006435f16d1d9a3a6">DefaultMaxToiRootIters</a> = std::uint8_t{30}</td></tr>
<tr class="memdesc:a35523dfe363049d006435f16d1d9a3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum time of impact root iterator count. <br /></td></tr>
<tr class="separator:a35523dfe363049d006435f16d1d9a3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac187d8e96ae483472c383b59726010"><td class="memItemLeft" align="right" valign="top"><a id="a9ac187d8e96ae483472c383b59726010"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9ac187d8e96ae483472c383b59726010">DefaultMaxDistanceIters</a> = std::uint8_t{20}</td></tr>
<tr class="memdesc:a9ac187d8e96ae483472c383b59726010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default max number of distance iterations. <br /></td></tr>
<tr class="separator:a9ac187d8e96ae483472c383b59726010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372f74648b7c4e8b586f6fd84b9cc232"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a372f74648b7c4e8b586f6fd84b9cc232">DefaultMaxSubSteps</a> = std::uint8_t{8}</td></tr>
<tr class="memdesc:a372f74648b7c4e8b586f6fd84b9cc232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum number of sub steps.  <a href="#a372f74648b7c4e8b586f6fd84b9cc232">More...</a><br /></td></tr>
<tr class="separator:a372f74648b7c4e8b586f6fd84b9cc232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97ff0dfa01d57e663d59d7574bb6fad"><td class="memItemLeft" align="right" valign="top"><a id="ae97ff0dfa01d57e663d59d7574bb6fad"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae97ff0dfa01d57e663d59d7574bb6fad">DefaultVelocityThreshold</a> = 1_mps</td></tr>
<tr class="memdesc:ae97ff0dfa01d57e663d59d7574bb6fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default velocity threshold. <br /></td></tr>
<tr class="separator:ae97ff0dfa01d57e663d59d7574bb6fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad481cccc03a01eeabc32c45d1c89cd7d"><td class="memItemLeft" align="right" valign="top"><a id="ad481cccc03a01eeabc32c45d1c89cd7d"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad481cccc03a01eeabc32c45d1c89cd7d">DefaultRegMinMomentum</a> = <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>{0_Ns / 100}</td></tr>
<tr class="memdesc:ad481cccc03a01eeabc32c45d1c89cd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default regular-phase minimum momentum. <br /></td></tr>
<tr class="separator:ad481cccc03a01eeabc32c45d1c89cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ff379667f9a3daa3f7bd4bf4ff1d1e"><td class="memItemLeft" align="right" valign="top"><a id="a39ff379667f9a3daa3f7bd4bf4ff1d1e"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a39ff379667f9a3daa3f7bd4bf4ff1d1e">DefaultToiMinMomentum</a> = <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>{0_Ns / 100}</td></tr>
<tr class="memdesc:a39ff379667f9a3daa3f7bd4bf4ff1d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TOI-phase minimum momentum. <br /></td></tr>
<tr class="separator:a39ff379667f9a3daa3f7bd4bf4ff1d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8a3bed4ddbbfdbaf170055a932dfed"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a></td></tr>
<tr class="memdesc:a7e8a3bed4ddbbfdbaf170055a932dfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bodies in a world.  <a href="#a7e8a3bed4ddbbfdbaf170055a932dfed">More...</a><br /></td></tr>
<tr class="separator:a7e8a3bed4ddbbfdbaf170055a932dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21662261fc1db26e8f50313731c1f0d3"><td class="memItemLeft" align="right" valign="top"><a id="a21662261fc1db26e8f50313731c1f0d3"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a21662261fc1db26e8f50313731c1f0d3">InvalidContactIndex</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>&gt;(-1)</td></tr>
<tr class="memdesc:a21662261fc1db26e8f50313731c1f0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid contact index. <br /></td></tr>
<tr class="separator:a21662261fc1db26e8f50313731c1f0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033fed46214035a6a09bc21400d1c61c"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a033fed46214035a6a09bc21400d1c61c">MaxContacts</a> = <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a>} * <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a> - 1} / <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{2}</td></tr>
<tr class="memdesc:a033fed46214035a6a09bc21400d1c61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of contacts in a world (2147319811).  <a href="#a033fed46214035a6a09bc21400d1c61c">More...</a><br /></td></tr>
<tr class="separator:a033fed46214035a6a09bc21400d1c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea7793500223bfe5600812095e41a72"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4ea7793500223bfe5600812095e41a72">MaxJoints</a></td></tr>
<tr class="memdesc:a4ea7793500223bfe5600812095e41a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of joints in a world.  <a href="#a4ea7793500223bfe5600812095e41a72">More...</a><br /></td></tr>
<tr class="separator:a4ea7793500223bfe5600812095e41a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bcd99b27e0ecf060b210d58fb1458f"><td class="memItemLeft" align="right" valign="top"><a id="a15bcd99b27e0ecf060b210d58fb1458f"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a15bcd99b27e0ecf060b210d58fb1458f">DefaultStepTime</a> = <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>{1_s / 60}</td></tr>
<tr class="memdesc:a15bcd99b27e0ecf060b210d58fb1458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step time. <br /></td></tr>
<tr class="separator:a15bcd99b27e0ecf060b210d58fb1458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739262106482e83c2deffac436a26c9d"><td class="memItemLeft" align="right" valign="top"><a id="a739262106482e83c2deffac436a26c9d"></a>
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a739262106482e83c2deffac436a26c9d">DefaultStepFrequency</a> = 60_Hz</td></tr>
<tr class="memdesc:a739262106482e83c2deffac436a26c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step frequency. <br /></td></tr>
<tr class="separator:a739262106482e83c2deffac436a26c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d3598cecf216d489aa0a62f0f1651d"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a21d3598cecf216d489aa0a62f0f1651d">DefaultMinStillTimeToSleep</a> = <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>{1_s / 2}</td></tr>
<tr class="memdesc:a21d3598cecf216d489aa0a62f0f1651d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default minimum still time to sleep.  <a href="#a21d3598cecf216d489aa0a62f0f1651d">More...</a><br /></td></tr>
<tr class="separator:a21d3598cecf216d489aa0a62f0f1651d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df889ebb1bb1244d02eb379c9ba6e41"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3df889ebb1bb1244d02eb379c9ba6e41">DefaultLinearSleepTolerance</a> = 0.01_mps</td></tr>
<tr class="memdesc:a3df889ebb1bb1244d02eb379c9ba6e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default linear sleep tolerance.  <a href="#a3df889ebb1bb1244d02eb379c9ba6e41">More...</a><br /></td></tr>
<tr class="separator:a3df889ebb1bb1244d02eb379c9ba6e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e86e9585daf0c5ae48263653f206c56"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5e86e9585daf0c5ae48263653f206c56">DefaultAngularSleepTolerance</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{(<a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * 2) / 180} * <a class="el" href="group__PhysicalUnits.html#ga100ccbd2bb9a367b985c771244bfd06d">RadianPerSecond</a></td></tr>
<tr class="memdesc:a5e86e9585daf0c5ae48263653f206c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default angular sleep tolerance.  <a href="#a5e86e9585daf0c5ae48263653f206c56">More...</a><br /></td></tr>
<tr class="separator:a5e86e9585daf0c5ae48263653f206c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5625850696940f96094a3da078187d63"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5625850696940f96094a3da078187d63">DefaultCirclesRatio</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{10}</td></tr>
<tr class="memdesc:a5625850696940f96094a3da078187d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default circles ratio.  <a href="#a5625850696940f96094a3da078187d63">More...</a><br /></td></tr>
<tr class="separator:a5625850696940f96094a3da078187d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ac917bbbd4ffab2322fb6f4f8d27c3"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>, boost::units::si::second)</td></tr>
<tr class="memdesc:ga52ac917bbbd4ffab2322fb6f4f8d27c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second unit of time.  <a href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">More...</a><br /></td></tr>
<tr class="separator:ga52ac917bbbd4ffab2322fb6f4f8d27c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93dd94a3639070fce0e3fcd9657524da"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga93dd94a3639070fce0e3fcd9657524da">SquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a></td></tr>
<tr class="memdesc:ga93dd94a3639070fce0e3fcd9657524da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square second unit.  <a href="group__PhysicalUnits.html#ga93dd94a3639070fce0e3fcd9657524da">More...</a><br /></td></tr>
<tr class="separator:ga93dd94a3639070fce0e3fcd9657524da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37ce31a2cc62baade6c44bd04b08543"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gae37ce31a2cc62baade6c44bd04b08543">Hertz</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a>, boost::units::si::hertz)</td></tr>
<tr class="memdesc:gae37ce31a2cc62baade6c44bd04b08543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hertz unit of Frequency.  <a href="group__PhysicalUnits.html#gae37ce31a2cc62baade6c44bd04b08543">More...</a><br /></td></tr>
<tr class="separator:gae37ce31a2cc62baade6c44bd04b08543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0ff7b721060132468649c9afb07c37"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga2f0ff7b721060132468649c9afb07c37">Meter</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>, boost::units::si::meter)</td></tr>
<tr class="memdesc:ga2f0ff7b721060132468649c9afb07c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter unit of Length.  <a href="group__PhysicalUnits.html#ga2f0ff7b721060132468649c9afb07c37">More...</a><br /></td></tr>
<tr class="separator:ga2f0ff7b721060132468649c9afb07c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fbed41867777a30fc3e3dda5cac700"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga46fbed41867777a30fc3e3dda5cac700">MeterPerSecond</a></td></tr>
<tr class="memdesc:ga46fbed41867777a30fc3e3dda5cac700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter per second unit of linear velocity.  <a href="group__PhysicalUnits.html#ga46fbed41867777a30fc3e3dda5cac700">More...</a><br /></td></tr>
<tr class="separator:ga46fbed41867777a30fc3e3dda5cac700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d200ec14214ce97214a95ec2f83c626"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga6d200ec14214ce97214a95ec2f83c626">MeterPerSquareSecond</a></td></tr>
<tr class="memdesc:ga6d200ec14214ce97214a95ec2f83c626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter per square second unit of linear acceleration.  <a href="group__PhysicalUnits.html#ga6d200ec14214ce97214a95ec2f83c626">More...</a><br /></td></tr>
<tr class="separator:ga6d200ec14214ce97214a95ec2f83c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46997d28d69677820f127d640f529ccc"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga46997d28d69677820f127d640f529ccc">Kilogram</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>, boost::units::si::kilogram)</td></tr>
<tr class="memdesc:ga46997d28d69677820f127d640f529ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilogram unit of mass.  <a href="group__PhysicalUnits.html#ga46997d28d69677820f127d640f529ccc">More...</a><br /></td></tr>
<tr class="separator:ga46997d28d69677820f127d640f529ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df6e111fd792c1a81dd8c7ff5a06148"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga8df6e111fd792c1a81dd8c7ff5a06148">SquareMeter</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a>, boost::units::si::square_meter)</td></tr>
<tr class="memdesc:ga8df6e111fd792c1a81dd8c7ff5a06148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square meter unit of area.  <a href="group__PhysicalUnits.html#ga8df6e111fd792c1a81dd8c7ff5a06148">More...</a><br /></td></tr>
<tr class="separator:ga8df6e111fd792c1a81dd8c7ff5a06148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8521b8635553bd6e022847e790aad0"><td class="memItemLeft" align="right" valign="top">
PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaba8521b8635553bd6e022847e790aad0">CubicMeter</a> = <a class="el" href="group__PhysicalUnits.html#ga2f0ff7b721060132468649c9afb07c37">Meter</a> * <a class="el" href="group__PhysicalUnits.html#ga2f0ff7b721060132468649c9afb07c37">Meter</a> * <a class="el" href="group__PhysicalUnits.html#ga2f0ff7b721060132468649c9afb07c37">Meter</a></td></tr>
<tr class="memdesc:gaba8521b8635553bd6e022847e790aad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic meter unit of volume. <br /></td></tr>
<tr class="separator:gaba8521b8635553bd6e022847e790aad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac211a055905dac0385f6b4b243695441"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gac211a055905dac0385f6b4b243695441">KilogramPerSquareMeter</a></td></tr>
<tr class="memdesc:gac211a055905dac0385f6b4b243695441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilogram per square meter unit of area density.  <a href="group__PhysicalUnits.html#gac211a055905dac0385f6b4b243695441">More...</a><br /></td></tr>
<tr class="separator:gac211a055905dac0385f6b4b243695441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5503e9d7955fa22a9d01e39f14108354"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>, boost::units::si::radian)</td></tr>
<tr class="memdesc:ga5503e9d7955fa22a9d01e39f14108354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian unit of angle.  <a href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">More...</a><br /></td></tr>
<tr class="separator:ga5503e9d7955fa22a9d01e39f14108354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6669d827e3af130893c46f8b68c3256"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gac6669d827e3af130893c46f8b68c3256">Degree</a> = <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{<a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a> * <a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{180}}</td></tr>
<tr class="memdesc:gac6669d827e3af130893c46f8b68c3256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree unit of angle quantity.  <a href="group__PhysicalUnits.html#gac6669d827e3af130893c46f8b68c3256">More...</a><br /></td></tr>
<tr class="separator:gac6669d827e3af130893c46f8b68c3256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba3c017800d0389a495a5ef783dac35"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gadba3c017800d0389a495a5ef783dac35">SquareRadian</a> = <a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a> * <a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a></td></tr>
<tr class="memdesc:gadba3c017800d0389a495a5ef783dac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square radian unit type.  <a href="group__PhysicalUnits.html#gadba3c017800d0389a495a5ef783dac35">More...</a><br /></td></tr>
<tr class="separator:gadba3c017800d0389a495a5ef783dac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100ccbd2bb9a367b985c771244bfd06d"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga100ccbd2bb9a367b985c771244bfd06d">RadianPerSecond</a></td></tr>
<tr class="memdesc:ga100ccbd2bb9a367b985c771244bfd06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian per second unit of angular velocity.  <a href="group__PhysicalUnits.html#ga100ccbd2bb9a367b985c771244bfd06d">More...</a><br /></td></tr>
<tr class="separator:ga100ccbd2bb9a367b985c771244bfd06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecdcb8e17745b805b88c63c21323eb6"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga5ecdcb8e17745b805b88c63c21323eb6">DegreePerSecond</a> = <a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>{<a class="el" href="group__PhysicalUnits.html#ga100ccbd2bb9a367b985c771244bfd06d">RadianPerSecond</a> * <a class="el" href="group__PhysicalUnits.html#gac6669d827e3af130893c46f8b68c3256">Degree</a> / <a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a>}</td></tr>
<tr class="memdesc:ga5ecdcb8e17745b805b88c63c21323eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree per second unit of angular velocity.  <a href="group__PhysicalUnits.html#ga5ecdcb8e17745b805b88c63c21323eb6">More...</a><br /></td></tr>
<tr class="separator:ga5ecdcb8e17745b805b88c63c21323eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea803bc1b5ab2d6a9959f4d4edc06a8b"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaea803bc1b5ab2d6a9959f4d4edc06a8b">RadianPerSquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a> / (<a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a>)</td></tr>
<tr class="memdesc:gaea803bc1b5ab2d6a9959f4d4edc06a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian per square second unit of angular acceleration.  <a href="group__PhysicalUnits.html#gaea803bc1b5ab2d6a9959f4d4edc06a8b">More...</a><br /></td></tr>
<tr class="separator:gaea803bc1b5ab2d6a9959f4d4edc06a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c7220de367fc0c06ded92c49ed1ccc"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga22c7220de367fc0c06ded92c49ed1ccc">DegreePerSquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#gac6669d827e3af130893c46f8b68c3256">Degree</a> / (<a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a>)</td></tr>
<tr class="memdesc:ga22c7220de367fc0c06ded92c49ed1ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree per square second unit of angular acceleration.  <a href="group__PhysicalUnits.html#ga22c7220de367fc0c06ded92c49ed1ccc">More...</a><br /></td></tr>
<tr class="separator:ga22c7220de367fc0c06ded92c49ed1ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf83413429e6771da6657a46ad815077f"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaf83413429e6771da6657a46ad815077f">Newton</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>, boost::units::si::newton)</td></tr>
<tr class="memdesc:gaf83413429e6771da6657a46ad815077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton unit of force.  <a href="group__PhysicalUnits.html#gaf83413429e6771da6657a46ad815077f">More...</a><br /></td></tr>
<tr class="separator:gaf83413429e6771da6657a46ad815077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c85a96cbeb317e90145a5a81ad879b"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga23c85a96cbeb317e90145a5a81ad879b">NewtonMeter</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a>, boost::units::si::newton_meter)</td></tr>
<tr class="memdesc:ga23c85a96cbeb317e90145a5a81ad879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton meter unit of torque.  <a href="group__PhysicalUnits.html#ga23c85a96cbeb317e90145a5a81ad879b">More...</a><br /></td></tr>
<tr class="separator:ga23c85a96cbeb317e90145a5a81ad879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21afa37545fc698d3ac72f7fbc87da8c"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga21afa37545fc698d3ac72f7fbc87da8c">NewtonSecond</a> = <a class="el" href="group__PhysicalUnits.html#gaf83413429e6771da6657a46ad815077f">Newton</a> * <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a></td></tr>
<tr class="memdesc:ga21afa37545fc698d3ac72f7fbc87da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton second unit of momentum.  <a href="group__PhysicalUnits.html#ga21afa37545fc698d3ac72f7fbc87da8c">More...</a><br /></td></tr>
<tr class="separator:ga21afa37545fc698d3ac72f7fbc87da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afb7605a074f251328303ecd73e4fd7"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0afb7605a074f251328303ecd73e4fd7">NewtonMeterSecond</a> = <a class="el" href="group__PhysicalUnits.html#ga23c85a96cbeb317e90145a5a81ad879b">NewtonMeter</a> * <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a></td></tr>
<tr class="memdesc:ga0afb7605a074f251328303ecd73e4fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton meter second unit of angular momentum.  <a href="group__PhysicalUnits.html#ga0afb7605a074f251328303ecd73e4fd7">More...</a><br /></td></tr>
<tr class="separator:ga0afb7605a074f251328303ecd73e4fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9963c8e2c625074e8301156943933d1"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaf9963c8e2c625074e8301156943933d1">RevolutionsPerMinute</a> = 2 * <a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * <a class="el" href="group__PhysicalUnits.html#ga5503e9d7955fa22a9d01e39f14108354">Radian</a> / (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{60} * <a class="el" href="group__PhysicalUnits.html#ga52ac917bbbd4ffab2322fb6f4f8d27c3">Second</a>)</td></tr>
<tr class="memdesc:gaf9963c8e2c625074e8301156943933d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revolutions per minute units of angular velocity.  <a href="group__PhysicalUnits.html#gaf9963c8e2c625074e8301156943933d1">More...</a><br /></td></tr>
<tr class="separator:gaf9963c8e2c625074e8301156943933d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e00b99f4f6901091091d553e04d3ec6"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UnitConstants.html#ga1e00b99f4f6901091091d553e04d3ec6">EarthlyLinearAcceleration</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{-9.8f} * MeterPerSquareSecond</td></tr>
<tr class="memdesc:ga1e00b99f4f6901091091d553e04d3ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Earthly gravity.  <a href="group__UnitConstants.html#ga1e00b99f4f6901091091d553e04d3ec6">More...</a><br /></td></tr>
<tr class="separator:ga1e00b99f4f6901091091d553e04d3ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404c812df49d0c0eb68a909eea991bf4"><td class="memItemLeft" align="right" valign="top">PLAYRHO_CONSTEXPR const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UnitConstants.html#ga404c812df49d0c0eb68a909eea991bf4">BigG</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{6.67408e-11f} * CubicMeter / (Kilogram * SquareSecond)</td></tr>
<tr class="memdesc:ga404c812df49d0c0eb68a909eea991bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Big "G".  <a href="group__UnitConstants.html#ga404c812df49d0c0eb68a909eea991bf4">More...</a><br /></td></tr>
<tr class="separator:ga404c812df49d0c0eb68a909eea991bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Name space for all PlayRho related names. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a4106d8a0e998a2485196534514527a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4106d8a0e998a2485196534514527a5a">&#9670;&nbsp;</a></span>BodyCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">playrho::BodyCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Body count type. </p>
<dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxBodies</code> value. </dd></dl>

</div>
</div>
<a id="aed352724e203ca09595faf0dc6a76e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed352724e203ca09595faf0dc6a76e5c">&#9670;&nbsp;</a></span>ChildCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">playrho::ChildCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#a1b2b91f99d7c6b008048a242cc291d6a">MaxChildCount</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Child counter type. </p>
<p>Relating to "children" of shape where each child is a convex shape possibly comprising a concave shape. </p><dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxChildCount</code> value. </dd></dl>

</div>
</div>
<a id="a2bf0674233f83e8b83b30db98332e129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf0674233f83e8b83b30db98332e129">&#9670;&nbsp;</a></span>ContactCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">playrho::ContactCounter</a> = typedef <a class="el" href="structplayrho_1_1Wider.html">Wider</a>&lt;<a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contact count type. </p>
<dl class="section note"><dt>Note</dt><dd>This type must be able to contain the squared value of <code>BodyCounter</code>. </dd></dl>

</div>
</div>
<a id="a51e61fee8a0be399ed24773ebc3135f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e61fee8a0be399ed24773ebc3135f8">&#9670;&nbsp;</a></span>Fixed32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">playrho::Fixed32</a> = typedef <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt;std::int32_t,9&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit fixed precision type. </p>
<dl class="section warning"><dt>Warning</dt><dd>The available numeric fidelity of any 32-bit fixed point type is very limited. Using a 32-bit fixed point type for Real should only be considered for simulations where it's been found to work and where the dynamics won't be changing between runs.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Maximum value (with 9 fraction bits) is approximately 4194303.99609375. </dd>
<dd>
Minimum value (with 9 fraction bits) is approximately 0.001953125. </dd></dl>

</div>
</div>
<a id="a2d09dc7b51321c052b071485357ca1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d09dc7b51321c052b071485357ca1f9">&#9670;&nbsp;</a></span>Force2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">playrho::Force2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Force quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional force vector. </dd></dl>

</div>
</div>
<a id="a7d449e0a1528c10ae0f241713fb69b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d449e0a1528c10ae0f241713fb69b40">&#9670;&nbsp;</a></span>IndexPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">playrho::IndexPair</a> = typedef std::pair&lt;<a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>, <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index pair. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is at least 2-bytes large. </dd>
<dd>
Using <code>std::array</code> would make more sense if it weren't for the fact that <code>std::pair</code>, but not <code>std::array</code>, has <code>constexpr</code> equality and inequality operators. </dd></dl>

</div>
</div>
<a id="a704da3b24d9b1f9135e140dcd5420518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704da3b24d9b1f9135e140dcd5420518">&#9670;&nbsp;</a></span>IndexPair3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">playrho::IndexPair3</a> = typedef std::array&lt;<a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>, <a class="el" href="namespaceplayrho.html#af31cf01d14137889e66fad67223e8e6f">MaxSimplexEdges</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of three index-pair elements. </p>
<dl class="section note"><dt>Note</dt><dd>An element having the <code>InvalidIndexPair</code> value, denotes an unused or invalid elements. </dd>
<dd>
This data type is 6-bytes large (on at least one 64-bit platform). </dd></dl>

</div>
</div>
<a id="aeb8ea60dc388d1e92e2e6fa277a32495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8ea60dc388d1e92e2e6fa277a32495">&#9670;&nbsp;</a></span>JointCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#aeb8ea60dc388d1e92e2e6fa277a32495">playrho::JointCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#a4ea7793500223bfe5600812095e41a72">MaxJoints</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joint count type. </p>
<dl class="section note"><dt>Note</dt><dd>This type must be able to contain the <code>MaxJoints</code> value. </dd></dl>

</div>
</div>
<a id="a7dc68cd0ce177e175ae0bb6c39db158d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc68cd0ce177e175ae0bb6c39db158d">&#9670;&nbsp;</a></span>Length2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">playrho::Length2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Length quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional distance or location vector. </dd></dl>

</div>
</div>
<a id="a5822921028100052d4c6dfb43c7f6c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822921028100052d4c6dfb43c7f6c4b">&#9670;&nbsp;</a></span>LinearAcceleration2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">playrho::LinearAcceleration2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of linear acceleration (<code>LinearAcceleration</code>) quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional linear acceleration vector. </dd></dl>

</div>
</div>
<a id="a2faa31bff8794a0c4191d8b042f7deeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faa31bff8794a0c4191d8b042f7deeb">&#9670;&nbsp;</a></span>LinearVelocity2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">playrho::LinearVelocity2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of linear velocity (<code>LinearVelocity</code>) quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional speed vector. </dd></dl>

</div>
</div>
<a id="acbf97bd8e3f0f2ce4588735388f4089a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf97bd8e3f0f2ce4588735388f4089a">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">playrho::Matrix</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, N&gt;, M&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic M by N matrix. </p>
<dl class="section note"><dt>Note</dt><dd>M is the number of rows of the matrix. </dd>
<dd>
N is the number of columns of the matrix. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">https://en.wikipedia.org/wiki/Matrix_(mathematics)</a> </dd>
<dd>
<a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a>, <a class="el" href="group__MatrixTraitsGroup.html" title="Collection of trait classes for matrices. ">Matrix Traits</a>, <a class="el" href="structplayrho_1_1IsVector.html" title="Trait class for checking if type is a Vector type. ">IsVector</a> </dd></dl>

</div>
</div>
<a id="a1fa6ffb2e67c2e2f620eed088412b146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa6ffb2e67c2e2f620eed088412b146">&#9670;&nbsp;</a></span>Momentum2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">playrho::Momentum2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Momentum quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional momentum vector. </dd></dl>

</div>
</div>
<a id="acbc56513bd325732410bc4dbb3261299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc56513bd325732410bc4dbb3261299">&#9670;&nbsp;</a></span>Optional</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#acbc56513bd325732410bc4dbb3261299">playrho::Optional</a> = typedef <a class="el" href="classplayrho_1_1OptionalValue.html">OptionalValue</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional type alias. </p>
<p>An alias setup to facilitate switching between implementations of the optional type idea. </p><dl class="section note"><dt>Note</dt><dd>This is meant to be used directly for optional values. </dd></dl>

</div>
</div>
<a id="ae444a62491fcb2b10f0f06a41b1ac406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae444a62491fcb2b10f0f06a41b1ac406">&#9670;&nbsp;</a></span>PairLength2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">playrho::PairLength2</a> = typedef std::pair&lt;<a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of <code>Length2</code> values. </p>
<dl class="section note"><dt>Note</dt><dd>Uses <code>std::pair</code> because this is a pair and also because <code>std::pair</code> has more support for constant expressions. </dd></dl>

</div>
</div>
<a id="a1fc125070a08100d083a1360f7167f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc125070a08100d083a1360f7167f87">&#9670;&nbsp;</a></span>Real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">playrho::Real</a> = typedef float</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-number type. </p>
<p>This is the number type underlying numerical calculations conceptually involving real-numbers. Ideally the implementation of this type doesn't suffer from things like: catastrophic cancellation, catastrophic division, overflows, nor underflows.</p>
<dl class="section note"><dt>Note</dt><dd>This can be implemented using any of the fundamental floating point types ( <code>float</code>, <code>double</code>, or <code>long double</code>). </dd>
<dd>
This can also be implemented using a <code>LiteralType</code> that has the necessary support: all common mathematical functions, support for infinity and NaN, and a specialization of the <code>std::numeric_limits</code> class template for it. </dd>
<dd>
At present, the <code>Fixed32</code> and <code>Fixed64</code> aliases of the <code><a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers. ">Fixed</a></code> template type are provided as examples of qualifying literal types though the usability of these are limited and their use is discouraged.</dd>
<dd>
Regarding division:<ul>
<li>While dividing 1 by a real, caching the result, and then doing multiplications with the result may well be faster (than repeatedly dividing), dividing 1 by the real can also result in an underflow situation that's then compounded every time it's multiplied with other values.</li>
<li>Meanwhile, dividing every time by a real isolates any underflows to the particular division where underflow occurs.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Using <code>Fixed32</code> is not advised as its numerical limitations are more likely to result in problems like overflows or underflows. </dd>
<dd>
The note regarding division applies even more so when using a fixed-point type (for <code>Real</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/language/types">http://en.cppreference.com/w/cpp/language/types</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/types/is_floating_point">http://en.cppreference.com/w/cpp/types/is_floating_point</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/concept/LiteralType">http://en.cppreference.com/w/cpp/concept/LiteralType</a> </dd></dl>

</div>
</div>
<a id="a3898807006fd29cd5c4fc2e1a9cf5536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898807006fd29cd5c4fc2e1a9cf5536">&#9670;&nbsp;</a></span>TimestepIters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">playrho::TimestepIters</a> = typedef std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time step iterations type. </p>
<p>A type for counting iterations per time-step. </p>

</div>
</div>
<a id="a592a9fb888eae63605b73b61c61ccd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592a9fb888eae63605b73b61c61ccd17">&#9670;&nbsp;</a></span>TupleContainsType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a592a9fb888eae63605b73b61c61ccd17">playrho::TupleContainsType</a> = typedef typename <a class="el" href="structplayrho_1_1HasType.html">HasType</a>&lt;T, Tuple&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tuple contains type alias. </p>
<p>Alias in case the trait itself should be <code>std::true_type</code> or <code>std::false_type</code>. </p><dl class="section note"><dt>Note</dt><dd>This is from Piotr Skotnicki's answer on the <em>StackOverflow</em> website to the question of: "How do I find out if a tuple contains a type?". </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/a/25958302/7410358">https://stackoverflow.com/a/25958302/7410358</a> </dd></dl>

</div>
</div>
<a id="ad93c0cd83df090aba6593ffac4b628ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93c0cd83df090aba6593ffac4b628ec">&#9670;&nbsp;</a></span>Vec2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">playrho::Vec2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> with 2 Real elements. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is two-times the size of the <code>Real</code> type (or 8 using Real of float). </dd></dl>

</div>
</div>
<a id="a63f6dcdf3763052ea25099973c7c00ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f6dcdf3763052ea25099973c7c00ad">&#9670;&nbsp;</a></span>Vec3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">playrho::Vec3</a> = typedef <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3-dimensional column vector with 3 elements. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is 3 times the size of <code>Real</code> - i.e. 12-bytes (with 4-byte Real). </dd></dl>

</div>
</div>
<a id="a97243f194a9406d0fdcf5f6f833851ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97243f194a9406d0fdcf5f6f833851ab">&#9670;&nbsp;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">playrho::Vector2</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> with 2-elements. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a C++11 alias template for 2-element uses of the <a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> template. </dd></dl>

</div>
</div>
<a id="ad07b44f811ac4c7551067fb1d3554ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07b44f811ac4c7551067fb1d3554ec5">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">playrho::Vector3</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> with 3-elements. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a C++11 alias template for 3-element uses of the <a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> template. </dd></dl>

</div>
</div>
<a id="a16da705f1b3c51c7fd1b9b1162c258b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16da705f1b3c51c7fd1b9b1162c258b9">&#9670;&nbsp;</a></span>VertexCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">playrho::VertexCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#ac43acb3229848771f11e519430b91725">MaxShapeVertices</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex count type. </p>
<dl class="section note"><dt>Note</dt><dd>This type must not support more than 255 vertices as that would conflict with the <code><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041" title="Index type. ">ContactFeature::Index</a></code> type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a098b0ef528e3b728af8e3e17873963f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098b0ef528e3b728af8e3e17873963f7">&#9670;&nbsp;</a></span>BodyType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">playrho::BodyType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Body Type. </p>
<dl class="section note"><dt>Note</dt><dd>static: zero mass, zero velocity, may be manually moved </dd>
<dd>
kinematic: zero mass, non-zero velocity set by user, moved by solver </dd>
<dd>
dynamic: positive mass, non-zero velocity determined by forces, moved by solver </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a84a8921b25f505d0d2077aeb5db4bc16"></a>Static&#160;</td><td class="fielddoc"><p>Static body type. </p>
<p>Static bodies have no mass, have no forces applied to them, and aren't moved by physical processes. They are impenetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: none. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a40c78b58b86002ee38fad2d3c9dd787e"></a>Kinematic&#160;</td><td class="fielddoc"><p>Kinematic body type. </p>
<p>Kinematic bodies have no mass and have no forces applied to them, but can move at set velocities. They are impenetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: velocity. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a971fd8cc345d8bd9f92e9f7d88fdf20c"></a>Dynamic&#160;</td><td class="fielddoc"><p>Dynamic body type. </p>
<p>Dynamic bodies are fully simulated bodies. Dynamic bodies always have a positive non-zero mass. They may be penetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: velocity, acceleration. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a06f67e158a928ef59e4263facac8fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f67e158a928ef59e4263facac8fb0b">&#9670;&nbsp;</a></span>PointState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">playrho::PointState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point state enumeration. </p>
<dl class="section note"><dt>Note</dt><dd>This is used for determining the state of contact points. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba5ac8cf2fb7a90ff2d0829f5fca4db5b8"></a>NullState&#160;</td><td class="fielddoc"><p>point does not exist </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba494a3e62657370358107e2edf3fca5a0"></a>AddState&#160;</td><td class="fielddoc"><p>point was added in the update </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba60a7f32dd91e5f33a4ca2bc7b7255343"></a>PersistState&#160;</td><td class="fielddoc"><p>point persisted across the update </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba3500ff358c0521359118fe519bd8f605"></a>RemoveState&#160;</td><td class="fielddoc"><p>point was removed in the update </p>
</td></tr>
</table>

</div>
</div>
<a id="a66189f1fe36ac717e284ab1099171106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66189f1fe36ac717e284ab1099171106">&#9670;&nbsp;</a></span>RayCastOpcode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">playrho::RayCastOpcode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ray cast opcode enumeration. </p>
<p>Instructs some ray casting methods on what to do next. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a056fa3d840f48b7bfbbd68c19a4797b3"></a>Terminate&#160;</td><td class="fielddoc"><p>End the ray-cast search for fixtures. </p>
<p>Use this to stop searching for fixtures. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106aaf8767ee039cdc51717435bb815da593"></a>IgnoreFixture&#160;</td><td class="fielddoc"><p>Ignore the current fixture. </p>
<p>Use this to continue searching for fixtures along the ray. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a8dcfe18b6245b17c9cd69d5af7ef1847"></a>ClipRay&#160;</td><td class="fielddoc"><p>Clip the ray end to the current point. </p>
<p>Use this shorten the ray to the current point and to continue searching for fixtures now along the newly shortened ray. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a4592f28dc9d11de3ce507bebafd9de16"></a>ResetRay&#160;</td><td class="fielddoc"><p>Reset the ray end back to the second point. </p>
<p>Use this to restore the ray to its full length and to continue searching for fixtures now along the restored full length ray. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5908a18311a865763d65130dcdf40052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5908a18311a865763d65130dcdf40052">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * playrho::Alloc </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory. </p>
<dl class="section note"><dt>Note</dt><dd>Implement this function to use your own memory allocator. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1StackAllocator.html#ac8e979666fdf6c46afcfabd9917b388a">playrho::StackAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, and <a class="el" href="classplayrho_1_1StackAllocator.html#a1ff66212305cb343da5b90937c1a98a6">playrho::StackAllocator::StackAllocator()</a>.</p>

</div>
</div>
<a id="af449f3dac7aed6e35a519ad0b9ebc540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af449f3dac7aed6e35a519ad0b9ebc540">&#9670;&nbsp;</a></span>AlmostZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , unsigned int FB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether a given value is almost zero. </p>
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga035c5294391f9652e8966092b5caca58">AlmostEqual()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a073a93c54a20aa68f2c56e759b7976ab">playrho::d2::ClipSegmentToLine()</a>, <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::Distance()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a7304da106cfaa394b4d0179ded468aa6">playrho::d2::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad3851d0c3b764c9fe4dbaad8268ea201">playrho::d2::GetToiViaSat()</a>, <a class="el" href="classplayrho_1_1d2_1_1TargetJoint.html#a3b8c6773c43164c5c1c109d774d4515b">playrho::d2::TargetJoint::InitVelocityConstraints()</a>, <a class="el" href="group__Math.html#gaa93fcc5a3b89a2c26ebeb2ba69e31a6d">Invert()</a>, <a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">Normalize()</a>, <a class="el" href="classplayrho_1_1d2_1_1PulleyJoint.html#a1371b014e0d2b3efa90aadb95d112e3b">playrho::d2::PulleyJoint::PulleyJoint()</a>, <a class="el" href="group__RayCastGroup.html#gad7a1b955a57a2bb043750bf32cde2549">playrho::d2::RayCast()</a>, and <a class="el" href="group__Math.html#ga48e5d966eb9e5d6b126f7fbe10d3b697">Solve()</a>.</p>

</div>
</div>
<a id="ac6715d6c6303a8e57025977ca0b079eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6715d6c6303a8e57025977ca0b079eb">&#9670;&nbsp;</a></span>Flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> Flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips contact features information. </p>

</div>
</div>
<a id="a62c138018c11ab3c255b410f2dedd7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c138018c11ab3c255b410f2dedd7d2">&#9670;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playrho::Free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory. </p>
<dl class="section note"><dt>Note</dt><dd>If you implement <code>Alloc</code>, you should also implement this function. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1BlockAllocator.html#a12d8426f4a31b8ed042b2a62699d04e4">playrho::BlockAllocator::Clear()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a74aadaded9475221a0ea343bff727df5">playrho::StackAllocator::Free()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#aa600c0613fcdcbb2c87a6b590554fca8">playrho::d2::DynamicTree::operator=()</a>, <a class="el" href="classplayrho_1_1GrowableStack.html#a9a52c69b5e506bef0d458f1631ca3514">playrho::GrowableStack&lt; T, N &gt;::push()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#a47cbaffc41092844c1b4812057e37f13">playrho::d2::DynamicTree::RebuildBottomUp()</a>, and <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ad81a322bcd52726dba15394783eea8fb">playrho::d2::DynamicTree::~DynamicTree()</a>.</p>

</div>
</div>
<a id="ac7d0f1bd8dfe3701e5380723c3277d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d0f1bd8dfe3701e5380723c3277d68">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, std::size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto &amp; Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the specified element of the given collection. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1ConvexHull.html#af3934cbb1d879f86b8f74f1b4aef9f97">playrho::d2::ConvexHull::Transform()</a>.</p>

</div>
</div>
<a id="abd40c765c799140cbe2b9e1ce4e82bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd40c765c799140cbe2b9e1ce4e82bb7">&#9670;&nbsp;</a></span>GetCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR T GetCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the center of the given interval. </p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the difference between the given range's max and min values overflows the range of the <code><a class="el" href="classplayrho_1_1Interval.html#af3f2912d491535ecbe0f8b03da2357b7" title="Value type. ">Interval::value_type</a></code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__RayCastGroup.html#gadf0ec62e1852e3bc9b017eae4a5616b4">playrho::d2::RayCast()</a>.</p>

</div>
</div>
<a id="abb1706f5ee9f03fdec4a73d2c4d6ce6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1706f5ee9f03fdec4a73d2c4d6ce6b">&#9670;&nbsp;</a></span>GetDefaultToiConf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto GetDefaultToiConf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the default time of impact configuration. </p>

</div>
</div>
<a id="ab8801413b54ba7e1db710717c18020d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8801413b54ba7e1db710717c18020d7">&#9670;&nbsp;</a></span>GetFaceFaceContactFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> GetFaceFaceContactFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the face face contact feature for the given indices. </p>

</div>
</div>
<a id="acba99e7b6830147b661bafaa0dea6e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba99e7b6830147b661bafaa0dea6e57">&#9670;&nbsp;</a></span>GetFaceVertexContactFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> GetFaceVertexContactFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the face vertex contact feature for the given indices. </p>

</div>
</div>
<a id="a43c7cbea13790b72a4bb3aa4af99091c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c7cbea13790b72a4bb3aa4af99091c">&#9670;&nbsp;</a></span>GetIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt;<a class="el" href="structplayrho_1_1IsSquareMatrix.html">IsSquareMatrix</a>&lt;T&gt;::value, T&gt; playrho::GetIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the identity matrix of the template type and size as given by the argument. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Identity_matrix">https://en.wikipedia.org/wiki/Identity_matrix</a> </dd>
<dd>
<a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a" title="Generic M by N matrix. ">Matrix</a>, <a class="el" href="structplayrho_1_1IsMatrix.html" title="Trait class for checking if type is a matrix type. ">IsMatrix</a>, <a class="el" href="structplayrho_1_1IsSquareMatrix.html" title="Trait class for checking if type is a square matrix type. ">IsSquareMatrix</a> </dd></dl>

</div>
</div>
<a id="a4a4f43ebaadcd88f829efb082cebec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4f43ebaadcd88f829efb082cebec9d">&#9670;&nbsp;</a></span>GetIdentityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt;T&gt;::value, <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt;T, N, N&gt; &gt; playrho::GetIdentityMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the identity matrix of the template type and size. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Identity_matrix">https://en.wikipedia.org/wiki/Identity_matrix</a> </dd>
<dd>
<a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a" title="Generic M by N matrix. ">Matrix</a>, <a class="el" href="structplayrho_1_1IsMatrix.html" title="Trait class for checking if type is a matrix type. ">IsMatrix</a>, <a class="el" href="structplayrho_1_1IsSquareMatrix.html" title="Trait class for checking if type is a square matrix type. ">IsSquareMatrix</a> </dd></dl>

</div>
</div>
<a id="ae1f28075bffede36f3b4c48a477edfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f28075bffede36f3b4c48a477edfda">&#9670;&nbsp;</a></span>GetIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; GetIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the intersecting interval of two given ranges. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1detail.html#aa2188c52c7ed607cf89168e29307e468">playrho::detail::GetIntersectingAABB()</a>.</p>

</div>
</div>
<a id="a53f690f42005d67b07deca5aca8bc613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f690f42005d67b07deca5aca8bc613">&#9670;&nbsp;</a></span>GetInvalid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="namespaceplayrho_1_1d2.html#a03a4588e961b6a369745c9c5b68b9868">d2::AABB</a> playrho::GetInvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an invalid AABB value. </p>

</div>
</div>
<a id="a396f543b42eadf60ef9e730edc77912c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396f543b42eadf60ef9e730edc77912c">&#9670;&nbsp;</a></span>GetMaxRegLinearCorrection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> GetMaxRegLinearCorrection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum regular linear correction from the given value. </p>

</div>
</div>
<a id="ae0cf14071c9ab7a52d0a11169a5a5ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cf14071c9ab7a52d0a11169a5a5ee3">&#9670;&nbsp;</a></span>GetMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto playrho::GetMaxSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> -&gt; decltype(pairs.max_size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum size of the given container of index pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns 3. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a331d0f9eebffe5a6de76b5124975bdbf">IsFull()</a>.</p>

</div>
</div>
<a id="a9f5227d01d6f7c75ac2399c3da7b5572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5227d01d6f7c75ac2399c3da7b5572">&#9670;&nbsp;</a></span>GetMovementConf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a> GetMovementConf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the movement configuration from the given value. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#ae47a8f358ef4192f3f47c66b718a5c69">playrho::d2::World::SolveRegIslandViaGS()</a>, and <a class="el" href="classplayrho_1_1d2_1_1World.html#a8c7c99fe7d61f94c5af23040c8403f71">playrho::d2::World::SolveToiViaGS()</a>.</p>

</div>
</div>
<a id="adaa1d36f29e78ecf1d24460013b56560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa1d36f29e78ecf1d24460013b56560">&#9670;&nbsp;</a></span>GetNumValidIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::size_t playrho::GetNumValidIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of valid indices in the given collection of index pairs. </p>
<dl class="section note"><dt>Note</dt><dd>Any element with a value of <code>InvalidIndexPair</code> is interpreted as being invalid in this context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Value between 0 and 3 inclusive. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1SeparationFinder.html#a79c2d12067379a4b718dcd85dd43b33a">playrho::d2::SeparationFinder::Get()</a>, <a class="el" href="namespaceplayrho.html#ad0c4ceb8ef2cef80108a8d9dcb0da945">GetSize()</a>, and <a class="el" href="namespaceplayrho.html#af9e1620b9ba34af4dd2d972369187e29">IsEmpty()</a>.</p>

</div>
</div>
<a id="ad0c4ceb8ef2cef80108a8d9dcb0da945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c4ceb8ef2cef80108a8d9dcb0da945">&#9670;&nbsp;</a></span>GetSize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto playrho::GetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceplayrho.html#adaa1d36f29e78ecf1d24460013b56560">GetNumValidIndices</a>(pairs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dynamic size of the given collection of index pairs. </p>
<dl class="section note"><dt>Note</dt><dd>This just calls <code>GetNumValidIndices</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#adaa1d36f29e78ecf1d24460013b56560" title="Gets the number of valid indices in the given collection of index pairs. ">GetNumValidIndices</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>, <a class="el" href="namespaceplayrho.html#a8d45df992becf6fd54bb224344dcfd82">GetBlockSizeIndex()</a>, <a class="el" href="namespaceplayrho_1_1detail.html#a69db919dd0fd89175d3e6386508e0d87">playrho::detail::GetDimensions()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a2845e1a67f12b93c3bd543e72f6655f0">playrho::BlockAllocator::GetMaxBlockSize()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a4f671c547cf8f5deecfa5bbf08899f14">playrho::d2::GetPerimeter()</a>, and <a class="el" href="namespaceplayrho.html#a331d0f9eebffe5a6de76b5124975bdbf">IsFull()</a>.</p>

</div>
</div>
<a id="a27cd843c0cfe341550f2f4e5f91bf894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cd843c0cfe341550f2f4e5f91bf894">&#9670;&nbsp;</a></span>GetSize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR T playrho::GetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the given interval. </p>
<p>Gets the difference between the max and min values. </p><dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the difference between the given range's max and min values overflows the range of the <code><a class="el" href="classplayrho_1_1Interval.html#af3f2912d491535ecbe0f8b03da2357b7" title="Value type. ">Interval::value_type</a></code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value unless the given interval is "unset" or invalid. </dd></dl>

</div>
</div>
<a id="a7f14d6b4300980071278dc4f968d36db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f14d6b4300980071278dc4f968d36db">&#9670;&nbsp;</a></span>GetSize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto playrho::GetSize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; decltype(arg.size())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current size of the given container. </p>
<dl class="section note"><dt>Note</dt><dd>This is from <code>std::size</code> for C++17. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/size">http://en.cppreference.com/w/cpp/iterator/size</a> </dd></dl>

</div>
</div>
<a id="a09121345512aa02387efe31575450d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09121345512aa02387efe31575450d6c">&#9670;&nbsp;</a></span>GetTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* playrho::GetTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the library defined name for the given type. </p>
<p>Provides an interface to a function that can be specialized for getting a C-style null-terminated array of characters that names the type. </p><dl class="section return"><dt>Returns</dt><dd>Non-null pointer to C-style string name of specified type. </dd></dl>

</div>
</div>
<a id="a2557f9e67a6520f3539c9ab282823c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2557f9e67a6520f3539c9ab282823c70">&#9670;&nbsp;</a></span>GetTypeName< Fixed32 >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespaceplayrho.html#a09121345512aa02387efe31575450d6c">playrho::GetTypeName</a>&lt; <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the specialized name for the <code>Fixed32</code> type. </p>
<p>Provides an interface to a specialized function for getting C-style null-terminated array of characters that names the <code>Fixed32</code> type. </p><dl class="section return"><dt>Returns</dt><dd>Non-null pointer to C-style string name of specified type. </dd></dl>

</div>
</div>
<a id="ad6e8b575033edcfa889ffbf46c59d3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e8b575033edcfa889ffbf46c59d3cf">&#9670;&nbsp;</a></span>GetVertexFaceContactFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> GetVertexFaceContactFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the vertex face contact feature for the given indices. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a073a93c54a20aa68f2c56e759b7976ab">playrho::d2::ClipSegmentToLine()</a>.</p>

</div>
</div>
<a id="a10ad4cc19ec75313b99288e91950a47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ad4cc19ec75313b99288e91950a47d">&#9670;&nbsp;</a></span>GetVertexVertexContactFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> GetVertexVertexContactFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the vertex vertex contact feature for the given indices. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Manifold.html#ab19eafd2d1d5c978707fcfcd043a5b16">playrho::d2::Manifold::GetForCircles()</a>.</p>

</div>
</div>
<a id="a75679dddad0465e76a3293176fc1eb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75679dddad0465e76a3293176fc1eb67">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto playrho::IsEmpty </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; decltype(arg.empty())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the given container is empty. </p>
<dl class="section note"><dt>Note</dt><dd>This is from <code>std::empty</code> for C++17. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/empty">http://en.cppreference.com/w/cpp/iterator/empty</a> </dd></dl>

</div>
</div>
<a id="a6337a4ffbf1fbfb13eece2bb55b93435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6337a4ffbf1fbfb13eece2bb55b93435">&#9670;&nbsp;</a></span>IsIntersecting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool IsIntersecting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two value ranges have any intersection/overlap at all. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1detail.html#a5accaf2fe5186e02ddb93f8c07887c54">playrho::detail::TestOverlap()</a>.</p>

</div>
</div>
<a id="a05d21c386ca6d39d5cc35cbad350a8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d21c386ca6d39d5cc35cbad350a8c9">&#9670;&nbsp;</a></span>IsMaxTranslationWithinTolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsMaxTranslationWithinTolerance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1StepConf.html">StepConf</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the maximum translation is within tolerance. </p>

</div>
</div>
<a id="a85222e60032cfff157b66b69d86a7941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85222e60032cfff157b66b69d86a7941">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1d2_1_1Transformation.html">d2::Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>

</div>
</div>
<a id="aed18ca9774b8ac513ee9c21153395b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed18ca9774b8ac513ee9c21153395b8e">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1d2_1_1Position.html">d2::Position</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>

</div>
</div>
<a id="aa51995ca843108552f24b8ccf3c7bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51995ca843108552f24b8ccf3c7bcee">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Sweep.html">d2::Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>

</div>
</div>
<a id="a75eaa3e476bb7117d67e6df9fbfef61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75eaa3e476bb7117d67e6df9fbfef61b">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1d2_1_1Acceleration.html">d2::Acceleration</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>

</div>
</div>
<a id="a2b6887c8070394826911cddf7c29be82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6887c8070394826911cddf7c29be82">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1d2_1_1Velocity.html">d2::Velocity</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>

</div>
</div>
<a id="aec0b8dab819e96f993cfdb8c5852ea3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0b8dab819e96f993cfdb8c5852ea3e">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>
<p>Determines whether the given vector contains finite coordinates. </p>

</div>
</div>
<a id="ad596c747e4643415e312ad69bef2a03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad596c747e4643415e312ad69bef2a03b">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Manifold.html">d2::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the given manifold is valid. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Sweep.html#a3597bd76c2b89f3b7f217692071fde47">playrho::d2::Sweep::Advance0()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a44cc65808fd89570707b3af1bc87eb36">playrho::d2::ComputeAABB()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ae18a4d20126e2b38e9840992b4bf0791">playrho::d2::DynamicTree::CreateLeaf()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::Distance()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#a153aeeb44400486c3a14c9e61fe7b197">playrho::d2::DynamicTree::FindLowestCostNode()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a1b9c651f93348723973bb0e08c4bc9ac">playrho::d2::VelocityConstraint::GetPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#ae1cb8e651628460be908ba768c7d3883">playrho::d2::WorldManifold::GetPointCount()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#aa791f769d7311d093e53b09c772b78d6">playrho::d2::GetPosition()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad3851d0c3b764c9fe4dbaad8268ea201">playrho::d2::GetToiViaSat()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a41583becf8482b534e9ce54ecd5601f7">playrho::d2::GetTransformation()</a>, <a class="el" href="classplayrho_1_1d2_1_1TargetJoint.html#a3b8c6773c43164c5c1c109d774d4515b">playrho::d2::TargetJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1d2_1_1TargetJoint.html#a344d49a15bfc2ddc9ef00643c43eed04">playrho::d2::TargetJoint::IsOkay()</a>, <a class="el" href="namespaceplayrho.html#a75eaa3e476bb7117d67e6df9fbfef61b">IsValid()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#ae216d87f0c3ab4660646133f58f3fb30">playrho::d2::Body::SetAcceleration()</a>, <a class="el" href="classplayrho_1_1d2_1_1MotorJoint.html#a9245b78f8c2437be65aa74a58a6c5988">playrho::d2::MotorJoint::SetCorrectionFactor()</a>, <a class="el" href="classplayrho_1_1d2_1_1BodyConstraint.html#ac2ab5427fcb2b91bc821d47275f111be">playrho::d2::BodyConstraint::SetPosition()</a>, <a class="el" href="classplayrho_1_1d2_1_1GearJoint.html#af302322eccd08aac5d314bb2b8b7a215">playrho::d2::GearJoint::SetRatio()</a>, <a class="el" href="classplayrho_1_1d2_1_1TargetJoint.html#adccc0a4d534ff19819851e22011da795">playrho::d2::TargetJoint::SetTarget()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#a51f40a6566392899980a0ba431e1aa89">playrho::d2::Body::SetTransform()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#a7c2bb05f34ad19f785a9cf88d5920b77">playrho::d2::Body::SetTransformation()</a>, <a class="el" href="classplayrho_1_1d2_1_1BodyConstraint.html#a911b6c49a7b561071794b80a437337dd">playrho::d2::BodyConstraint::SetVelocity()</a>, <a class="el" href="classplayrho_1_1d2_1_1TargetJoint.html#a63c767a86e1ece9f5a5e2d3f2ae38e23">playrho::d2::TargetJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#abecb08ff48f11998024ebb2ddf00300e">playrho::d2::World::Synchronize()</a>, and <a class="el" href="classplayrho_1_1d2_1_1World.html#a35b79e2bb6204b41236efa1ecb251c14">playrho::d2::World::UpdateBody()</a>.</p>

</div>
</div>
<a id="ab84205bd8956258eea02a5cb0d829042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84205bd8956258eea02a5cb0d829042">&#9670;&nbsp;</a></span>MakeUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt;std::is_signed&lt;T&gt;::value, std::make_unsigned_t&lt;T&gt; &gt; playrho::MakeUnsigned </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the given value into an unsigned value. </p>
<dl class="section note"><dt>Note</dt><dd>If the given value is negative, this will result in an unsigned value which is the two's complement modulo-wrapped value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a1b38c605da457526f62c63035cb0affe">playrho::d2::Count()</a>.</p>

</div>
</div>
<a id="a50d46e6e45df1f7049decee120ce9922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d46e6e45df1f7049decee120ce9922">&#9670;&nbsp;</a></span>MixFriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> playrho::MixFriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>friction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>friction2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mixes friction. </p>
<p>Friction mixing formula. The idea is to allow either fixture to drive the resulting friction to zero. For example, anything slides on ice.</p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if either friction values is less than zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">friction1</td><td>A zero or greater value. </td></tr>
    <tr><td class="paramname">friction2</td><td>A zero or greater value. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a6364ce32adb82c7dd45b80e8b0c9bfd5">playrho::d2::ResetFriction()</a>.</p>

</div>
</div>
<a id="abdd2574637d4c8869ae345d3975829cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd2574637d4c8869ae345d3975829cc">&#9670;&nbsp;</a></span>MixRestitution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> playrho::MixRestitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>restitution1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>restitution2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mixes restitution. </p>
<p>Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface. For example, a super ball bounces on anything. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ae7c83e82f89844199f5c06c5cda3749d">playrho::d2::ResetRestitution()</a>.</p>

</div>
</div>
<a id="a11952027f7e2cabb36d03c2677219a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11952027f7e2cabb36d03c2677219a4a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

</div>
</div>
<a id="ab177f652a925ae4e4a236a597dbe6d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab177f652a925ae4e4a236a597dbe6d07">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

</div>
</div>
<a id="a9469d42ec9781ca037c112ae05ebe9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9469d42ec9781ca037c112ae05ebe9ae">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given two contact features are not equal. </p>

</div>
</div>
<a id="afb0b5a548efed2357cfdfa38c746f00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0b5a548efed2357cfdfa38c746f00f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

</div>
</div>
<a id="a56e28e7223ba1dc78278773b81130c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e28e7223ba1dc78278773b81130c19">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="section note"><dt>Note</dt><dd>Satisfies the <code>EqualityComparable</code> concept for <a class="el" href="classplayrho_1_1Interval.html" title="Interval template type. ">Interval</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/EqualityComparable">http://en.cppreference.com/w/cpp/concept/EqualityComparable</a> </dd></dl>

</div>
</div>
<a id="a916ffd1ead44fed6c0296cd1eb152de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916ffd1ead44fed6c0296cd1eb152de8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, std::size_t C, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, C &gt;, A &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, B &gt;, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, C &gt;, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the matrix product of the two given vector of vectors (matrices). </p>
<p>Multiplies an A-by-B vector of vectors by a B-by-C vector of vectors returning an A-by-C vector of vectors. </p><dl class="section note"><dt>Note</dt><dd>From Wikipedia: <blockquote class="doxtable">
<p>Multiplication of two matrices is defined if and only if the number of columns of the left matrix is the same as the number of rows of the right matrix. </p>
</blockquote>
</dd>
<dd>
Matrix multiplication is not commutative. </dd>
<dd>
Algorithmically speaking, this implementation is called the "naive" algorithm. For small matrices, like 3-by-3 or smaller matrices, its complexity shouldn't be an issue. The matrix dimensions are compile time constants anyway which can help compilers automatically identify loop unrolling and hardware level parallelism opportunities. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side matrix. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A-by-C matrix product of the left-hand-side matrix and the right-hand-side matrix. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_multiplication">https://en.wikipedia.org/wiki/Matrix_multiplication</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm">https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Commutative_property">https://en.wikipedia.org/wiki/Commutative_property</a> </dd></dl>

</div>
</div>
<a id="a65669d8b8c23c5569bfcf6a5262a6cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65669d8b8c23c5569bfcf6a5262a6cdb">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt;<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt;T1, T2&gt;::value &amp;&amp; !<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt;T1&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;OT, B&gt; &gt; playrho::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, B &gt;, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies an A-element vector by a A-by-B vector of vectors. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm favors column major ordering of the vector of vectors. </dd>
<dd>
This treats the left-hand-side argument as though it's a 1-by-A vector of vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side vector treated as if it were of type: <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a>&lt;Vector&lt;T1, A&gt;, 1&gt;</code>. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side vector of vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B-element vector product. </dd></dl>

</div>
</div>
<a id="a9a493b2f768fa07b50356b4ba142ad11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a493b2f768fa07b50356b4ba142ad11">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt;<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt;T1, T2&gt;::value &amp;&amp; !<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt;T2&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;OT, B&gt; &gt; playrho::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt;, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a B-by-A vector of vectors by an A-element vector. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm favors row major ordering of the vector of vectors. </dd>
<dd>
This treats the right-hand-side argument as though it's an A-by-1 vector of vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side vector of vectors. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side vector treated as if it were of type: <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a>&lt;Vector&lt;T2, 1&gt;, A&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B-element vector product. </dd></dl>

</div>
</div>
<a id="a49704e8fc8a2eb2e95e3a429ad638f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49704e8fc8a2eb2e95e3a429ad638f50">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T1 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for non-vector times vector. </p>
<dl class="section note"><dt>Note</dt><dd>Explicitly disabled for <a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> * <a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> to prevent this function from existing in that case and prevent errors like "use of overloaded operator '*' is ambiguous". </dd></dl>

</div>
</div>
<a id="a329a09aded9f2ef0d9f599153feebc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329a09aded9f2ef0d9f599153feebc63">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for vector times non-vector. </p>
<dl class="section note"><dt>Note</dt><dd>Explicitly disabled for <a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> * <a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> to prevent this function from existing in that case and prevent errors like "use of overloaded operator '*' is ambiguous". </dd></dl>

</div>
</div>
<a id="a3867e38d81818a352ab8e6f527a5dafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3867e38d81818a352ab8e6f527a5dafa">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T1, decltype(T1{} *T2{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator. </p>

</div>
</div>
<a id="ae0ab91ce9948b28251bd5f7010ea56f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ab91ce9948b28251bd5f7010ea56f8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto playrho::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition operator for two same-type, same-sized matrices. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_addition">https://en.wikipedia.org/wiki/Matrix_addition</a> </dd></dl>

</div>
</div>
<a id="a32698762d0d37c394a55cdd167cd4948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32698762d0d37c394a55cdd167cd4948">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary plus operator. </p>

</div>
</div>
<a id="a26f12e932cc3ae8a52a46acb6a759018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f12e932cc3ae8a52a46acb6a759018">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{}+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two vectors component-wise. </p>

</div>
</div>
<a id="a9ac37e361c264eb820a4fcd0957b6659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac37e361c264eb820a4fcd0957b6659">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{}+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the left hand side value by the right hand side value. </p>

</div>
</div>
<a id="abf301cca25ae9324372e0d266601be2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf301cca25ae9324372e0d266601be2e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR auto playrho::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix subtraction operator for two same-type, same-sized matrices. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_addition">https://en.wikipedia.org/wiki/Matrix_addition</a> </dd></dl>

</div>
</div>
<a id="a4b14eb31c39cb09ab1e073c98b575de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b14eb31c39cb09ab1e073c98b575de4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(-T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary negation operator. </p>

</div>
</div>
<a id="ae4498290f800bb77a09ca6e181f4d200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4498290f800bb77a09ca6e181f4d200">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{} - T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two vectors component-wise. </p>

</div>
</div>
<a id="a17db72d9d3cf57a3dcde299003091925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17db72d9d3cf57a3dcde299003091925">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T, decltype(T{} - T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements the left hand side value by the right hand side value. </p>

</div>
</div>
<a id="a7adc6d6a43f882bafb2b88a4e7091e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adc6d6a43f882bafb2b88a4e7091e57">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} / T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsDivisable.html">IsDivisable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator. </p>

</div>
</div>
<a id="a33ef497cc5b8197cec1fb5bf7fcdb546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ef497cc5b8197cec1fb5bf7fcdb546">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR std::enable_if_t&lt; std::is_same&lt; T1, decltype(T1{}/T2{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator. </p>

</div>
</div>
<a id="ab24ce9e9d1f928ef3e60c6bede948966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24ce9e9d1f928ef3e60c6bede948966">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison. </dd>
<dd>
Obeys the <code>LessThanComparable</code> concept: <code>for all a, !(a &lt; a); if (a &lt; b) then !(b &lt; a); if (a &lt; b) and (b &lt; c) then (a &lt; c); with equiv = !(a &lt; b) &amp;&amp; !(b &lt; a), if equiv(a, b) and equiv(b, c), then equiv(a, c).</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">http://en.cppreference.com/w/cpp/concept/LessThanComparable</a> </dd></dl>

</div>
</div>
<a id="a53f714963917f6a632001a9bb3a3d1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f714963917f6a632001a9bb3a3d1d6">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical less-than operator. </p>

</div>
</div>
<a id="a6bda91572806860fa512fff0f01a001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bda91572806860fa512fff0f01a001b">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::std::ostream&amp; playrho::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">::std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream operator. </p>

</div>
</div>
<a id="a54f2a9ebae8216d14665a627b78c81a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2a9ebae8216d14665a627b78c81a8">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than or equal-to operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="a8920673b547533b8ea9ae73a337cd426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8920673b547533b8ea9ae73a337cd426">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical less-than or equal-to operator. </p>

</div>
</div>
<a id="a7fa7929a7c9cfd63177dcf77c3116bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa7929a7c9cfd63177dcf77c3116bf1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1FixtureProxy.html">FixtureProxy</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<a id="af48fe223cf379b5534ebf571d5f83164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48fe223cf379b5534ebf571d5f83164">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<a id="a197cce644da40356103fcdebd7911dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197cce644da40356103fcdebd7911dba">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given two contact features are equal. </p>

</div>
</div>
<a id="ac57dd3d609c236bf471a84526d8dfe4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57dd3d609c236bf471a84526d8dfe4e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<a id="abebf2ea3be7831ecd4559b2bc0d739c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebf2ea3be7831ecd4559b2bc0d739c1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="section note"><dt>Note</dt><dd>Satisfies the <code>EqualityComparable</code> concept for <a class="el" href="classplayrho_1_1Interval.html" title="Interval template type. ">Interval</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/EqualityComparable">http://en.cppreference.com/w/cpp/concept/EqualityComparable</a> </dd></dl>

</div>
</div>
<a id="a4d1061544f64556d9c7d77ae547a60b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1061544f64556d9c7d77ae547a60b8">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="ab6dcf1a39cfc007ab5fc07b698d306e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dcf1a39cfc007ab5fc07b698d306e9">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical greater-than operator. </p>

</div>
</div>
<a id="a6f7ace6468a69a7f600ff05d01598ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7ace6468a69a7f600ff05d01598ffd">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than or equal-to operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="a69f0a3cf79016d76c6949999433a8fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0a3cf79016d76c6949999433a8fb5">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical greater-than or equal-to operator. </p>

</div>
</div>
<a id="a1e5b2682a491fff8510bbcfea1929e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5b2682a491fff8510bbcfea1929e59">&#9670;&nbsp;</a></span>Realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * playrho::Realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates memory. </p>
<dl class="section note"><dt>Note</dt><dd>Implement this function to use your own memory allocator. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a3a103da67690df019db5811cec069c61">Realloc()</a>.</p>

</div>
</div>
<a id="a223329721a8138f316898ed9a4877250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223329721a8138f316898ed9a4877250">&#9670;&nbsp;</a></span>ShouldCollide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ShouldCollide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filterA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filterB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether collision processing should be performed. </p>

</div>
</div>
<a id="a4d72a91d98ac22b6b7603f9747bca314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d72a91d98ac22b6b7603f9747bca314">&#9670;&nbsp;</a></span>Visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool playrho::Visit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function for visiting objects. </p>
<dl class="section note"><dt>Note</dt><dd>Specialize this function to tie in application specific handling for types which don't already have specialized handling. Specializations should always return <code>true</code>. </dd>
<dd>
First parameter is the object to visit. </dd>
<dd>
Second parameter is user data or the <code>nullptr</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Visitor_pattern">https://en.wikipedia.org/wiki/Visitor_pattern</a> </dd></dl>

</div>
</div>
<a id="a5088fa473b382571a89d042e8a310bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5088fa473b382571a89d042e8a310bee">&#9670;&nbsp;</a></span>Visit< d2::Shape >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceplayrho.html#a4d72a91d98ac22b6b7603f9747bca314">playrho::Visit</a>&lt; <a class="el" href="classplayrho_1_1d2_1_1Shape.html">d2::Shape</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">d2::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visits the given shape with the potentially non-null user data pointer. </p>
<dl class="section note"><dt>Note</dt><dd>This is a specialization of the <code>Visit</code> function template for the <code><a class="el" href="classplayrho_1_1d2_1_1Shape.html" title="Shape. ">d2::Shape</a></code> class. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Visitor_pattern">https://en.wikipedia.org/wiki/Visitor_pattern</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a14624c80f5b2f01b49d878764aa55af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14624c80f5b2f01b49d878764aa55af0">&#9670;&nbsp;</a></span>AllocatorBlockSizes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const std::size_t playrho::AllocatorBlockSizes[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    {</div><div class="line">        16, 32, 64, 96, 128, 160, 192, 224, 256, 320, 384, 448, 512, 640,</div><div class="line">    }</div></div><!-- fragment -->
<p>Allocator block sizes array data. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, and <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>.</p>

</div>
</div>
<a id="a5e86e9585daf0c5ae48263653f206c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e86e9585daf0c5ae48263653f206c56">&#9670;&nbsp;</a></span>DefaultAngularSleepTolerance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultAngularSleepTolerance = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{(<a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * 2) / 180} * <a class="el" href="group__PhysicalUnits.html#ga100ccbd2bb9a367b985c771244bfd06d">RadianPerSecond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default angular sleep tolerance. </p>
<p>A body cannot sleep if its angular velocity is above this amount. </p>

</div>
</div>
<a id="afdeec74885c6139f6d3589df0961b465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdeec74885c6139f6d3589df0961b465">&#9670;&nbsp;</a></span>DefaultAngularSlop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultAngularSlop = (<a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * 2_rad) / Real{180}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default angular slop. </p>
<p>A small angle used as a collision and constraint tolerance. Usually it is chosen to be numerically significant, but visually insignificant. </p>

</div>
</div>
<a id="a5625850696940f96094a3da078187d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5625850696940f96094a3da078187d63">&#9670;&nbsp;</a></span>DefaultCirclesRatio</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultCirclesRatio = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{10}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default circles ratio. </p>
<p>Ratio used for switching between rounded-corner collisions and closest-face biased normal collisions. </p>

</div>
</div>
<a id="a3df889ebb1bb1244d02eb379c9ba6e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df889ebb1bb1244d02eb379c9ba6e41">&#9670;&nbsp;</a></span>DefaultLinearSleepTolerance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultLinearSleepTolerance = 0.01_mps</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default linear sleep tolerance. </p>
<p>A body cannot sleep if the magnitude of its linear velocity is above this amount. </p>

</div>
</div>
<a id="a3d420c3642290da261ff169a973b070f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d420c3642290da261ff169a973b070f">&#9670;&nbsp;</a></span>DefaultLinearSlop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultLinearSlop = <a class="el" href="structplayrho_1_1detail_1_1Defaults.html">detail::Defaults</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::GetLinearSlop()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default linear slop. </p>
<p>Length used as a collision and constraint tolerance. Usually chosen to be numerically significant, but visually insignificant. Lower or raise to decrease or increase respectively the minimum of space between bodies at rest. </p><dl class="section note"><dt>Note</dt><dd>Smaller values relative to sizes of bodies increases the time it takes for bodies to come to rest. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1DiskShapeConf.html#a7b449596383835ec7e2d4868a5e262ed">playrho::d2::DiskShapeConf::GetDefaultRadius()</a>, <a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html#a964f148cd7c5507a2d0a39f36bbc73fa">playrho::d2::PolygonShapeConf::GetDefaultVertexRadius()</a>, <a class="el" href="classplayrho_1_1d2_1_1EdgeShapeConf.html#a54d089d5ad8e26aac03f2d0d70d84499">playrho::d2::EdgeShapeConf::GetDefaultVertexRadius()</a>, <a class="el" href="classplayrho_1_1d2_1_1ChainShapeConf.html#af5c859b445995082575e72afdc0cb2f3">playrho::d2::ChainShapeConf::GetDefaultVertexRadius()</a>, <a class="el" href="structplayrho_1_1d2_1_1MultiShapeConf.html#a7d2a15ec3044e03c69be7bea285568ed">playrho::d2::MultiShapeConf::GetDefaultVertexRadius()</a>, and <a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html#a0f0f7f5c1e7813f0fddfbec61f67fab6">playrho::d2::PolygonShapeConf::Set()</a>.</p>

</div>
</div>
<a id="a8c72ad15b5cc7420967f448df82f9392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c72ad15b5cc7420967f448df82f9392">&#9670;&nbsp;</a></span>DefaultMaxAngularCorrection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultMaxAngularCorrection = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(8.0f / 180.0f) * Pi * 1_rad</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum angular correction. </p>
<dl class="section note"><dt>Note</dt><dd>This value should be greater than the angular slop value. </dd></dl>

</div>
</div>
<a id="af06c35910bfd4af96dab8900b3bbd068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06c35910bfd4af96dab8900b3bbd068">&#9670;&nbsp;</a></span>DefaultMaxLinearCorrection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultMaxLinearCorrection = 0.2_m</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum linear correction. </p>
<p>The maximum linear position correction used when solving constraints. This helps to prevent overshoot. </p><dl class="section note"><dt>Note</dt><dd>This value should be greater than the linear slop value. </dd></dl>

</div>
</div>
<a id="a57b41af1b8c909a70f0212ce87a7a5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b41af1b8c909a70f0212ce87a7a5dc">&#9670;&nbsp;</a></span>DefaultMaxRotation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultMaxRotation = <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{<a class="el" href="namespaceplayrho.html#a83e2e155484aefe7098ddf4248bff8ca">Pi</a> * 1_rad / Real(2)}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum rotation per world step. </p>
<dl class="section warning"><dt>Warning</dt><dd>This value should be less than Pi * Radian. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This limit is meant to prevent numerical problems. Adjusting this value isn't advised. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classplayrho_1_1StepConf.html#a0ab48d76f772682e5d2d2d937eacdde4" title="Maximum rotation. ">StepConf::maxRotation</a>. </dd></dl>

</div>
</div>
<a id="a372f74648b7c4e8b586f6fd84b9cc232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372f74648b7c4e8b586f6fd84b9cc232">&#9670;&nbsp;</a></span>DefaultMaxSubSteps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultMaxSubSteps = std::uint8_t{8}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum number of sub steps. </p>
<p>This is the default maximum number of sub-steps per contact in continuous physics simulation. In other words, this is the default maximum number of times in a world step that a contact will have continuous collision resolution done for it. </p><dl class="section note"><dt>Note</dt><dd>Used in the TOI phase of step processing. </dd></dl>

</div>
</div>
<a id="a21d3598cecf216d489aa0a62f0f1651d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d3598cecf216d489aa0a62f0f1651d">&#9670;&nbsp;</a></span>DefaultMinStillTimeToSleep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::DefaultMinStillTimeToSleep = <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>{1_s / 2}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default minimum still time to sleep. </p>
<p>The default minimum time bodies must be still for bodies to be put to sleep. </p>

</div>
</div>
<a id="a9ae0d4494c5f273d7bae9489ea22cf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae0d4494c5f273d7bae9489ea22cf15">&#9670;&nbsp;</a></span>InvalidIndexPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::InvalidIndexPair</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>{</div><div class="line">    <a class="code" href="namespaceplayrho.html#ab13e92f7c6118e3ac33ea8f769dd51a3">InvalidVertex</a>, <a class="code" href="namespaceplayrho.html#ab13e92f7c6118e3ac33ea8f769dd51a3">InvalidVertex</a></div><div class="line">}</div><div class="ttc" id="namespaceplayrho_html_ab13e92f7c6118e3ac33ea8f769dd51a3"><div class="ttname"><a href="namespaceplayrho.html#ab13e92f7c6118e3ac33ea8f769dd51a3">playrho::InvalidVertex</a></div><div class="ttdeci">PLAYRHO_CONSTEXPR const auto InvalidVertex</div><div class="ttdoc">Invalid vertex index. </div><div class="ttdef"><b>Definition:</b> Settings.hpp:125</div></div>
<div class="ttc" id="namespaceplayrho_html_a7d449e0a1528c10ae0f241713fb69b40"><div class="ttname"><a href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">playrho::IndexPair</a></div><div class="ttdeci">std::pair&lt; VertexCounter, VertexCounter &gt; IndexPair</div><div class="ttdoc">Index pair. </div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:36</div></div>
</div><!-- fragment -->
<p>Invalid index-pair value. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::Distance()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a70613779e152f647af4f80dce352d83c">playrho::d2::GetIndexPairs()</a>, and <a class="el" href="namespaceplayrho.html#adaa1d36f29e78ecf1d24460013b56560">GetNumValidIndices()</a>.</p>

</div>
</div>
<a id="a7a6ff7b1718107009f0242e8919d96a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6ff7b1718107009f0242e8919d96a7">&#9670;&nbsp;</a></span>InvalidIndexPair3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::InvalidIndexPair3</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>{{</div><div class="line">    <a class="code" href="namespaceplayrho.html#a9ae0d4494c5f273d7bae9489ea22cf15">InvalidIndexPair</a>, <a class="code" href="namespaceplayrho.html#a9ae0d4494c5f273d7bae9489ea22cf15">InvalidIndexPair</a>, InvalidIndexPair</div><div class="line">}}</div><div class="ttc" id="namespaceplayrho_html_a704da3b24d9b1f9135e140dcd5420518"><div class="ttname"><a href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">playrho::IndexPair3</a></div><div class="ttdeci">std::array&lt; IndexPair, MaxSimplexEdges &gt; IndexPair3</div><div class="ttdoc">Array of three index-pair elements. </div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:47</div></div>
<div class="ttc" id="namespaceplayrho_html_a9ae0d4494c5f273d7bae9489ea22cf15"><div class="ttname"><a href="namespaceplayrho.html#a9ae0d4494c5f273d7bae9489ea22cf15">playrho::InvalidIndexPair</a></div><div class="ttdeci">PLAYRHO_CONSTEXPR const auto InvalidIndexPair</div><div class="ttdoc">Invalid index-pair value. </div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:39</div></div>
</div><!-- fragment -->
<p>Invalid array of three index-pair elements. </p>

</div>
</div>
<a id="a7e8a3bed4ddbbfdbaf170055a932dfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8a3bed4ddbbfdbaf170055a932dfed">&#9670;&nbsp;</a></span>MaxBodies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::MaxBodies</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div><div class="line">                                                      std::uint16_t{1})</div></div><!-- fragment -->
<p>Maximum number of bodies in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#ad4be6a47513f324105d91a85c1628837">playrho::d2::World::AddToIsland()</a>, and <a class="el" href="classplayrho_1_1d2_1_1World.html#a66716e8c9020509c9891d9223a58be93">playrho::d2::World::CreateBody()</a>.</p>

</div>
</div>
<a id="a033fed46214035a6a09bc21400d1c61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033fed46214035a6a09bc21400d1c61c">&#9670;&nbsp;</a></span>MaxContacts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::MaxContacts = <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a>} * <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7e8a3bed4ddbbfdbaf170055a932dfed">MaxBodies</a> - 1} / <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{2}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of contacts in a world (2147319811). </p>
<p>Uses the formula for the maximum number of edges in an unidirectional graph of <code>MaxBodies</code> nodes. This occurs when every possible body is connected to every other body. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#aee4f65962fab8e1368212784b979767c">playrho::d2::World::Add()</a>.</p>

</div>
</div>
<a id="a4ea7793500223bfe5600812095e41a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea7793500223bfe5600812095e41a72">&#9670;&nbsp;</a></span>MaxJoints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::MaxJoints</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div><div class="line">                                                      std::uint16_t{1})</div></div><!-- fragment -->
<p>Maximum number of joints in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#a8b2dbd2e42ecedf2d877875c62a9a2a4">playrho::d2::World::CreateJoint()</a>.</p>

</div>
</div>
<a id="a56978175f768dd093094931064fed774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56978175f768dd093094931064fed774">&#9670;&nbsp;</a></span>MaxManifoldPoints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::MaxManifoldPoints = std::uint8_t{2}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum manifold points. This is the maximum number of contact points between two convex shapes. Do not change this value. </p>
<dl class="section note"><dt>Note</dt><dd>For memory efficiency, uses the smallest integral type that can hold the value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1ContactImpulsesList.html#a10582ed9bfbe1061650b20acbaa3787f">playrho::d2::ContactImpulsesList::AddEntry()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a149f6f811476b024dca1245f57c5aa75">playrho::d2::VelocityConstraint::AddPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1Manifold.html#a1399ecf9d6951ca8b72dd34dc66d1e75">playrho::d2::Manifold::AddPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a82d672d8bf598bf27a746423392b72b3">playrho::d2::WorldManifold::GetImpulses()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a4872f3b8f5ec291a4e2d8324829f82b6">playrho::d2::WorldManifold::GetPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a0522810720f80c9e976e069aaca09cf4">playrho::d2::VelocityConstraint::GetPointAt()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a0e20bfa57459aa27c74c57043b822bd0">playrho::d2::WorldManifold::GetSeparation()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a5087e20abce45986f04d23834de5f8f3">playrho::d2::VelocityConstraint::PointAt()</a>, and <a class="el" href="classplayrho_1_1d2_1_1Manifold.html#a477022edb23b761024a659e533098047">playrho::d2::Manifold::SetPointImpulses()</a>.</p>

</div>
</div>
<a id="ac43acb3229848771f11e519430b91725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43acb3229848771f11e519430b91725">&#9670;&nbsp;</a></span>MaxShapeVertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::MaxShapeVertices = std::uint8_t{254}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of vertices for any shape type. </p>
<dl class="section note"><dt>Note</dt><dd>For memory efficiency, uses the smallest integral type that can hold the value minus one that's left out as a sentinel value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ad3851d0c3b764c9fe4dbaad8268ea201">playrho::d2::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="a83e2e155484aefe7098ddf4248bff8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e2e155484aefe7098ddf4248bff8ca">&#9670;&nbsp;</a></span>Pi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::Pi = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(3.14159265358979323846264338327950288)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pi. </p>
<p>An "irrational number" that's defined as the ratio of a circle's circumference to its diameter.</p>
<dl class="section note"><dt>Note</dt><dd>While the include file definition of M_PI may be a POSIX compliance requirement and initially attractive to use, it's apparently not a C++ standards requirement and casually including it pollutes the name space of all code that uses this library. Whatever the case, MSVC 2017 doesn't make it part of the <code>cmath</code> include without enabling <code>_USE_MATH_DEFINES</code>. So rather than add yet more C preprocessor macros to all sources that this library may be compiled with, it's simply hard-coded in here instead using a C++ mechanism that also keeps it with the enclosing name space. </dd>
<dd>
Any narrowing is intentional.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Pi">https://en.wikipedia.org/wiki/Pi</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga0eb57dabfe8d3db9e509a6b493173358">GetAreaOfCircle()</a>, <a class="el" href="group__Math.html#ga3b8e8abc999b0c63cf1921b0edcf0b36">GetCircleVertices()</a>, <a class="el" href="group__Math.html#ga8c036532db1260373b97c1d85360894c">GetDelta()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a9b3b93dcaddc83a77e35b87b54960d5e">playrho::d2::GetMassData()</a>, <a class="el" href="classplayrho_1_1d2_1_1ChainShapeConf.html#a212282d094f3bb26c9182f72eac6319d">playrho::d2::ChainShapeConf::GetMassData()</a>, <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">GetNormalized()</a>, <a class="el" href="classplayrho_1_1d2_1_1WeldJoint.html#a265ce4480c483f05e12d3096d1ccdcd4">playrho::d2::WeldJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceJoint.html#a311249c1d60b80f288317962bf733d4d">playrho::d2::DistanceJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1d2_1_1TargetJoint.html#a3b8c6773c43164c5c1c109d774d4515b">playrho::d2::TargetJoint::InitVelocityConstraints()</a>, and <a class="el" href="classplayrho_1_1d2_1_1WheelJoint.html#add8afb78454f0c0684932b1acd52bc05">playrho::d2::WheelJoint::InitVelocityConstraints()</a>.</p>

</div>
</div>
<a id="aea8c760ae98e855ef8ba9c976fa732b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8c760ae98e855ef8ba9c976fa732b5">&#9670;&nbsp;</a></span>s_blockSizeLookup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const std::uint8_t playrho::s_blockSizeLookup[<a class="el" href="classplayrho_1_1BlockAllocator.html#a2845e1a67f12b93c3bd543e72f6655f0">BlockAllocator::GetMaxBlockSize</a>()+1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    0,</div><div class="line">    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div><div class="line">    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, </div><div class="line">    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, </div><div class="line">    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, </div><div class="line">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, </div><div class="line">    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, </div><div class="line">    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, </div><div class="line">    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, </div><div class="line">    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, </div><div class="line">    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, </div><div class="line">    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, </div><div class="line">    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, </div><div class="line">    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, </div><div class="line">    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, </div><div class="line">    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, </div><div class="line">    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, </div><div class="line">    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, </div><div class="line">    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, </div><div class="line">    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, </div><div class="line">    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, </div><div class="line">    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, </div><div class="line">}</div></div><!-- fragment -->
<p>Block size lookup array. </p>

</div>
</div>
<a id="a4398b65ad858db7f77516a968f8443ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4398b65ad858db7f77516a968f8443ce">&#9670;&nbsp;</a></span>SquareRootTwo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLAYRHO_CONSTEXPR const auto playrho::SquareRootTwo</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1.414213562373095048801688724209698078569671875376948073176679737990732478462)</div><div class="ttc" id="namespaceplayrho_html_a1fc125070a08100d083a1360f7167f87"><div class="ttname"><a href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">playrho::Real</a></div><div class="ttdeci">float Real</div><div class="ttdoc">Real-number type. </div><div class="ttdef"><b>Definition:</b> Real.hpp:69</div></div>
</div><!-- fragment -->
<p>Square root of two. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Square_root_of_2">https://en.wikipedia.org/wiki/Square_root_of_2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html#a77506b9b17fd73a6f0815745e69442bf">playrho::d2::UnitVec::GetBottomRight()</a>, and <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html#a159ff90e97e95537fee99a49a8355443">playrho::d2::UnitVec::GetTopRight()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceplayrho.html">playrho</a></li>
    <li class="footer">Generated on Sun Feb 4 2018 11:20:29 for PlayRho by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
