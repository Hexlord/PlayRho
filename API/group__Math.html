<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: Mathematical Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A Real-Time-Oriented 2-D Physics Engine and Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mathematical Functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for common mathematical operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9cf6fb58c36515834217c6b150b43772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9cf6fb58c36515834217c6b150b43772"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga9cf6fb58c36515834217c6b150b43772">playrho::Secant</a> (T target, U a1, T s1, U a2, T s2) noexcept</td></tr>
<tr class="memdesc:ga9cf6fb58c36515834217c6b150b43772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant method.  <a href="group__Math.html#ga9cf6fb58c36515834217c6b150b43772">More...</a><br /></td></tr>
<tr class="separator:ga9cf6fb58c36515834217c6b150b43772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8ccc71ac7ccd063fd81a31d78c3d2c90">playrho::Bisect</a> (T a1, T a2) noexcept</td></tr>
<tr class="memdesc:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection method.  <a href="group__Math.html#ga8ccc71ac7ccd063fd81a31d78c3d2c90">More...</a><br /></td></tr>
<tr class="separator:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76721557b2b677d24efa2d0415954be5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga76721557b2b677d24efa2d0415954be5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga76721557b2b677d24efa2d0415954be5">playrho::IsOdd</a> (T val) noexcept</td></tr>
<tr class="memdesc:ga76721557b2b677d24efa2d0415954be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-odd.  <a href="group__Math.html#ga76721557b2b677d24efa2d0415954be5">More...</a><br /></td></tr>
<tr class="separator:ga76721557b2b677d24efa2d0415954be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplParams" colspan="2"><a id="ga948ebcbc9ef959d24546e6c8ff848fa6"></a>
template&lt;class TYPE &gt; </td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga948ebcbc9ef959d24546e6c8ff848fa6">playrho::Square</a> (TYPE t) noexcept</td></tr>
<tr class="memdesc:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1986d73d7ab9af67055c652b03bf8c7e"><td class="memTemplParams" colspan="2"><a id="ga1986d73d7ab9af67055c652b03bf8c7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1986d73d7ab9af67055c652b03bf8c7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1986d73d7ab9af67055c652b03bf8c7e">playrho::Sqrt</a> (T t)</td></tr>
<tr class="memdesc:ga1986d73d7ab9af67055c652b03bf8c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root's the given value. <br /></td></tr>
<tr class="separator:ga1986d73d7ab9af67055c652b03bf8c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf273e818412b015e0dc42775bd43d798"><td class="memTemplParams" colspan="2"><a id="gaf273e818412b015e0dc42775bd43d798"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf273e818412b015e0dc42775bd43d798"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaf273e818412b015e0dc42775bd43d798">playrho::Hypot</a> (T x, T y)</td></tr>
<tr class="memdesc:gaf273e818412b015e0dc42775bd43d798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares. <br /></td></tr>
<tr class="separator:gaf273e818412b015e0dc42775bd43d798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673e2c478136179b6d9cb480312066c2"><td class="memTemplParams" colspan="2"><a id="ga673e2c478136179b6d9cb480312066c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga673e2c478136179b6d9cb480312066c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga673e2c478136179b6d9cb480312066c2">playrho::IsNormal</a> (T arg)</td></tr>
<tr class="memdesc:ga673e2c478136179b6d9cb480312066c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given argument is normal. <br /></td></tr>
<tr class="separator:ga673e2c478136179b6d9cb480312066c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95558a2405348366d0c9c6babc3150b6"><td class="memTemplParams" colspan="2"><a id="ga95558a2405348366d0c9c6babc3150b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga95558a2405348366d0c9c6babc3150b6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga95558a2405348366d0c9c6babc3150b6">playrho::IsNan</a> (T arg)</td></tr>
<tr class="memdesc:ga95558a2405348366d0c9c6babc3150b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is not-a-number. <br /></td></tr>
<tr class="separator:ga95558a2405348366d0c9c6babc3150b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b56379b5919e634170db3899214703"><td class="memTemplParams" colspan="2"><a id="gad2b56379b5919e634170db3899214703"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad2b56379b5919e634170db3899214703"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gad2b56379b5919e634170db3899214703">playrho::IsFinite</a> (T arg)</td></tr>
<tr class="memdesc:gad2b56379b5919e634170db3899214703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is finite. <br /></td></tr>
<tr class="separator:gad2b56379b5919e634170db3899214703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9ab3c52dabfe0014877b1fcd0334b1"><td class="memTemplParams" colspan="2"><a id="ga7c9ab3c52dabfe0014877b1fcd0334b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7c9ab3c52dabfe0014877b1fcd0334b1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga7c9ab3c52dabfe0014877b1fcd0334b1">playrho::Round</a> (T arg)</td></tr>
<tr class="memdesc:ga7c9ab3c52dabfe0014877b1fcd0334b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the given value. <br /></td></tr>
<tr class="separator:ga7c9ab3c52dabfe0014877b1fcd0334b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8269d6923a53d9e03799bb44ecd6e4bf"><td class="memTemplParams" colspan="2"><a id="ga8269d6923a53d9e03799bb44ecd6e4bf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8269d6923a53d9e03799bb44ecd6e4bf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8269d6923a53d9e03799bb44ecd6e4bf">playrho::Trunc</a> (T arg)</td></tr>
<tr class="memdesc:ga8269d6923a53d9e03799bb44ecd6e4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the given value. <br /></td></tr>
<tr class="separator:ga8269d6923a53d9e03799bb44ecd6e4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869562cdc908a0f9fc3e7951049e7711"><td class="memTemplParams" colspan="2"><a id="ga869562cdc908a0f9fc3e7951049e7711"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga869562cdc908a0f9fc3e7951049e7711"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga869562cdc908a0f9fc3e7951049e7711">playrho::SignBit</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga869562cdc908a0f9fc3e7951049e7711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value is negative. <br /></td></tr>
<tr class="separator:ga869562cdc908a0f9fc3e7951049e7711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9018daeae722906ac9c42abd81eb7ffa"><td class="memTemplParams" colspan="2"><a id="ga9018daeae722906ac9c42abd81eb7ffa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9018daeae722906ac9c42abd81eb7ffa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga9018daeae722906ac9c42abd81eb7ffa">playrho::NextAfter</a> (T from, T to)</td></tr>
<tr class="memdesc:ga9018daeae722906ac9c42abd81eb7ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next representable value after the given from value and going towards the to value. <br /></td></tr>
<tr class="separator:ga9018daeae722906ac9c42abd81eb7ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0affb1e7e6c45dad2fd642fe3a0db5"><td class="memTemplParams" colspan="2"><a id="gada0affb1e7e6c45dad2fd642fe3a0db5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada0affb1e7e6c45dad2fd642fe3a0db5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gada0affb1e7e6c45dad2fd642fe3a0db5">playrho::Cos</a> (T arg)</td></tr>
<tr class="memdesc:gada0affb1e7e6c45dad2fd642fe3a0db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the argument. <br /></td></tr>
<tr class="separator:gada0affb1e7e6c45dad2fd642fe3a0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba92b4ce41fb2dc4ac3f3e15ba7576a"><td class="memTemplParams" colspan="2"><a id="gadba92b4ce41fb2dc4ac3f3e15ba7576a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadba92b4ce41fb2dc4ac3f3e15ba7576a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gadba92b4ce41fb2dc4ac3f3e15ba7576a">playrho::Sin</a> (T arg)</td></tr>
<tr class="memdesc:gadba92b4ce41fb2dc4ac3f3e15ba7576a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of the argument. <br /></td></tr>
<tr class="separator:gadba92b4ce41fb2dc4ac3f3e15ba7576a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">playrho::Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values.  <a href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">More...</a><br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memTemplParams" colspan="2"><a id="ga7b2db834a9d392a7e63660f5dca67c73"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga7b2db834a9d392a7e63660f5dca67c73">playrho::Average</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const T &gt; span)</td></tr>
<tr class="memdesc:ga7b2db834a9d392a7e63660f5dca67c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga7b2db834a9d392a7e63660f5dca67c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6acc32fa41f23f57847fe45878051d21"><td class="memTemplParams" colspan="2"><a id="ga6acc32fa41f23f57847fe45878051d21"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6acc32fa41f23f57847fe45878051d21"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga6acc32fa41f23f57847fe45878051d21">playrho::RoundOff</a> (T value, unsigned precision=100000)</td></tr>
<tr class="memdesc:ga6acc32fa41f23f57847fe45878051d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga6acc32fa41f23f57847fe45878051d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memItemLeft" align="right" valign="top"><a id="ga812ea5eaf66fb9d1bffa799886b2eee3"></a>
<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga812ea5eaf66fb9d1bffa799886b2eee3">playrho::RoundOff</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> value, std::uint32_t precision=100000)</td></tr>
<tr class="memdesc:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b729c7680b3baa4450ebdb434fab13"><td class="memItemLeft" align="right" valign="top"><a id="ga32b729c7680b3baa4450ebdb434fab13"></a>
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga32b729c7680b3baa4450ebdb434fab13">playrho::GetVec2</a> (const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> value)</td></tr>
<tr class="memdesc:ga32b729c7680b3baa4450ebdb434fab13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a Vec2 representation of the given value. <br /></td></tr>
<tr class="separator:ga32b729c7680b3baa4450ebdb434fab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb2b1127b68deb833762e6e57da8fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaedcb2b1127b68deb833762e6e57da8fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaedcb2b1127b68deb833762e6e57da8fa">playrho::AlmostZero</a> (T value)</td></tr>
<tr class="memdesc:gaedcb2b1127b68deb833762e6e57da8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group__Math.html#gaedcb2b1127b68deb833762e6e57da8fa">More...</a><br /></td></tr>
<tr class="separator:gaedcb2b1127b68deb833762e6e57da8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb59c71d84b1f4788dcc783afff36cc"><td class="memTemplParams" colspan="2"><a id="gabeb59c71d84b1f4788dcc783afff36cc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabeb59c71d84b1f4788dcc783afff36cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gabeb59c71d84b1f4788dcc783afff36cc">playrho::AlmostEqual</a> (T x, T y, int ulp=2)</td></tr>
<tr class="memdesc:gabeb59c71d84b1f4788dcc783afff36cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:gabeb59c71d84b1f4788dcc783afff36cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1e3299e5a7b20d8d77ab30505421ca3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae1e3299e5a7b20d8d77ab30505421ca3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gae1e3299e5a7b20d8d77ab30505421ca3">playrho::ModuloViaFmod</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:gae1e3299e5a7b20d8d77ab30505421ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using std::fmod.  <a href="group__Math.html#gae1e3299e5a7b20d8d77ab30505421ca3">More...</a><br /></td></tr>
<tr class="separator:gae1e3299e5a7b20d8d77ab30505421ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">playrho::ModuloViaTrunc</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using std::trunc.  <a href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">More...</a><br /></td></tr>
<tr class="separator:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a2abff11f978a8df25efbf0c10147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> value) noexcept</td></tr>
<tr class="memdesc:ga156a2abff11f978a8df25efbf0c10147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle.  <a href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">More...</a><br /></td></tr>
<tr class="separator:ga156a2abff11f978a8df25efbf0c10147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1b231481b1fb34bbd4742d5ba937bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gade1b231481b1fb34bbd4742d5ba937bd">playrho::GetNormalized</a> (const <a class="el" href="structplayrho_1_1Position.html">Position</a> &amp;val) noexcept</td></tr>
<tr class="memdesc:gade1b231481b1fb34bbd4742d5ba937bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" position.  <a href="group__Math.html#gade1b231481b1fb34bbd4742d5ba937bd">More...</a><br /></td></tr>
<tr class="separator:gade1b231481b1fb34bbd4742d5ba937bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b21383c1a73afea37f11e0ba906a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Sweep.html">Sweep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga09b21383c1a73afea37f11e0ba906a76">playrho::GetNormalized</a> (<a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> sweep) noexcept</td></tr>
<tr class="memdesc:ga09b21383c1a73afea37f11e0ba906a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a sweep with the given sweeps's angles normalized.  <a href="group__Math.html#ga09b21383c1a73afea37f11e0ba906a76">More...</a><br /></td></tr>
<tr class="separator:ga09b21383c1a73afea37f11e0ba906a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ac24431ece2665105981c22c6d7948"><td class="memItemLeft" align="right" valign="top"><a id="ga76ac24431ece2665105981c22c6d7948"></a>
<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga76ac24431ece2665105981c22c6d7948">playrho::GetAngle</a> (const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> value)</td></tr>
<tr class="memdesc:ga76ac24431ece2665105981c22c6d7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle of the given unit vector. <br /></td></tr>
<tr class="separator:ga76ac24431ece2665105981c22c6d7948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">playrho::GetAngle</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; value)</td></tr>
<tr class="memdesc:ga56785e4c60180ef416fe29f68ccf525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <a href="group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">More...</a><br /></td></tr>
<tr class="separator:ga56785e4c60180ef416fe29f68ccf525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1ac00e661c653f21ddbd0693bbb039ac">playrho::GetMagnitudeSquared</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the magnitude of the given iterable value.  <a href="group__Math.html#ga1ac00e661c653f21ddbd0693bbb039ac">More...</a><br /></td></tr>
<tr class="separator:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">playrho::GetMagnitude</a> (T value)</td></tr>
<tr class="memdesc:ga85c114f129eeee63e60ec7d4703bbd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the magnitude of the given value.  <a href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">More...</a><br /></td></tr>
<tr class="separator:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga451c8554a408d41df85a41650e0ada93">playrho::Dot</a> (const T1 a, const T2 b) noexcept</td></tr>
<tr class="memdesc:ga451c8554a408d41df85a41650e0ada93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <a href="group__Math.html#ga451c8554a408d41df85a41650e0ada93">More...</a><br /></td></tr>
<tr class="separator:ga451c8554a408d41df85a41650e0ada93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804d55e7545685ee9841c239bdac7c8f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size&lt; T1 &gt;::value==2 &amp;&amp;std::tuple_size&lt; T2 &gt;::value==2, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga804d55e7545685ee9841c239bdac7c8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga804d55e7545685ee9841c239bdac7c8f">playrho::Cross</a> (T1 a, T2 b) noexcept</td></tr>
<tr class="memdesc:ga804d55e7545685ee9841c239bdac7c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-element analog of the cross product of two vectors.  <a href="group__Math.html#ga804d55e7545685ee9841c239bdac7c8f">More...</a><br /></td></tr>
<tr class="separator:ga804d55e7545685ee9841c239bdac7c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3846333746b73978c91e250c6f239ce3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3846333746b73978c91e250c6f239ce3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3846333746b73978c91e250c6f239ce3">playrho::Solve</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; b) noexcept</td></tr>
<tr class="memdesc:ga3846333746b73978c91e250c6f239ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga3846333746b73978c91e250c6f239ce3">More...</a><br /></td></tr>
<tr class="separator:ga3846333746b73978c91e250c6f239ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplParams" colspan="2"><a id="ga00cc9646bab6ce84d6b4704f8c1e0ade"></a>
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga00cc9646bab6ce84d6b4704f8c1e0ade">playrho::Invert</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; IN_TYPE &gt; value) noexcept</td></tr>
<tr class="memdesc:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4795a90a377c5335ce5b1900caf6d24"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">playrho::Solve33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:gab4795a90a377c5335ce5b1900caf6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">More...</a><br /></td></tr>
<tr class="separator:gab4795a90a377c5335ce5b1900caf6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0a0606abee6bd0cc122578a2a640f044">playrho::Solve22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const T b) noexcept</td></tr>
<tr class="memdesc:ga0a0606abee6bd0cc122578a2a640f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga0a0606abee6bd0cc122578a2a640f044">More...</a><br /></td></tr>
<tr class="separator:ga0a0606abee6bd0cc122578a2a640f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaeaceaa1218e1f86e27e6678db247bc79">playrho::GetInverse22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gaeaceaa1218e1f86e27e6678db247bc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <a href="group__Math.html#gaeaceaa1218e1f86e27e6678db247bc79">More...</a><br /></td></tr>
<tr class="separator:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a513e105038f6425bfc83180a69cd3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae7a513e105038f6425bfc83180a69cd3">playrho::GetSymInverse33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gae7a513e105038f6425bfc83180a69cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <a href="group__Math.html#gae7a513e105038f6425bfc83180a69cd3">More...</a><br /></td></tr>
<tr class="separator:gae7a513e105038f6425bfc83180a69cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga6aa0aece94173885da01b5e3a6737af7">playrho::GetRevPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga6aa0aece94173885da01b5e3a6737af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.  <a href="group__Math.html#ga6aa0aece94173885da01b5e3a6737af7">More...</a><br /></td></tr>
<tr class="separator:ga6aa0aece94173885da01b5e3a6737af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga87b57d633b625c58f9200a201e4664a7">playrho::GetFwdPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga87b57d633b625c58f9200a201e4664a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.  <a href="group__Math.html#ga87b57d633b625c58f9200a201e4664a7">More...</a><br /></td></tr>
<tr class="separator:ga87b57d633b625c58f9200a201e4664a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb719b00fc92c4e84de7115834c745d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0fb719b00fc92c4e84de7115834c745d">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga0fb719b00fc92c4e84de7115834c745d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another.  <a href="group__Math.html#ga0fb719b00fc92c4e84de7115834c745d">More...</a><br /></td></tr>
<tr class="separator:ga0fb719b00fc92c4e84de7115834c745d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memItemLeft" align="right" valign="top"><a id="ga819a9ef6f9c3d492b5177ca25077618e"></a>
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga819a9ef6f9c3d492b5177ca25077618e">playrho::InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga819a9ef6f9c3d492b5177ca25077618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform). <br /></td></tr>
<tr class="separator:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab34a9d610d4a68c5ad673caa438f33c"><td class="memTemplParams" colspan="2"><a id="gaab34a9d610d4a68c5ad673caa438f33c"></a>
template&lt;class T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:gaab34a9d610d4a68c5ad673caa438f33c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaab34a9d610d4a68c5ad673caa438f33c">playrho::operator*</a> (<a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; s, <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> u) noexcept</td></tr>
<tr class="memdesc:gaab34a9d610d4a68c5ad673caa438f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:gaab34a9d610d4a68c5ad673caa438f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c751a02e23112ef67abb20f8660ed8"><td class="memTemplParams" colspan="2"><a id="ga95c751a02e23112ef67abb20f8660ed8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga95c751a02e23112ef67abb20f8660ed8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga95c751a02e23112ef67abb20f8660ed8">playrho::operator*</a> (const T s, const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> u) noexcept</td></tr>
<tr class="memdesc:ga95c751a02e23112ef67abb20f8660ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:ga95c751a02e23112ef67abb20f8660ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8d2e8c4f2e3e38083948152e909f7b"><td class="memTemplParams" colspan="2"><a id="ga0c8d2e8c4f2e3e38083948152e909f7b"></a>
template&lt;class T , LoValueCheck lo, HiValueCheck hi&gt; </td></tr>
<tr class="memitem:ga0c8d2e8c4f2e3e38083948152e909f7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0c8d2e8c4f2e3e38083948152e909f7b">playrho::operator*</a> (<a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> u, <a class="el" href="classplayrho_1_1BoundedValue.html">BoundedValue</a>&lt; T, lo, hi &gt; s) noexcept</td></tr>
<tr class="memdesc:ga0c8d2e8c4f2e3e38083948152e909f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:ga0c8d2e8c4f2e3e38083948152e909f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24be09e8489f1a675a59e5a3510f6fce"><td class="memTemplParams" colspan="2"><a id="ga24be09e8489f1a675a59e5a3510f6fce"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga24be09e8489f1a675a59e5a3510f6fce"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga24be09e8489f1a675a59e5a3510f6fce">playrho::operator*</a> (const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> u, const T s) noexcept</td></tr>
<tr class="memdesc:ga24be09e8489f1a675a59e5a3510f6fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:ga24be09e8489f1a675a59e5a3510f6fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e6519bbead1fc1cf08300b7e35e8f5"><td class="memItemLeft" align="right" valign="top"><a id="gae7e6519bbead1fc1cf08300b7e35e8f5"></a>
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae7e6519bbead1fc1cf08300b7e35e8f5">playrho::operator/</a> (const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> u, const <a class="el" href="classplayrho_1_1UnitVec2.html#ab21b256a14b20403a84ed7d33dde9733">UnitVec2::value_type</a> s) noexcept</td></tr>
<tr class="memdesc:gae7e6519bbead1fc1cf08300b7e35e8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:gae7e6519bbead1fc1cf08300b7e35e8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7fc7e2730184d22b620c4f1f607611"><td class="memItemLeft" align="right" valign="top"><a id="gaca7fc7e2730184d22b620c4f1f607611"></a>
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaca7fc7e2730184d22b620c4f1f607611">playrho::Mul</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gaca7fc7e2730184d22b620c4f1f607611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A * B. <br /></td></tr>
<tr class="separator:gaca7fc7e2730184d22b620c4f1f607611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471bae6413067374ab8d8262533e402"><td class="memItemLeft" align="right" valign="top"><a id="gab471bae6413067374ab8d8262533e402"></a>
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gab471bae6413067374ab8d8262533e402">playrho::MulT</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gab471bae6413067374ab8d8262533e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:gab471bae6413067374ab8d8262533e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a09da0dbd8012afafebfae98e6ed44f"><td class="memItemLeft" align="right" valign="top"><a id="ga3a09da0dbd8012afafebfae98e6ed44f"></a>
constexpr <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3a09da0dbd8012afafebfae98e6ed44f">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> &amp;v, const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga3a09da0dbd8012afafebfae98e6ed44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix by a vector. <br /></td></tr>
<tr class="separator:ga3a09da0dbd8012afafebfae98e6ed44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894bcf52e04e21184227d1f872b9fd1c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga894bcf52e04e21184227d1f872b9fd1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga894bcf52e04e21184227d1f872b9fd1c">playrho::Rotate</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; vector, const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga894bcf52e04e21184227d1f872b9fd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a vector by a given angle.  <a href="group__Math.html#ga894bcf52e04e21184227d1f872b9fd1c">More...</a><br /></td></tr>
<tr class="separator:ga894bcf52e04e21184227d1f872b9fd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999a90fd3cc89960c512bbc00c37aab7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga999a90fd3cc89960c512bbc00c37aab7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga999a90fd3cc89960c512bbc00c37aab7">playrho::InverseRotate</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; vector, const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga999a90fd3cc89960c512bbc00c37aab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse rotates a vector.  <a href="group__Math.html#ga999a90fd3cc89960c512bbc00c37aab7">More...</a><br /></td></tr>
<tr class="separator:ga999a90fd3cc89960c512bbc00c37aab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f66519396d97c2588561efa6459dd6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae6f66519396d97c2588561efa6459dd6">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> v, const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> xfm) noexcept</td></tr>
<tr class="memdesc:gae6f66519396d97c2588561efa6459dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given 2-D vector with the given transformation.  <a href="group__Math.html#gae6f66519396d97c2588561efa6459dd6">More...</a><br /></td></tr>
<tr class="separator:gae6f66519396d97c2588561efa6459dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1866cb856a308673d77fe28ff1657b60"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1866cb856a308673d77fe28ff1657b60">playrho::InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> v, const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> T) noexcept</td></tr>
<tr class="memdesc:ga1866cb856a308673d77fe28ff1657b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse transforms the given 2-D vector with the given transformation.  <a href="group__Math.html#ga1866cb856a308673d77fe28ff1657b60">More...</a><br /></td></tr>
<tr class="separator:ga1866cb856a308673d77fe28ff1657b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76b0dc85088e062731fd7868aa78a57"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gad76b0dc85088e062731fd7868aa78a57">playrho::Mul</a> (const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;A, const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gad76b0dc85088e062731fd7868aa78a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a given transformation by another given transformation.  <a href="group__Math.html#gad76b0dc85088e062731fd7868aa78a57">More...</a><br /></td></tr>
<tr class="separator:gad76b0dc85088e062731fd7868aa78a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6af2739f6bfd0ec9d1e0824c960c3f6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaf6af2739f6bfd0ec9d1e0824c960c3f6">playrho::MulT</a> (const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;A, const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gaf6af2739f6bfd0ec9d1e0824c960c3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse multiplies a given transformation by another given transformation.  <a href="group__Math.html#gaf6af2739f6bfd0ec9d1e0824c960c3f6">More...</a><br /></td></tr>
<tr class="separator:gaf6af2739f6bfd0ec9d1e0824c960c3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memTemplParams" colspan="2"><a id="ga8c5b7f3e28aa844cad21eb801d081cd3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8c5b7f3e28aa844cad21eb801d081cd3">playrho::Abs</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> a)</td></tr>
<tr class="memdesc:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ga8c5b7f3e28aa844cad21eb801d081cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9842d9af8def4938c227e4256f42975"><td class="memTemplParams" colspan="2"><a id="gad9842d9af8def4938c227e4256f42975"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:gad9842d9af8def4938c227e4256f42975"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gad9842d9af8def4938c227e4256f42975">playrho::Abs</a> (<a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> a)</td></tr>
<tr class="memdesc:gad9842d9af8def4938c227e4256f42975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gad9842d9af8def4938c227e4256f42975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa726d0bc106afc7a490573f3d008f6bc"><td class="memItemLeft" align="right" valign="top"><a id="gaa726d0bc106afc7a490573f3d008f6bc"></a>
<a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaa726d0bc106afc7a490573f3d008f6bc">playrho::Abs</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A)</td></tr>
<tr class="memdesc:gaa726d0bc106afc7a490573f3d008f6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gaa726d0bc106afc7a490573f3d008f6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13603b635fc25d5299189e6eddf3816f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13603b635fc25d5299189e6eddf3816f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga13603b635fc25d5299189e6eddf3816f">playrho::Clamp</a> (T value, T low, T high) noexcept</td></tr>
<tr class="memdesc:ga13603b635fc25d5299189e6eddf3816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the given value within the given range (inclusive).  <a href="group__Math.html#ga13603b635fc25d5299189e6eddf3816f">More...</a><br /></td></tr>
<tr class="separator:ga13603b635fc25d5299189e6eddf3816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0ad2d1e2b11362e91193d313ee00e78c">playrho::NextPowerOfTwo</a> (std::uint64_t x)</td></tr>
<tr class="memdesc:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <a href="group__Math.html#ga0ad2d1e2b11362e91193d313ee00e78c">More...</a><br /></td></tr>
<tr class="separator:ga0ad2d1e2b11362e91193d313ee00e78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d83c58301aba934e46490f07d804645"><td class="memItemLeft" align="right" valign="top"><a id="ga4d83c58301aba934e46490f07d804645"></a>
constexpr <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga4d83c58301aba934e46490f07d804645">playrho::GetTransformation</a> (const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> ctr, const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> rot, const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> localCtr) noexcept</td></tr>
<tr class="memdesc:ga4d83c58301aba934e46490f07d804645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transformation for the given values. <br /></td></tr>
<tr class="separator:ga4d83c58301aba934e46490f07d804645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad266d117105c997e621bea7d99bbb06"><td class="memItemLeft" align="right" valign="top"><a id="gaad266d117105c997e621bea7d99bbb06"></a>
<a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaad266d117105c997e621bea7d99bbb06">playrho::GetTransformation</a> (const <a class="el" href="structplayrho_1_1Position.html">Position</a> pos, const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> local_ctr) noexcept</td></tr>
<tr class="memdesc:gaad266d117105c997e621bea7d99bbb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transformation for the given values. <br /></td></tr>
<tr class="separator:gaad266d117105c997e621bea7d99bbb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f84687cb6c4ceff5ff7f1ba75ab193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193">playrho::GetTransformation</a> (const <a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> &amp;sweep, const <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> beta) noexcept</td></tr>
<tr class="memdesc:ga78f84687cb6c4ceff5ff7f1ba75ab193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interpolated transform at a specific time.  <a href="group__Math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193">More...</a><br /></td></tr>
<tr class="separator:ga78f84687cb6c4ceff5ff7f1ba75ab193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6b905518bb8caf52657fe4289dc046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gacf6b905518bb8caf52657fe4289dc046">playrho::GetTransform0</a> (const <a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> &amp;sweep) noexcept</td></tr>
<tr class="memdesc:gacf6b905518bb8caf52657fe4289dc046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transform at "time" zero.  <a href="group__Math.html#gacf6b905518bb8caf52657fe4289dc046">More...</a><br /></td></tr>
<tr class="separator:gacf6b905518bb8caf52657fe4289dc046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacceda036ecb96e25642e2bd1d6fe9314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gacceda036ecb96e25642e2bd1d6fe9314">playrho::GetTransform1</a> (const <a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> &amp;sweep) noexcept</td></tr>
<tr class="memdesc:gacceda036ecb96e25642e2bd1d6fe9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transform at "time" one.  <a href="group__Math.html#gacceda036ecb96e25642e2bd1d6fe9314">More...</a><br /></td></tr>
<tr class="separator:gacceda036ecb96e25642e2bd1d6fe9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top"><a id="ga0c7d2525a406c1f83c0574e46a2cee32"></a>
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">playrho::Normalize</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056dae72feae97a9bcfd58c468be56df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">LinearVelocity2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga056dae72feae97a9bcfd58c468be56df">playrho::GetContactRelVelocity</a> (const <a class="el" href="structplayrho_1_1Velocity.html">Velocity</a> velA, const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> relA, const <a class="el" href="structplayrho_1_1Velocity.html">Velocity</a> velB, const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> relB) noexcept</td></tr>
<tr class="memdesc:ga056dae72feae97a9bcfd58c468be56df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contact relative velocity.  <a href="group__Math.html#ga056dae72feae97a9bcfd58c468be56df">More...</a><br /></td></tr>
<tr class="separator:ga056dae72feae97a9bcfd58c468be56df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769785f0540a4b8960b282f6b105c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">playrho::ComputeCentroid</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gae769785f0540a4b8960b282f6b105c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <a href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">More...</a><br /></td></tr>
<tr class="separator:gae769785f0540a4b8960b282f6b105c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memTemplParams" colspan="2"><a id="gaf9689e93a5538424dfb54bbbb78ad217"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaf9689e93a5538424dfb54bbbb78ad217">playrho::GetModuloNext</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:gaf9689e93a5538424dfb54bbbb78ad217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value. <br /></td></tr>
<tr class="separator:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e627f196ec102af9dd855d05611a6e"><td class="memTemplParams" colspan="2"><a id="ga37e627f196ec102af9dd855d05611a6e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37e627f196ec102af9dd855d05611a6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga37e627f196ec102af9dd855d05611a6e">playrho::GetModuloPrev</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:ga37e627f196ec102af9dd855d05611a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value. <br /></td></tr>
<tr class="separator:ga37e627f196ec102af9dd855d05611a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c036532db1260373b97c1d85360894c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8c036532db1260373b97c1d85360894c">playrho::GetDelta</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga8c036532db1260373b97c1d85360894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest angular distance to go from angle 1 to angle 2.  <a href="group__Math.html#ga8c036532db1260373b97c1d85360894c">More...</a><br /></td></tr>
<tr class="separator:ga8c036532db1260373b97c1d85360894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dcf271b85b501cd2d7188902066e55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga07dcf271b85b501cd2d7188902066e55">playrho::GetRevRotationalAngle</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga07dcf271b85b501cd2d7188902066e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#ga07dcf271b85b501cd2d7188902066e55">More...</a><br /></td></tr>
<tr class="separator:ga07dcf271b85b501cd2d7188902066e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc6530d99418947b42485bded9915fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacdc6530d99418947b42485bded9915fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gacdc6530d99418947b42485bded9915fa">playrho::GetUnitVector</a> (<a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; value, <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> fallback=<a class="el" href="classplayrho_1_1UnitVec2.html#a2b7eb358d02072690a14ef4cbe2990ff">UnitVec2::GetDefaultFallback</a>())</td></tr>
<tr class="memdesc:gacdc6530d99418947b42485bded9915fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unit vector for the given value.  <a href="group__Math.html#gacdc6530d99418947b42485bded9915fa">More...</a><br /></td></tr>
<tr class="separator:gacdc6530d99418947b42485bded9915fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memItemLeft" align="right" valign="top"><a id="ga3b8e8abc999b0c63cf1921b0edcf0b36"></a>
std::vector&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3b8e8abc999b0c63cf1921b0edcf0b36">playrho::GetCircleVertices</a> (<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius, unsigned slices, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> start=0_deg, Real turns=Real{1})</td></tr>
<tr class="memdesc:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memItemLeft" align="right" valign="top"><a id="ga0eb57dabfe8d3db9e509a6b493173358"></a>
<a class="el" href="group__BoundedAliases.html#gafc08c4f8490a39cbd018110ec9e5aa33">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0eb57dabfe8d3db9e509a6b493173358">playrho::GetAreaOfCircle</a> (<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius)</td></tr>
<tr class="memdesc:ga0eb57dabfe8d3db9e509a6b493173358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a cirlce. <br /></td></tr>
<tr class="separator:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118f8284073d2638e48ef8f13177e1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__BoundedAliases.html#gafc08c4f8490a39cbd018110ec9e5aa33">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">playrho::GetAreaOfPolygon</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga118f8284073d2638e48ef8f13177e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <a href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">More...</a><br /></td></tr>
<tr class="separator:ga118f8284073d2638e48ef8f13177e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#ga84a494e0a8763db409c32bde53324b06">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">playrho::GetPolarMoment</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <a href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">More...</a><br /></td></tr>
<tr class="separator:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b21383c1a73afea37f11e0ba906a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Sweep.html">Sweep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga09b21383c1a73afea37f11e0ba906a76">GetNormalized</a> (<a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> sweep) noexcept</td></tr>
<tr class="memdesc:ga09b21383c1a73afea37f11e0ba906a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a sweep with the given sweeps's angles normalized.  <a href="#ga09b21383c1a73afea37f11e0ba906a76">More...</a><br /></td></tr>
<tr class="separator:ga09b21383c1a73afea37f11e0ba906a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for common mathematical operations. </p>
<p>These are non-member non-friend functions for mathematical operations especially those with mixed input and output types. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaedcb2b1127b68deb833762e6e57da8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcb2b1127b68deb833762e6e57da8fa">&#9670;&nbsp;</a></span>AlmostZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, bool&gt;::type playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether a given value is almost zero. </p>
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab870a9188fcc77c905807fa718a8268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab870a9188fcc77c905807fa718a8268d">&#9670;&nbsp;</a></span>Atan2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::Atan2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc-tangent of the given y and x values. </p>
<dl class="section return"><dt>Returns</dt><dd>Normalized angle - an angle between -Pi and Pi inclusively. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/numeric/math/atan2">http://en.cppreference.com/w/cpp/numeric/math/atan2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga76ac24431ece2665105981c22c6d7948">playrho::GetAngle()</a>.</p>

</div>
</div>
<a id="ga8ccc71ac7ccd063fd81a31d78c3d2c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccc71ac7ccd063fd81a31d78c3d2c90">&#9670;&nbsp;</a></span>Bisect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Bisect </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bisection method. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Bisection_method">https://en.wikipedia.org/wiki/Bisection_method</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#acad38ef6ac1537641203f3eb15225235">playrho::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="ga13603b635fc25d5299189e6eddf3816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13603b635fc25d5299189e6eddf3816f">&#9670;&nbsp;</a></span>Clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamps the given value within the given range (inclusive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to clamp. </td></tr>
    <tr><td class="paramname">low</td><td>Lowest value to return or NaN to keep the low-end unbounded. </td></tr>
    <tr><td class="paramname">high</td><td>Highest value to return or NaN to keep the high-end unbounded. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1RopeJoint.html#a0753352f143b872d629f9cd780bc9e68">playrho::RopeJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#aaae0fdf05f7ebef72e958aa8919bed82">playrho::DistanceJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#a6d138a41b46dd4bf08f6197da6e83e86">playrho::PrismaticJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#a8aa84707f3971ce7bb60097465c9abd4">playrho::RevoluteJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#a52645f7db87f606b7d01e402295f4a26">playrho::FrictionJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#ab3acf9e00b50ba7a5c7ab0a065b76dda">playrho::MotorJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a9aa91b7a7a4dfa54dbdea4f5d47144c3">playrho::WheelJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#af4b715b541f5ad41fbb568d893c7b2c5">playrho::PrismaticJoint::SolveVelocityConstraints()</a>, and <a class="el" href="classplayrho_1_1RevoluteJoint.html#a59b88398432043019e0ca598aa3ff6fc">playrho::RevoluteJoint::SolveVelocityConstraints()</a>.</p>

</div>
</div>
<a id="gae769785f0540a4b8960b282f6b105c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae769785f0540a4b8960b282f6b105c14">&#9670;&nbsp;</a></span>ComputeCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> playrho::ComputeCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid of a counter-clockwise array of 3 or more vertices. </p>
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if there are less than 3 vertices or the vertices don't go counter-clockwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1PolygonShape.html#a0482e18f3f8759c35388688aed5154f5">playrho::PolygonShape::Set()</a>.</p>

</div>
</div>
<a id="ga804d55e7545685ee9841c239bdac7c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804d55e7545685ee9841c239bdac7c8f">&#9670;&nbsp;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size&lt; T1 &gt;::value==2 &amp;&amp;std::tuple_size&lt; T2 &gt;::value==2, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Cross </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the 2-element analog of the cross product of two vectors. </p>
<p>Cross-products the given two values.</p>
<p>Defined as the result of: <code>(a.x * b.y) - (a.y * b.x)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is dimension squashing. I.e. A cross of a 2-D length by a 2-D unit vector results in a 1-D length value. </dd>
<dd>
The unit of the result is the 1-D product of the inputs. </dd>
<dd>
This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd>
<dd>
The result will be 0 if any of the following are true: vector A or vector B has a length of zero; vectors A and B point in the same direction; or vectors A and B point in exactly opposite direction of each other. </dd>
<dd>
The result will be positive if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of greater than 0 and less than 180 degrees (counter-clockwise from A being a positive angle). </dd>
<dd>
Result will be negative if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of less than 0 and greater than -180 degrees (clockwise from A being a negative angle). </dd>
<dd>
The absolute value of the result is the area of the parallelogram formed by the vectors A and B.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value A of a 2-element type. </td></tr>
    <tr><td class="paramname">b</td><td>Value B of a 2-element type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value A of a 3-element type. </td></tr>
    <tr><td class="paramname">b</td><td>Value B of a 3-element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two values. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a0b21a34b270ecd1ad966a293ba681bc5">playrho::ApplyForce()</a>, <a class="el" href="namespaceplayrho.html#a07f50b8133debf454d50f491d196dc24">playrho::ApplyLinearImpulse()</a>, <a class="el" href="classplayrho_1_1Simplex.html#a59fece7b429a7012a6009e7cc2e19fa7">playrho::Simplex::CalcMetric()</a>, <a class="el" href="classplayrho_1_1Simplex.html#ab6a1b7d57bde90877214bff9d8d71b48">playrho::Simplex::CalcSearchDirection()</a>, <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">playrho::ComputeCentroid()</a>, <a class="el" href="classplayrho_1_1Simplex.html#ae184255348982095084062a7cdd3b983">playrho::Simplex::Get()</a>, <a class="el" href="namespaceplayrho.html#a0cff60d0baa3e545629bd9dc91256762">playrho::GetConvexHullAsVector()</a>, <a class="el" href="namespaceplayrho.html#aa9b84c6dd6e381916012c70abcef9132">playrho::GetMassData()</a>, <a class="el" href="classplayrho_1_1VelocityConstraint.html#ab6c3ee90252f1329a2126f6bdd966014">playrho::VelocityConstraint::GetPoint()</a>, <a class="el" href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">playrho::GetPolarMoment()</a>, <a class="el" href="group__Math.html#gae7a513e105038f6425bfc83180a69cd3">playrho::GetSymInverse33()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#ab38d5b1be2fa8c6a05ae5bf02f6c7932">playrho::FrictionJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WeldJoint.html#a9b45158543eb8a7088d3f21f4e313b67">playrho::WeldJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#acd94fcbcef70709e32bede3fd55be593">playrho::RopeJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#a78e7e25eab45e75f897ed19c38743401">playrho::PulleyJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#a095885c8c90e9f82d2f525b1debc2835">playrho::MotorJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#a3973856f2b8ccefad127d829e1ccb302">playrho::DistanceJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MouseJoint.html#ae80012204f951d3147d0c1fccd669f7a">playrho::MouseJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a7a26e97c6abcbf17a22647a856101236">playrho::WheelJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#ae4c8524060c5ec7235767fc35d97a4df">playrho::PrismaticJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#ab17f18569ada37b4f107932ce849bd06">playrho::RevoluteJoint::InitVelocityConstraints()</a>, <a class="el" href="group__Math.html#ga00cc9646bab6ce84d6b4704f8c1e0ade">playrho::Invert()</a>, <a class="el" href="group__RayCastGroup.html#gabc2e992343e201f48c1956753a530247">playrho::RayCast()</a>, <a class="el" href="namespaceplayrho.html#a8a2c515bee211ab828b8d36ba80dc149">playrho::SetForce()</a>, <a class="el" href="group__Math.html#ga3846333746b73978c91e250c6f239ce3">playrho::Solve()</a>, <a class="el" href="group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">playrho::Solve33()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#a0753352f143b872d629f9cd780bc9e68">playrho::RopeJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1WeldJoint.html#a99e2af4d15574d310e13b3a7f28ed3e3">playrho::WeldJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#abff2e18760b22a8fda48627f908fda46">playrho::PulleyJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#aaae0fdf05f7ebef72e958aa8919bed82">playrho::DistanceJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a16e9ec84252c36fb24c9a87961620e96">playrho::WheelJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#a6d138a41b46dd4bf08f6197da6e83e86">playrho::PrismaticJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#a8aa84707f3971ce7bb60097465c9abd4">playrho::RevoluteJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#a52645f7db87f606b7d01e402295f4a26">playrho::FrictionJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#a7e7affd8bc323c2832b63a0f7a3d4380">playrho::RopeJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WeldJoint.html#a43a8a19b85cc0463938fdc57375adeb7">playrho::WeldJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#a02c113eca1dae0430c2bbcf0ae732a3d">playrho::PulleyJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#ab3acf9e00b50ba7a5c7ab0a065b76dda">playrho::MotorJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#ae1caf6f17b907eaee4503654cc5c3d2f">playrho::DistanceJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MouseJoint.html#a5262f70a2f2d296a5c9bbb6fffbd69cb">playrho::MouseJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#a59b88398432043019e0ca598aa3ff6fc">playrho::RevoluteJoint::SolveVelocityConstraints()</a>, and <a class="el" href="namespaceplayrho.html#a4d2196055fbb200dbd8a8630e7d14ae9">playrho::Validate()</a>.</p>

</div>
</div>
<a id="ga451c8554a408d41df85a41650e0ada93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451c8554a408d41df85a41650e0ada93">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Dot </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the dot product on two vectors (A and B). </p>
<p>The dot product of two vectors is defined as: the magnitude of vector A, multiplied by, the magnitude of vector B, multiplied by, the cosine of the angle between the two vectors (A and B). Thus the dot product of two vectors is a value ranging between plus and minus the magnitudes of each vector times each other. The middle value of 0 indicates that two vectors are perpendicular to each other (at an angle of +/- 90 degrees from each other).</p>
<dl class="section note"><dt>Note</dt><dd>This operation is commutative. I.e. Dot(a, b) == Dot(b, a). </dd>
<dd>
If A and B are the same vectors, GetMagnitudeSquared(Vec2) returns the same value using effectively one less input parameter. </dd>
<dd>
This is similar to the <code>std::inner_product</code> standard library algorithm except benchmark tests suggest this implementation is faster at least for <code>Vec2</code> like instances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> A. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors (0 means the two vectors are perpendicular). </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a0182bc2e0465762b01f37de17b43a607">playrho::ClipSegmentToLine()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a45eafe957d5e21a37daf453f9b114163">playrho::SeparationFinder::EvaluateForFaceA()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a375b7881a41af8ea83efe0c8b3f9b3e6">playrho::SeparationFinder::EvaluateForFaceB()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a9ba9206796d18be4fb7451cbef09338a">playrho::SeparationFinder::EvaluateForPoints()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a8a17c3a10337c840c928f5c750c07c4a">playrho::SeparationFinder::FindMinSeparationForFaceA()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a38701a732aa40dc5c70970b122382cb3">playrho::SeparationFinder::FindMinSeparationForFaceB()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a6f82f0e62d89781e6488ddc093c275ff">playrho::SeparationFinder::FindMinSeparationForPoints()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#aecc1804bc7d37d3caf48181d46a38181">playrho::SeparationFinder::Get()</a>, <a class="el" href="classplayrho_1_1Simplex.html#a1e9bc4ff4fb2e08dc656ec80c1199e74">playrho::Simplex::Get()</a>, <a class="el" href="namespaceplayrho.html#a5a7670d3ce160acd59649d8fa877ae85">playrho::GetJointTranslation()</a>, <a class="el" href="namespaceplayrho.html#adcd27abba8be9fe2f9c2e02fa2bbcd86">playrho::GetLinearVelocity()</a>, <a class="el" href="namespaceplayrho.html#a4fdbdfa3b311c43f6811bb49f9865c34">playrho::GetMaxSeparation4x4()</a>, <a class="el" href="classplayrho_1_1VelocityConstraint.html#ab6c3ee90252f1329a2126f6bdd966014">playrho::VelocityConstraint::GetPoint()</a>, <a class="el" href="namespaceplayrho.html#a13e620b55097d3179e73ac14e5256591">playrho::GetSupportIndex()</a>, <a class="el" href="group__Math.html#gae7a513e105038f6425bfc83180a69cd3">playrho::GetSymInverse33()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a7a26e97c6abcbf17a22647a856101236">playrho::WheelJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#ae4c8524060c5ec7235767fc35d97a4df">playrho::PrismaticJoint::InitVelocityConstraints()</a>, <a class="el" href="group__Math.html#ga819a9ef6f9c3d492b5177ca25077618e">playrho::InverseTransform()</a>, <a class="el" href="group__Math.html#gab471bae6413067374ab8d8262533e402">playrho::MulT()</a>, <a class="el" href="namespaceplayrho.html#a6cabf3aac9e547fb7937275f50068381">playrho::RayCast()</a>, <a class="el" href="group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">playrho::Solve33()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a16e9ec84252c36fb24c9a87961620e96">playrho::WheelJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#a6d138a41b46dd4bf08f6197da6e83e86">playrho::PrismaticJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#a7e7affd8bc323c2832b63a0f7a3d4380">playrho::RopeJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1GearJoint.html#a940c64ac77816f70c0c4a768c31c0645">playrho::GearJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#a02c113eca1dae0430c2bbcf0ae732a3d">playrho::PulleyJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#ae1caf6f17b907eaee4503654cc5c3d2f">playrho::DistanceJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a9aa91b7a7a4dfa54dbdea4f5d47144c3">playrho::WheelJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#af4b715b541f5ad41fbb568d893c7b2c5">playrho::PrismaticJoint::SolveVelocityConstraints()</a>, and <a class="el" href="group__TestPointGroup.html#gac9da7b3dd9e1dc5532a0f3c47f31f22e">playrho::TestPoint()</a>.</p>

</div>
</div>
<a id="ga56785e4c60180ef416fe29f68ccf525a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56785e4c60180ef416fe29f68ccf525a">&#9670;&nbsp;</a></span>GetAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the angle. </p>
<dl class="section return"><dt>Returns</dt><dd>Angular value in the range of -Pi to +Pi radians. </dd></dl>

</div>
</div>
<a id="ga118f8284073d2638e48ef8f13177e1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118f8284073d2638e48ef8f13177e1d9">&#9670;&nbsp;</a></span>GetAreaOfPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BoundedAliases.html#gafc08c4f8490a39cbd018110ec9e5aa33">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt; playrho::GetAreaOfPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the area of a polygon. </p>
<dl class="section note"><dt>Note</dt><dd>This function is valid for any non-self-intersecting (simple) polygon, which can be convex or concave. </dd>
<dd>
Winding order doesn't matter. </dd></dl>

</div>
</div>
<a id="ga056dae72feae97a9bcfd58c468be56df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga056dae72feae97a9bcfd58c468be56df">&#9670;&nbsp;</a></span>GetContactRelVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">LinearVelocity2</a> playrho::GetContactRelVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Velocity.html">Velocity</a>&#160;</td>
          <td class="paramname"><em>velA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td>
          <td class="paramname"><em>relA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Velocity.html">Velocity</a>&#160;</td>
          <td class="paramname"><em>velB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td>
          <td class="paramname"><em>relB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the contact relative velocity. </p>
<dl class="section note"><dt>Note</dt><dd>If relA and relB are the zero vectors, the resulting value is simply velB.linear - velA.linear. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1VelocityConstraint.html#ab6c3ee90252f1329a2126f6bdd966014">playrho::VelocityConstraint::GetPoint()</a>.</p>

</div>
</div>
<a id="ga8c036532db1260373b97c1d85360894c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c036532db1260373b97c1d85360894c">&#9670;&nbsp;</a></span>GetDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the shortest angular distance to go from angle 1 to angle 2. </p>
<p>This gets the angle to rotate angle 1 by in order to get to angle 2 with the least amount of rotation. </p><dl class="section return"><dt>Returns</dt><dd>Angle between -Pi and Pi radians inclusively. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147" title="Gets the &quot;normalized&quot; value of the given angle. ">GetNormalized</a> </dd></dl>

</div>
</div>
<a id="ga87b57d633b625c58f9200a201e4664a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b57d633b625c58f9200a201e4664a7">&#9670;&nbsp;</a></span>GetFwdPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetFwdPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a vector clockwise (forward-clockwise) perpendicular to the given vector. </p>
<p>This takes a vector of form (x, y) and returns the vector (y, -x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> to return a clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga6aa0aece94173885da01b5e3a6737af7" title="Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector. ">GetRevPerpendicular</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1MultiShape.html#ab7257ed16b8f4534b29b39baf456e192">playrho::MultiShape::AddConvexHull()</a>, <a class="el" href="classplayrho_1_1Simplex.html#ab6a1b7d57bde90877214bff9d8d71b48">playrho::Simplex::CalcSearchDirection()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#aecc1804bc7d37d3caf48181d46a38181">playrho::SeparationFinder::Get()</a>, <a class="el" href="classplayrho_1_1VelocityConstraint.html#a18ef9652a325eb62a50b6010497458ee">playrho::VelocityConstraint::GetTangent()</a>, <a class="el" href="classplayrho_1_1EdgeShape.html#aafcf389f099bece8e2db6371effe6784">playrho::EdgeShape::Set()</a>, and <a class="el" href="classplayrho_1_1PolygonShape.html#a0482e18f3f8759c35388688aed5154f5">playrho::PolygonShape::Set()</a>.</p>

</div>
</div>
<a id="gaeaceaa1218e1f86e27e6678db247bc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaceaa1218e1f86e27e6678db247bc79">&#9670;&nbsp;</a></span>GetInverse22()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> playrho::GetInverse22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the inverse of the given matrix as a 2-by-2. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1WeldJoint.html#a9b45158543eb8a7088d3f21f4e313b67">playrho::WeldJoint::InitVelocityConstraints()</a>.</p>

</div>
</div>
<a id="ga85c114f129eeee63e60ec7d4703bbd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c114f129eeee63e60ec7d4703bbd65">&#9670;&nbsp;</a></span>GetMagnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::GetMagnitude </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the magnitude of the given value. </p>
<dl class="section note"><dt>Note</dt><dd>Works for any type for which <code>GetMagnitudeSquared</code> also works. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a6970aff5f3ad80147b55f36902039b4e">playrho::GetCentripetalForce()</a>, <a class="el" href="namespaceplayrho.html#a14a941545584e7cdd988f35be8cc0524">playrho::GetCurrentLengthA()</a>, <a class="el" href="namespaceplayrho.html#ae5523513c7bf6104e006be40abd13289">playrho::GetCurrentLengthB()</a>, <a class="el" href="namespaceplayrho.html#a5428024c9b1acdcad4f6a9d3373e7ff4">playrho::GetMassData()</a>, <a class="el" href="classplayrho_1_1ChainShape.html#aa82bf948a6cafb90a3e067660dfd0ad0">playrho::ChainShape::GetMassData()</a>, <a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">playrho::Normalize()</a>, and <a class="el" href="classplayrho_1_1WeldJoint.html#a99e2af4d15574d310e13b3a7f28ed3e3">playrho::WeldJoint::SolvePositionConstraints()</a>.</p>

</div>
</div>
<a id="ga1ac00e661c653f21ddbd0693bbb039ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ac00e661c653f21ddbd0693bbb039ac">&#9670;&nbsp;</a></span>GetMagnitudeSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetMagnitudeSquared </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the square of the magnitude of the given iterable value. </p>
<dl class="section note"><dt>Note</dt><dd>For performance, use this instead of <a class="el" href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65" title="Gets the magnitude of the given value. ">GetMagnitude(T value)</a> (if possible). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a532a2a6530a34432d28f6089193b2260">playrho::CalcGravitationalAcceleration()</a>, <a class="el" href="classplayrho_1_1Simplex.html#a59fece7b429a7012a6009e7cc2e19fa7">playrho::Simplex::CalcMetric()</a>, <a class="el" href="namespaceplayrho.html#ac0bed42717184a2866593f4c3a6bfedd">playrho::Distance()</a>, <a class="el" href="classplayrho_1_1VertexSet.html#a212158e5a9a9115b8dec75170e91c313">playrho::VertexSet::find()</a>, <a class="el" href="namespaceplayrho.html#afd5009f0701e56be66936edcd9308111">playrho::FindClosestBody()</a>, <a class="el" href="namespaceplayrho.html#a0cff60d0baa3e545629bd9dc91256762">playrho::GetConvexHullAsVector()</a>, <a class="el" href="namespaceplayrho.html#accc0736257251f381353661320af972e">playrho::GetLocalRotInertia()</a>, <a class="el" href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">playrho::GetMagnitude()</a>, <a class="el" href="namespaceplayrho.html#a3c96f9cde2662bc786f26a087a60ac4c">playrho::GetMassData()</a>, <a class="el" href="namespaceplayrho.html#acad38ef6ac1537641203f3eb15225235">playrho::GetToiViaSat()</a>, <a class="el" href="namespaceplayrho.html#a486a4af37125ad1fc95d541ff34f0321">playrho::GetVelocity()</a>, <a class="el" href="namespaceplayrho.html#a670476d4ad0d75a0c06dcd46972d3362">playrho::IsUnderActive()</a>, <a class="el" href="group__RayCastGroup.html#gab748de78383a93812c90af28af34e54a">playrho::RayCast()</a>, <a class="el" href="classplayrho_1_1Body.html#a1da721b67ed4d0643c9c20ce27ff8aa0">playrho::Body::ResetMassData()</a>, <a class="el" href="classplayrho_1_1Body.html#aa29406774e358385944e32900ad5d4b0">playrho::Body::SetMassData()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#a8aa84707f3971ce7bb60097465c9abd4">playrho::RevoluteJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#a52645f7db87f606b7d01e402295f4a26">playrho::FrictionJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#ab3acf9e00b50ba7a5c7ab0a065b76dda">playrho::MotorJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MouseJoint.html#a5262f70a2f2d296a5c9bbb6fffbd69cb">playrho::MouseJoint::SolveVelocityConstraints()</a>, <a class="el" href="namespaceplayrho.html#a8d206174a0c0100d2d9e8b3e31ef1c4d">playrho::TestOverlap()</a>, <a class="el" href="group__TestPointGroup.html#gac9da7b3dd9e1dc5532a0f3c47f31f22e">playrho::TestPoint()</a>, and <a class="el" href="classplayrho_1_1Contact.html#ad65d52220f396c191d2041558412580d">playrho::Contact::Update()</a>.</p>

</div>
</div>
<a id="ga156a2abff11f978a8df25efbf0c10147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156a2abff11f978a8df25efbf0c10147">&#9670;&nbsp;</a></span>GetNormalized() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the "normalized" value of the given angle. </p>
<dl class="section return"><dt>Returns</dt><dd>Angle between -Pi and Pi radians inclusively where 0 represents the positive X-axis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d" title="Computes the arc-tangent of the given y and x values. ">Atan2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a68f3d6b8ed4709b6b99bd8e096a9960e">playrho::CalcToi()</a>, <a class="el" href="group__Math.html#ga8c036532db1260373b97c1d85360894c">playrho::GetDelta()</a>, and <a class="el" href="group__Math.html#gade1b231481b1fb34bbd4742d5ba937bd">playrho::GetNormalized()</a>.</p>

</div>
</div>
<a id="gade1b231481b1fb34bbd4742d5ba937bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1b231481b1fb34bbd4742d5ba937bd">&#9670;&nbsp;</a></span>GetNormalized() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1Position.html">Position</a> playrho::GetNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the "normalized" position. </p>
<p>Enforces a wrap-around of one rotation on the angular position. </p><dl class="section note"><dt>Note</dt><dd>Use to prevent unbounded angles in positions. </dd></dl>

</div>
</div>
<a id="ga09b21383c1a73afea37f11e0ba906a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b21383c1a73afea37f11e0ba906a76">&#9670;&nbsp;</a></span>GetNormalized() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> GetNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Sweep.html">Sweep</a>&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a sweep with the given sweeps's angles normalized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> to return with its angles normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> with its pos0 angle to be between -2 pi and 2 pi and its pos1 angle reduced by the amount pos0's angle was reduced by. </dd></dl>

</div>
</div>
<a id="ga09b21383c1a73afea37f11e0ba906a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b21383c1a73afea37f11e0ba906a76">&#9670;&nbsp;</a></span>GetNormalized() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> GetNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Sweep.html">Sweep</a>&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a sweep with the given sweeps's angles normalized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> to return with its angles normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> with its pos0 angle to be between -2 pi and 2 pi and its pos1 angle reduced by the amount pos0's angle was reduced by. </dd></dl>

</div>
</div>
<a id="ga760adfdd1cb30bdae8cd37c1ae5da485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760adfdd1cb30bdae8cd37c1ae5da485">&#9670;&nbsp;</a></span>GetPolarMoment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#ga84a494e0a8763db409c32bde53324b06">SecondMomentOfArea</a> playrho::GetPolarMoment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the polar moment of the area enclosed by the given vertices. </p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if given collection has less than 3 vertices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Collection of three or more vertices. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a5428024c9b1acdcad4f6a9d3373e7ff4">playrho::GetMassData()</a>.</p>

</div>
</div>
<a id="ga6aa0aece94173885da01b5e3a6737af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa0aece94173885da01b5e3a6737af7">&#9670;&nbsp;</a></span>GetRevPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetRevPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector. </p>
<p>This takes a vector of form (x, y) and returns the vector (-y, x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> to return a counter-clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A counter-clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga87b57d633b625c58f9200a201e4664a7" title="Gets a vector clockwise (forward-clockwise) perpendicular to the given vector. ">GetFwdPerpendicular</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1Simplex.html#ab6a1b7d57bde90877214bff9d8d71b48">playrho::Simplex::CalcSearchDirection()</a>, <a class="el" href="group__Math.html#ga056dae72feae97a9bcfd58c468be56df">playrho::GetContactRelVelocity()</a>, <a class="el" href="namespaceplayrho.html#adcd27abba8be9fe2f9c2e02fa2bbcd86">playrho::GetLinearVelocity()</a>, <a class="el" href="namespaceplayrho.html#ab7217cc5275bc5d8c2f2407ee20fb958">playrho::GetLinearVelocityFromWorldPoint()</a>, <a class="el" href="namespaceplayrho.html#a5428024c9b1acdcad4f6a9d3373e7ff4">playrho::GetMassData()</a>, <a class="el" href="namespaceplayrho.html#a6cabf3aac9e547fb7937275f50068381">playrho::RayCast()</a>, <a class="el" href="classplayrho_1_1Body.html#a1da721b67ed4d0643c9c20ce27ff8aa0">playrho::Body::ResetMassData()</a>, <a class="el" href="classplayrho_1_1Body.html#aa29406774e358385944e32900ad5d4b0">playrho::Body::SetMassData()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#a52645f7db87f606b7d01e402295f4a26">playrho::FrictionJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#a7e7affd8bc323c2832b63a0f7a3d4380">playrho::RopeJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WeldJoint.html#a43a8a19b85cc0463938fdc57375adeb7">playrho::WeldJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#a02c113eca1dae0430c2bbcf0ae732a3d">playrho::PulleyJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#ab3acf9e00b50ba7a5c7ab0a065b76dda">playrho::MotorJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#ae1caf6f17b907eaee4503654cc5c3d2f">playrho::DistanceJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MouseJoint.html#a5262f70a2f2d296a5c9bbb6fffbd69cb">playrho::MouseJoint::SolveVelocityConstraints()</a>, and <a class="el" href="classplayrho_1_1RevoluteJoint.html#a59b88398432043019e0ca598aa3ff6fc">playrho::RevoluteJoint::SolveVelocityConstraints()</a>.</p>

</div>
</div>
<a id="ga07dcf271b85b501cd2d7188902066e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07dcf271b85b501cd2d7188902066e55">&#9670;&nbsp;</a></span>GetRevRotationalAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetRevRotationalAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2. </p>
<dl class="section return"><dt>Returns</dt><dd>Angular rotation in the counter clockwise direction to go from angle 1 to angle 2. </dd></dl>

</div>
</div>
<a id="gae7a513e105038f6425bfc83180a69cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a513e105038f6425bfc83180a69cd3">&#9670;&nbsp;</a></span>GetSymInverse33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> playrho::GetSymInverse33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the symmetric inverse of this matrix as a 3-by-3. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1WeldJoint.html#a9b45158543eb8a7088d3f21f4e313b67">playrho::WeldJoint::InitVelocityConstraints()</a>.</p>

</div>
</div>
<a id="gacf6b905518bb8caf52657fe4289dc046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6b905518bb8caf52657fe4289dc046">&#9670;&nbsp;</a></span>GetTransform0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> playrho::GetTransform0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the transform at "time" zero. </p>
<dl class="section note"><dt>Note</dt><dd>This is like calling GetTransformation(sweep, 0), except more efficiently. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193" title="Gets the interpolated transform at a specific time. ">GetTransformation(const Sweep&amp; sweep, Real beta)</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> data to get the transform from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structplayrho_1_1Transformation.html" title="Describes a geometric transformation. ">Transformation</a> of the given sweep at time zero. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1World.html#a184fb6c487005cc114adca655ea0a629">playrho::World::SetType()</a>, <a class="el" href="classplayrho_1_1World.html#a22920e520db8f1126a0258deef481d68">playrho::World::SolveReg()</a>, <a class="el" href="classplayrho_1_1World.html#ab5d1b082eee5d1073aaf6de06ae6e5b6">playrho::World::SolveToi()</a>, and <a class="el" href="classplayrho_1_1World.html#a69d27f52ea92dec4e2a6272f70c5cb47">playrho::World::SynchronizeProxies()</a>.</p>

</div>
</div>
<a id="gacceda036ecb96e25642e2bd1d6fe9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacceda036ecb96e25642e2bd1d6fe9314">&#9670;&nbsp;</a></span>GetTransform1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> playrho::GetTransform1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>sweep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the transform at "time" one. </p>
<dl class="section note"><dt>Note</dt><dd>This is like calling GetTransformation(sweep, 1.0), except more efficiently. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga78f84687cb6c4ceff5ff7f1ba75ab193" title="Gets the interpolated transform at a specific time. ">GetTransformation(const Sweep&amp; sweep, Real beta)</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> data to get the transform from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structplayrho_1_1Transformation.html" title="Describes a geometric transformation. ">Transformation</a> of the given sweep at time one. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1Body.html#a5c71a09cb25f1fc455554f3fa075a5c1">playrho::Body::Advance()</a>, and <a class="el" href="classplayrho_1_1BodyAtty.html#a0518361a2186b420db7f1a7d0584f7ba">playrho::BodyAtty::Restore()</a>.</p>

</div>
</div>
<a id="ga78f84687cb6c4ceff5ff7f1ba75ab193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f84687cb6c4ceff5ff7f1ba75ab193">&#9670;&nbsp;</a></span>GetTransformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> playrho::GetTransformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Sweep.html">Sweep</a> &amp;&#160;</td>
          <td class="paramname"><em>sweep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the interpolated transform at a specific time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sweep</td><td><a class="el" href="classplayrho_1_1Sweep.html" title="Description of a &quot;sweep&quot; of motion. ">Sweep</a> data to get the transform from. </td></tr>
    <tr><td class="paramname">beta</td><td>Time factor in [0,1], where 0 indicates alpha0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structplayrho_1_1Transformation.html" title="Describes a geometric transformation. ">Transformation</a> of the given sweep at the specified time. </dd></dl>

</div>
</div>
<a id="gacdc6530d99418947b42485bded9915fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc6530d99418947b42485bded9915fa">&#9670;&nbsp;</a></span>GetUnitVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> playrho::GetUnitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a>&#160;</td>
          <td class="paramname"><em>fallback</em> = <code><a class="el" href="classplayrho_1_1UnitVec2.html#a2b7eb358d02072690a14ef4cbe2990ff">UnitVec2::GetDefaultFallback</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the unit vector for the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to get the unit vector for. </td></tr>
    <tr><td class="paramname">fallback</td><td>Fallback unit vector value to use in case a unit vector can't effectively be calculated from the given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value divided by its length if length not almost zero otherwise invalid value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a6aaf4879371df30246226867c121a9ad" title="Determines whether the given two values are &quot;almost equal&quot;. ">AlmostEqual</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1MultiShape.html#ab7257ed16b8f4534b29b39baf456e192">playrho::MultiShape::AddConvexHull()</a>, <a class="el" href="namespaceplayrho.html#a532a2a6530a34432d28f6089193b2260">playrho::CalcGravitationalAcceleration()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#aecc1804bc7d37d3caf48181d46a38181">playrho::SeparationFinder::Get()</a>, <a class="el" href="namespaceplayrho.html#a5428024c9b1acdcad4f6a9d3373e7ff4">playrho::GetMassData()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#a78e7e25eab45e75f897ed19c38743401">playrho::PulleyJoint::InitVelocityConstraints()</a>, <a class="el" href="namespaceplayrho.html#a6cabf3aac9e547fb7937275f50068381">playrho::RayCast()</a>, <a class="el" href="classplayrho_1_1EdgeShape.html#aafcf389f099bece8e2db6371effe6784">playrho::EdgeShape::Set()</a>, <a class="el" href="classplayrho_1_1PolygonShape.html#a0482e18f3f8759c35388688aed5154f5">playrho::PolygonShape::Set()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#a52645f7db87f606b7d01e402295f4a26">playrho::FrictionJoint::SolveVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#ab3acf9e00b50ba7a5c7ab0a065b76dda">playrho::MotorJoint::SolveVelocityConstraints()</a>, and <a class="el" href="classplayrho_1_1MouseJoint.html#a5262f70a2f2d296a5c9bbb6fffbd69cb">playrho::MouseJoint::SolveVelocityConstraints()</a>.</p>

</div>
</div>
<a id="ga999a90fd3cc89960c512bbc00c37aab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999a90fd3cc89960c512bbc00c37aab7">&#9670;&nbsp;</a></span>InverseRotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InverseRotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse rotates a vector. </p>
<p>This is the inverse of rotating a vector - it undoes what rotate does. I.e. this effectively subtracts from the angle of the given vector the angle that's expressed by the angle parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> to reverse rotate. </td></tr>
    <tr><td class="paramname">angle</td><td>Expresses the angle to reverse rotate the given vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga894bcf52e04e21184227d1f872b9fd1c" title="Rotates a vector by a given angle. ">Rotate</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#ac0bed42717184a2866593f4c3a6bfedd">playrho::Distance()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a8a17c3a10337c840c928f5c750c07c4a">playrho::SeparationFinder::FindMinSeparationForFaceA()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a38701a732aa40dc5c70970b122382cb3">playrho::SeparationFinder::FindMinSeparationForFaceB()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a6f82f0e62d89781e6488ddc093c275ff">playrho::SeparationFinder::FindMinSeparationForPoints()</a>, <a class="el" href="namespaceplayrho.html#a5a04f9943fad8b814d21f753d7b8c7e5">playrho::GetLocalVector()</a>, <a class="el" href="group__Math.html#ga1866cb856a308673d77fe28ff1657b60">playrho::InverseTransform()</a>, and <a class="el" href="group__Math.html#gaf6af2739f6bfd0ec9d1e0824c960c3f6">playrho::MulT()</a>.</p>

</div>
</div>
<a id="ga1866cb856a308673d77fe28ff1657b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1866cb856a308673d77fe28ff1657b60">&#9670;&nbsp;</a></span>InverseTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> playrho::InverseTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse transforms the given 2-D vector with the given transformation. </p>
<p>Inverse translate and rotate the given 2-D vector according to the translation and rotation defined by the given transformation. </p><dl class="section note"><dt>Note</dt><dd>Passing the output of this function to <code>Transform</code> (with the same transformation again) will result in the original vector being returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceplayrho.html#a6a71364f5b072a1b29770acc42d30c40" title="Transforms the given shape by the given transformation. ">Transform</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>2-D vector to inverse transform (inverse translate and inverse rotate). </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="structplayrho_1_1Transformation.html" title="Describes a geometric transformation. ">Transformation</a> (a translation and rotation) to inversely apply to the given vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse transformed vector. </dd></dl>

</div>
</div>
<a id="ga76721557b2b677d24efa2d0415954be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76721557b2b677d24efa2d0415954be5">&#9670;&nbsp;</a></span>IsOdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsOdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is-odd. </p>
<p>Determines whether the given integral value is odd (as opposed to being even). </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#acad38ef6ac1537641203f3eb15225235">playrho::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="gae1e3299e5a7b20d8d77ab30505421ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1e3299e5a7b20d8d77ab30505421ca3">&#9670;&nbsp;</a></span>ModuloViaFmod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::type playrho::ModuloViaFmod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo operation using std::fmod. </p>
<dl class="section note"><dt>Note</dt><dd>Modulo via std::fmod appears slower than via std::trunc. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200" title="Modulo operation using std::trunc. ">ModuloViaTrunc</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized()</a>.</p>

</div>
</div>
<a id="ga84e7cb2a415fcb956202c8d7e1b1d200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e7cb2a415fcb956202c8d7e1b1d200">&#9670;&nbsp;</a></span>ModuloViaTrunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::ModuloViaTrunc </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo operation using std::trunc. </p>
<dl class="section note"><dt>Note</dt><dd>Modulo via std::fmod appears slower than via std::trunc. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#gae1e3299e5a7b20d8d77ab30505421ca3" title="Modulo operation using std::fmod. ">ModuloViaFmod</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized()</a>.</p>

</div>
</div>
<a id="gad76b0dc85088e062731fd7868aa78a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76b0dc85088e062731fd7868aa78a57">&#9670;&nbsp;</a></span>Mul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> playrho::Mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a given transformation by another given transformation. </p>
<dl class="section note"><dt>Note</dt><dd>v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p </dd></dl>

</div>
</div>
<a id="gaf6af2739f6bfd0ec9d1e0824c960c3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6af2739f6bfd0ec9d1e0824c960c3f6">&#9670;&nbsp;</a></span>MulT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> playrho::MulT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse multiplies a given transformation by another given transformation. </p>
<dl class="section note"><dt>Note</dt><dd>v2 = A.q' * (B.q * v1 + B.p - A.p) = A.q' * B.q * v1 + A.q' * (B.p - A.p) </dd></dl>

</div>
</div>
<a id="ga0ad2d1e2b11362e91193d313ee00e78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad2d1e2b11362e91193d313ee00e78c">&#9670;&nbsp;</a></span>NextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t playrho::NextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next largest power of 2. </p>
<p>Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next largest power of 2. For a 64-bit value:" </p>

</div>
</div>
<a id="ga894bcf52e04e21184227d1f872b9fd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga894bcf52e04e21184227d1f872b9fd1c">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1UnitVec2.html">UnitVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates a vector by a given angle. </p>
<p>This rotates a vector by the angle expressed by the angle parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector. ">Vector</a> to forward rotate. </td></tr>
    <tr><td class="paramname">angle</td><td>Expresses the angle to forward rotate the given vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga999a90fd3cc89960c512bbc00c37aab7" title="Inverse rotates a vector. ">InverseRotate</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1SeparationFinder.html#a45eafe957d5e21a37daf453f9b114163">playrho::SeparationFinder::EvaluateForFaceA()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a375b7881a41af8ea83efe0c8b3f9b3e6">playrho::SeparationFinder::EvaluateForFaceB()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a8a17c3a10337c840c928f5c750c07c4a">playrho::SeparationFinder::FindMinSeparationForFaceA()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#a38701a732aa40dc5c70970b122382cb3">playrho::SeparationFinder::FindMinSeparationForFaceB()</a>, <a class="el" href="classplayrho_1_1SeparationFinder.html#aecc1804bc7d37d3caf48181d46a38181">playrho::SeparationFinder::Get()</a>, <a class="el" href="namespaceplayrho.html#adcd27abba8be9fe2f9c2e02fa2bbcd86">playrho::GetLinearVelocity()</a>, <a class="el" href="namespaceplayrho.html#ae704de91e1e03a4a82d1f80aa4114a42">playrho::GetMaxSeparation()</a>, <a class="el" href="group__Math.html#ga4d83c58301aba934e46490f07d804645">playrho::GetTransformation()</a>, <a class="el" href="namespaceplayrho.html#a0ccc8fe53ed54beba80db7046ab8ddf0">playrho::GetWorldVector()</a>, <a class="el" href="classplayrho_1_1FrictionJoint.html#ab38d5b1be2fa8c6a05ae5bf02f6c7932">playrho::FrictionJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#acd94fcbcef70709e32bede3fd55be593">playrho::RopeJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WeldJoint.html#a9b45158543eb8a7088d3f21f4e313b67">playrho::WeldJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#a78e7e25eab45e75f897ed19c38743401">playrho::PulleyJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MotorJoint.html#a095885c8c90e9f82d2f525b1debc2835">playrho::MotorJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#a3973856f2b8ccefad127d829e1ccb302">playrho::DistanceJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1MouseJoint.html#ae80012204f951d3147d0c1fccd669f7a">playrho::MouseJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a7a26e97c6abcbf17a22647a856101236">playrho::WheelJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#ae4c8524060c5ec7235767fc35d97a4df">playrho::PrismaticJoint::InitVelocityConstraints()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#ab17f18569ada37b4f107932ce849bd06">playrho::RevoluteJoint::InitVelocityConstraints()</a>, <a class="el" href="group__Math.html#gad76b0dc85088e062731fd7868aa78a57">playrho::Mul()</a>, <a class="el" href="group__RayCastGroup.html#gabc2e992343e201f48c1956753a530247">playrho::RayCast()</a>, <a class="el" href="classplayrho_1_1WeldJoint.html#a99e2af4d15574d310e13b3a7f28ed3e3">playrho::WeldJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1RopeJoint.html#a0753352f143b872d629f9cd780bc9e68">playrho::RopeJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PulleyJoint.html#abff2e18760b22a8fda48627f908fda46">playrho::PulleyJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1DistanceJoint.html#aaae0fdf05f7ebef72e958aa8919bed82">playrho::DistanceJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1WheelJoint.html#a16e9ec84252c36fb24c9a87961620e96">playrho::WheelJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#a6d138a41b46dd4bf08f6197da6e83e86">playrho::PrismaticJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1RevoluteJoint.html#a8aa84707f3971ce7bb60097465c9abd4">playrho::RevoluteJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PolygonShape.html#a83a4772e5b0d4c4f7472b69b626b5d4b">playrho::PolygonShape::Transform()</a>, and <a class="el" href="group__Math.html#gae6f66519396d97c2588561efa6459dd6">playrho::Transform()</a>.</p>

</div>
</div>
<a id="ga9cf6fb58c36515834217c6b150b43772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cf6fb58c36515834217c6b150b43772">&#9670;&nbsp;</a></span>Secant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U playrho::Secant </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Secant method. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Secant_method">https://en.wikipedia.org/wiki/Secant_method</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#acad38ef6ac1537641203f3eb15225235">playrho::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="ga3846333746b73978c91e250c6f239ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3846333746b73978c91e250c6f239ce3">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1PrismaticJoint.html#a6d138a41b46dd4bf08f6197da6e83e86">playrho::PrismaticJoint::SolvePositionConstraints()</a>, and <a class="el" href="classplayrho_1_1RevoluteJoint.html#a8aa84707f3971ce7bb60097465c9abd4">playrho::RevoluteJoint::SolvePositionConstraints()</a>.</p>

</div>
</div>
<a id="ga0a0606abee6bd0cc122578a2a640f044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0606abee6bd0cc122578a2a640f044">&#9670;&nbsp;</a></span>Solve22()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Solve22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd>
<dd>
Solves only the upper 2-by-2 matrix equation. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1WeldJoint.html#a99e2af4d15574d310e13b3a7f28ed3e3">playrho::WeldJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#af4b715b541f5ad41fbb568d893c7b2c5">playrho::PrismaticJoint::SolveVelocityConstraints()</a>, and <a class="el" href="classplayrho_1_1RevoluteJoint.html#a59b88398432043019e0ca598aa3ff6fc">playrho::RevoluteJoint::SolveVelocityConstraints()</a>.</p>

</div>
</div>
<a id="gab4795a90a377c5335ce5b1900caf6d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4795a90a377c5335ce5b1900caf6d24">&#9670;&nbsp;</a></span>Solve33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> playrho::Solve33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1WeldJoint.html#a99e2af4d15574d310e13b3a7f28ed3e3">playrho::WeldJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#a6d138a41b46dd4bf08f6197da6e83e86">playrho::PrismaticJoint::SolvePositionConstraints()</a>, <a class="el" href="classplayrho_1_1PrismaticJoint.html#af4b715b541f5ad41fbb568d893c7b2c5">playrho::PrismaticJoint::SolveVelocityConstraints()</a>, and <a class="el" href="classplayrho_1_1RevoluteJoint.html#a59b88398432043019e0ca598aa3ff6fc">playrho::RevoluteJoint::SolveVelocityConstraints()</a>.</p>

</div>
</div>
<a id="ga0fb719b00fc92c4e84de7115834c745d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb719b00fc92c4e84de7115834c745d">&#9670;&nbsp;</a></span>Transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> playrho::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a matrix times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another. </p>
<p>Multiplies a matrix by a vector. </p>

</div>
</div>
<a id="gae6f66519396d97c2588561efa6459dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6f66519396d97c2588561efa6459dd6">&#9670;&nbsp;</a></span>Transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> playrho::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Transformation.html">Transformation</a>&#160;</td>
          <td class="paramname"><em>xfm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the given 2-D vector with the given transformation. </p>
<p>Rotate and translate the given 2-D linear position according to the rotation and translation defined by the given transformation. </p><dl class="section note"><dt>Note</dt><dd>Passing the output of this function to <code>InverseTransform</code> (with the same transformation again) will result in the original vector being returned. </dd>
<dd>
For a 2-D linear position of the origin (0, 0), the result is simply the translation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__Math.html#ga819a9ef6f9c3d492b5177ca25077618e" title="Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms th...">InverseTransform</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>2-D position to transform (to rotate and then translate). </td></tr>
    <tr><td class="paramname">xfm</td><td><a class="el" href="structplayrho_1_1Transformation.html" title="Describes a geometric transformation. ">Transformation</a> (a translation and rotation) to apply to the given vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotated and translated vector. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 30 2017 12:16:52 for PlayRho by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
